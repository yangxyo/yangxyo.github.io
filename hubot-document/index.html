<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 5.4.0"><link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png"><link rel="mask-icon" href="/images/safari-pinned-tab.svg" color="#222"><link rel="manifest" href="/images/site.webmanifest"><meta name="google-site-verification" content="k5HBUjLU81xJuWb8xJnZv0UgiQblDBrNU3i_164wuTI"><meta name="msvalidate.01" content="B8100FBA99CDE591E1C042A3608C96E9"><meta name="yandex-verification" content="d950e9c7ce2375f9"><meta name="baidu-site-verification" content="7CEDnF5GIr"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.4/css/all.min.css" integrity="sha256-mUZM63G8m73Mcidfrv5E+Y61y7a12O5mW4ezU3bxqW4=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous"><script class="next-config" data-name="main" type="application/json">{"hostname":"blog.xyang.xin","root":"/","images":"/images","scheme":"Mist","version":"8.7.1","exturl":false,"sidebar":{"position":"right","display":"post","padding":18,"offset":12},"copycode":true,"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":true,"pangu":true,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":true,"nav":null},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script><meta name="description" content="Hubot 官方文档原文链接🔗 概览Hubot 起步您需要node.js和npm。安装它们后，我们就可以安装 hubot 生成器： 1$ npm install -g yo generator-hubot  这条命令将给我们带来hubot yeoman生成器。现在我们就可以先创建一个的文件夹，然后在里面生成一个新的hubot实例。例如，如果我们想制造一个叫 myhubot的机器人： 123$ m"><meta property="og:type" content="article"><meta property="og:title" content="Hubot 官方文档（译）"><meta property="og:url" content="http://blog.xyang.xin/hubot-document/index.html"><meta property="og:site_name" content="韶 光"><meta property="og:description" content="Hubot 官方文档原文链接🔗 概览Hubot 起步您需要node.js和npm。安装它们后，我们就可以安装 hubot 生成器： 1$ npm install -g yo generator-hubot  这条命令将给我们带来hubot yeoman生成器。现在我们就可以先创建一个的文件夹，然后在里面生成一个新的hubot实例。例如，如果我们想制造一个叫 myhubot的机器人： 123$ m"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://images.xyang.xin/2021%2F09%2F01%2Fhubot-avatar.png"><meta property="article:published_time" content="2021-09-02T20:27:46.000Z"><meta property="article:modified_time" content="2021-09-07T09:34:51.569Z"><meta property="article:author" content="杨欣雨"><meta property="article:tag" content="hubot"><meta property="article:tag" content="chatops"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://images.xyang.xin/2021%2F09%2F01%2Fhubot-avatar.png"><link rel="canonical" href="http://blog.xyang.xin/hubot-document/"><script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"http://blog.xyang.xin/hubot-document/","path":"hubot-document/","title":"Hubot 官方文档（译）"}</script><script class="next-config" data-name="calendar" type="application/json">""</script><title>Hubot 官方文档（译） | 韶 光</title><noscript><link rel="stylesheet" href="/css/noscript.css"></noscript><link rel="alternate" href="/atom.xml" title="韶 光" type="application/atom+xml"></head><body itemscope itemtype="http://schema.org/WebPage" class="use-motion"><div class="headband"></div><main class="main"><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏" role="button"><span class="toggle-line"></span><span class="toggle-line"></span><span class="toggle-line"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><i class="logo-line"></i><h1 class="site-title">韶 光</h1><i class="logo-line"></i></a><p class="site-subtitle" itemprop="description">Yang Xinyu's Personal Blog</p></div><div class="site-nav-right"><div class="toggle popup-trigger"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class="site-nav"><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-信息技术"><a href="/categories/%E4%BF%A1%E6%81%AF%E6%8A%80%E6%9C%AF/" rel="section"><i class="fa fa-bolt fa-fw"></i>信息技术</a></li><li class="menu-item menu-item-思想文化"><a href="/categories/%E6%80%9D%E6%83%B3%E6%96%87%E5%8C%96/" rel="section"><i class="fa fa-bookmark fa-fw"></i>思想文化</a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i> 搜索</a></li></ul></nav><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"><input autocomplete="off" autocapitalize="off" maxlength="80" placeholder="搜索..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close" role="button"><i class="fa fa-times-circle"></i></span></div><div class="search-result-container no-result"><div class="search-result-icon"><i class="fa fa-spinner fa-pulse fa-5x"></i></div></div></div></div></div><div class="toggle sidebar-toggle" role="button"><span class="toggle-line"></span><span class="toggle-line"></span><span class="toggle-line"></span></div><aside class="sidebar"><div class="sidebar-inner sidebar-nav-active sidebar-toc-active"><ul class="sidebar-nav"><li class="sidebar-nav-toc">文章目录</li><li class="sidebar-nav-overview">站点概览</li></ul><div class="sidebar-panel-container"><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Hubot-%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3"><span class="nav-number">1.</span> <span class="nav-text">Hubot 官方文档</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A6%82%E8%A7%88"><span class="nav-number">1.1.</span> <span class="nav-text">概览</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Hubot-%E8%B5%B7%E6%AD%A5"><span class="nav-number">1.1.1.</span> <span class="nav-text">Hubot 起步</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%84%9A%E6%9C%AC"><span class="nav-number">1.1.2.</span> <span class="nav-text">脚本</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%82%E9%85%8D%E5%99%A8"><span class="nav-number">1.1.3.</span> <span class="nav-text">适配器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%83%A8%E7%BD%B2"><span class="nav-number">1.1.4.</span> <span class="nav-text">部署</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A8%A1%E5%BC%8F"><span class="nav-number">1.1.5.</span> <span class="nav-text">模式</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%84%9A%E6%9C%AC-1"><span class="nav-number">1.2.</span> <span class="nav-text">脚本</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%84%9A%E6%9C%AC%E5%89%96%E6%9E%90"><span class="nav-number">1.2.1.</span> <span class="nav-text">脚本剖析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%81%86%E5%90%AC%E5%92%8C%E5%93%8D%E5%BA%94"><span class="nav-number">1.2.2.</span> <span class="nav-text">聆听和响应</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%91%E9%80%81%E5%92%8C%E5%9B%9E%E5%A4%8D"><span class="nav-number">1.2.3.</span> <span class="nav-text">发送和回复</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%99%E6%88%BF%E9%97%B4%E6%88%96%E7%94%A8%E6%88%B7%E7%9A%84%E6%B6%88%E6%81%AF"><span class="nav-number">1.2.4.</span> <span class="nav-text">给房间或用户的消息</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8D%95%E8%8E%B7%E6%95%B0%E6%8D%AE"><span class="nav-number">1.2.5.</span> <span class="nav-text">捕获数据</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B0%83%E7%94%A8-HTTP"><span class="nav-number">1.2.6.</span> <span class="nav-text">调用 HTTP</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#JSON"><span class="nav-number">1.2.6.1.</span> <span class="nav-text">JSON</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#XML"><span class="nav-number">1.2.6.2.</span> <span class="nav-text">XML</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%90%A4%E5%B9%95%E6%8A%93%E5%8F%96"><span class="nav-number">1.2.6.3.</span> <span class="nav-text">萤幕抓取</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%AB%98%E7%BA%A7-HTTP-%E5%92%8C-HTTPS-%E8%AE%BE%E7%BD%AE"><span class="nav-number">1.2.6.4.</span> <span class="nav-text">高级 HTTP 和 HTTPS 设置</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9A%8F%E6%9C%BA"><span class="nav-number">1.2.7.</span> <span class="nav-text">随机</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BB%E9%A2%98"><span class="nav-number">1.2.8.</span> <span class="nav-text">主题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8A%A0%E5%85%A5%E5%92%8C%E7%A6%BB%E5%BC%80"><span class="nav-number">1.2.9.</span> <span class="nav-text">加入和离开</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E7%9B%91%E5%90%AC%E5%99%A8"><span class="nav-number">1.2.10.</span> <span class="nav-text">自定义监听器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F"><span class="nav-number">1.2.11.</span> <span class="nav-text">环境变量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BE%9D%E8%B5%96"><span class="nav-number">1.2.12.</span> <span class="nav-text">依赖</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B6%85%E6%97%B6%E5%92%8C%E9%97%B4%E9%9A%94"><span class="nav-number">1.2.13.</span> <span class="nav-text">超时和间隔</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#HTTP-%E7%9B%91%E5%90%AC%E5%99%A8"><span class="nav-number">1.2.14.</span> <span class="nav-text">HTTP 监听器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8B%E4%BB%B6"><span class="nav-number">1.2.15.</span> <span class="nav-text">事件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86"><span class="nav-number">1.2.16.</span> <span class="nav-text">错误处理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%84%9A%E6%9C%AC%E6%96%87%E6%A1%A3"><span class="nav-number">1.2.17.</span> <span class="nav-text">脚本文档</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8C%81%E4%B9%85%E5%8C%96"><span class="nav-number">1.2.18.</span> <span class="nav-text">持久化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%84%9A%E6%9C%AC%E5%8A%A0%E8%BD%BD"><span class="nav-number">1.2.19.</span> <span class="nav-text">脚本加载</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%86%E4%BA%AB%E8%84%9A%E6%9C%AC"><span class="nav-number">1.2.20.</span> <span class="nav-text">分享脚本</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9F%A5%E7%9C%8B%E8%84%9A%E6%9C%AC%E6%98%AF%E5%90%A6%E5%B7%B2%E5%AD%98%E5%9C%A8"><span class="nav-number">1.2.20.1.</span> <span class="nav-text">查看脚本是否已存在</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E8%84%9A%E6%9C%AC%E7%A8%8B%E5%BA%8F%E5%8C%85"><span class="nav-number">1.2.20.2.</span> <span class="nav-text">创建一个脚本程序包</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%9B%91%E5%90%AC%E5%99%A8%E5%85%83%E6%95%B0%E6%8D%AE"><span class="nav-number">1.2.21.</span> <span class="nav-text">监听器元数据</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%AD%E9%97%B4%E4%BB%B6"><span class="nav-number">1.2.22.</span> <span class="nav-text">中间件</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B%E5%92%8C-API"><span class="nav-number">1.2.22.1.</span> <span class="nav-text">执行过程和 API</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86-1"><span class="nav-number">1.2.22.2.</span> <span class="nav-text">错误处理</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Listener-%E4%B8%AD%E9%97%B4%E4%BB%B6"><span class="nav-number">1.2.23.</span> <span class="nav-text">Listener 中间件</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Listener-%E4%B8%AD%E9%97%B4%E4%BB%B6%E7%A4%BA%E4%BE%8B"><span class="nav-number">1.2.23.1.</span> <span class="nav-text">Listener 中间件示例</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Listener-%E4%B8%AD%E9%97%B4%E4%BB%B6-API"><span class="nav-number">1.2.23.2.</span> <span class="nav-text">Listener 中间件 API</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Receive-%E4%B8%AD%E9%97%B4%E4%BB%B6"><span class="nav-number">1.2.24.</span> <span class="nav-text">Receive 中间件</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Receive-%E4%B8%AD%E9%97%B4%E4%BB%B6%E7%A4%BA%E4%BE%8B"><span class="nav-number">1.2.24.1.</span> <span class="nav-text">Receive 中间件示例</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Receive-%E4%B8%AD%E9%97%B4%E4%BB%B6-API"><span class="nav-number">1.2.24.2.</span> <span class="nav-text">Receive 中间件 API</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Response-%E4%B8%AD%E9%97%B4%E4%BB%B6"><span class="nav-number">1.2.25.</span> <span class="nav-text">Response 中间件</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Response-%E4%B8%AD%E9%97%B4%E4%BB%B6%E7%A4%BA%E4%BE%8B"><span class="nav-number">1.2.25.1.</span> <span class="nav-text">Response 中间件示例</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Response-%E4%B8%AD%E9%97%B4%E4%BB%B6-API"><span class="nav-number">1.2.25.2.</span> <span class="nav-text">Response 中间件 API</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B5%8B%E8%AF%95-hubot-%E8%84%9A%E6%9C%AC"><span class="nav-number">1.2.26.</span> <span class="nav-text">测试 hubot 脚本</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A8%A1%E5%BC%8F-1"><span class="nav-number">1.3.</span> <span class="nav-text">模式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%87%8D%E5%91%BD%E5%90%8Dhubot%E5%AE%9E%E4%BE%8B"><span class="nav-number">1.3.1.</span> <span class="nav-text">重命名hubot实例</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%83%E7%94%A8%E6%88%96%E9%87%8D%E5%91%BD%E5%90%8D%E7%9B%91%E5%90%AC%E5%99%A8"><span class="nav-number">1.3.2.</span> <span class="nav-text">弃用或重命名监听器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%9A%E8%BF%87%E4%BB%A3%E7%90%86%E8%BD%AC%E5%8F%91%E6%89%80%E6%9C%89-HTTP-%E8%AF%B7%E6%B1%82"><span class="nav-number">1.3.3.</span> <span class="nav-text">通过代理转发所有 HTTP 请求</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B6%88%E6%81%AF%E7%9A%84%E5%8A%A8%E6%80%81%E5%8C%B9%E9%85%8D"><span class="nav-number">1.3.4.</span> <span class="nav-text">消息的动态匹配</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%99%90%E5%88%B6%E5%91%BD%E4%BB%A4%E8%AE%BF%E9%97%AE"><span class="nav-number">1.3.5.</span> <span class="nav-text">限制命令访问</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%AE%80%E5%8D%95%E7%9A%84%E6%AF%8F%E4%B8%AA%E7%9B%91%E5%90%AC%E5%99%A8%E8%AE%BF%E9%97%AE"><span class="nav-number">1.3.5.1.</span> <span class="nav-text">简单的每个监听器访问</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%AF%8F%E4%B8%AA%E7%9B%91%E5%90%AC%E5%99%A8%E7%89%B9%E5%AE%9A%E7%9A%84%E8%AE%BF%E9%97%AE%E8%A7%84%E5%88%99"><span class="nav-number">1.3.5.2.</span> <span class="nav-text">每个监听器特定的访问规则</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%AF%8F%E4%B8%AA%E6%88%BF%E9%97%B4%E7%89%B9%E5%AE%9A%E7%9A%84%E8%AE%BF%E9%97%AE%E8%A7%84%E5%88%99"><span class="nav-number">1.3.5.3.</span> <span class="nav-text">每个房间特定的访问规则</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%80%82%E9%85%8D%E5%99%A8-1"><span class="nav-number">1.4.</span> <span class="nav-text">适配器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BC%96%E5%86%99%E6%82%A8%E8%87%AA%E5%B7%B1%E7%9A%84%E9%80%82%E9%85%8D%E5%99%A8"><span class="nav-number">1.4.1.</span> <span class="nav-text">编写您自己的适配器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Campfire-%E9%80%82%E9%85%8D%E5%99%A8"><span class="nav-number">1.4.2.</span> <span class="nav-text">Campfire 适配器</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%B5%B7%E6%AD%A5"><span class="nav-number">1.4.2.1.</span> <span class="nav-text">起步</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%85%8D%E7%BD%AE"><span class="nav-number">1.4.2.2.</span> <span class="nav-text">配置</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Campfire-API-%E4%BB%A4%E7%89%8C"><span class="nav-number">1.4.2.2.1.</span> <span class="nav-text">Campfire API 令牌</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Campfire-%E6%88%BF%E9%97%B4%E5%8F%B7"><span class="nav-number">1.4.2.2.2.</span> <span class="nav-text">Campfire 房间号</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Campfire-%E8%B4%A6%E6%88%B7"><span class="nav-number">1.4.2.2.3.</span> <span class="nav-text">Campfire 账户</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%9C%A8-Heroku-%E4%B8%8A%E9%85%8D%E7%BD%AE%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F"><span class="nav-number">1.4.2.2.4.</span> <span class="nav-text">在 Heroku 上配置环境变量</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%9C%A8-Unix-%E4%B8%8A%E9%85%8D%E7%BD%AE%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F"><span class="nav-number">1.4.2.2.5.</span> <span class="nav-text">在 Unix 上配置环境变量</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%9C%A8-Windows-%E4%B8%8A%E9%85%8D%E7%BD%AE%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F"><span class="nav-number">1.4.2.2.6.</span> <span class="nav-text">在 Windows 上配置环境变量</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Shell-%E9%80%82%E9%85%8D%E5%99%A8"><span class="nav-number">1.4.3.</span> <span class="nav-text">Shell 适配器</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%B5%B7%E6%AD%A5-1"><span class="nav-number">1.4.3.1.</span> <span class="nav-text">起步</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%85%8D%E7%BD%AE-1"><span class="nav-number">1.4.3.2.</span> <span class="nav-text">配置</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%80%E5%8F%91%E9%80%82%E9%85%8D%E5%99%A8"><span class="nav-number">1.4.4.</span> <span class="nav-text">开发适配器</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%80%82%E9%85%8D%E5%99%A8%E5%9F%BA%E7%A1%80"><span class="nav-number">1.4.4.1.</span> <span class="nav-text">适配器基础</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%85%8D%E7%BD%AE%E6%82%A8%E7%9A%84%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83"><span class="nav-number">1.4.4.2.</span> <span class="nav-text">配置您的开发环境</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Gochas"><span class="nav-number">1.4.4.3.</span> <span class="nav-text">Gochas</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%83%A8%E7%BD%B2-1"><span class="nav-number">1.5.</span> <span class="nav-text">部署</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%83%A8%E7%BD%B2%E5%88%B0-Heroku"><span class="nav-number">1.5.1.</span> <span class="nav-text">部署到 Heroku</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%83%A8%E7%BD%B2%E5%88%B0-Unix"><span class="nav-number">1.5.2.</span> <span class="nav-text">部署到 Unix</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#node-%E5%92%8C-npm"><span class="nav-number">1.5.2.1.</span> <span class="nav-text">node 和 npm</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9C%A8%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8A%E6%9B%B4%E6%96%B0%E4%BB%A3%E7%A0%81"><span class="nav-number">1.5.2.2.</span> <span class="nav-text">在服务器上更新代码</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%90%AF%E5%8A%A8%E3%80%81%E5%81%9C%E6%AD%A2%E5%92%8C%E9%87%8D%E5%90%AF-hubot"><span class="nav-number">1.5.2.3.</span> <span class="nav-text">启动、停止和重启 hubot</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BB%BA%E8%AE%AE"><span class="nav-number">1.5.2.4.</span> <span class="nav-text">建议</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%83%A8%E7%BD%B2%E5%88%B0-Windows"><span class="nav-number">1.5.3.</span> <span class="nav-text">部署到 Windows</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#node-%E5%92%8C-npm-1"><span class="nav-number">1.5.3.1.</span> <span class="nav-text">node 和 npm</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9B%B4%E6%96%B0%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8A%E7%9A%84%E4%BB%A3%E7%A0%81"><span class="nav-number">1.5.3.2.</span> <span class="nav-text">更新服务器上的代码</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AE%BE%E7%BD%AE%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F"><span class="nav-number">1.5.3.3.</span> <span class="nav-text">设置环境变量</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%90%AF%E5%8A%A8%E3%80%81%E5%81%9C%E6%AD%A2%E5%92%8C%E9%87%8D%E5%90%AF-hubot-1"><span class="nav-number">1.5.3.4.</span> <span class="nav-text">启动、停止和重启 hubot</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%89%A9%E5%85%85%E6%96%87%E6%A1%A3"><span class="nav-number">1.5.3.5.</span> <span class="nav-text">扩充文档</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%83%A8%E7%BD%B2%E5%88%B0-Azure"><span class="nav-number">1.5.4.</span> <span class="nav-text">部署到 Azure</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%95%85%E9%9A%9C%E6%8E%92%E9%99%A4%E6%8F%90%E7%A4%BA%E5%92%8C%E6%8A%80%E5%B7%A7"><span class="nav-number">1.5.4.1.</span> <span class="nav-text">故障排除提示和技巧</span></a></li></ol></li></ol></li></ol></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-overview"><div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="site-author-image" itemprop="image" alt="杨欣雨" src="https://images.xyang.xin/2018-12/war-soldier.jpeg"><p class="site-author-name" itemprop="name">杨欣雨</p><div class="site-description" itemprop="description">韶华易逝，享受这欢乐的美妙时光。</div></div><div class="site-state-wrap site-overview-item animated"><nav class="site-state"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">42</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/"><span class="site-state-item-count">2</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/"><span class="site-state-item-count">45</span> <span class="site-state-item-name">标签</span></a></div></nav></div><div class="links-of-author site-overview-item animated"><span class="links-of-author-item"><a href="https://github.com/yangxyo" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;yangxyo" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i> GitHub</a></span></div><div class="cc-license site-overview-item animated" itemprop="license"><a href="https://creativecommons.org/licenses/by-nc-nd/4.0/deed.zsh" class="cc-opacity" rel="noopener" target="_blank"><img src="https://cdn.jsdelivr.net/npm/@creativecommons/vocabulary@2020.11.3/assets/license_badges/small/by_nc_nd.svg" alt="Creative Commons"></a></div><div class="links-of-blogroll site-overview-item animated"><div class="links-of-blogroll-title"><i class="fa fa-globe fa-fw"></i> Links</div><ul class="links-of-blogroll-list"><li class="links-of-blogroll-item"><a href="http://www.ruanyifeng.com/blog/" title="http:&#x2F;&#x2F;www.ruanyifeng.com&#x2F;blog&#x2F;" rel="noopener" target="_blank">阮一峰的网络日志</a></li></ul></div></div></div></div></div></aside><div class="sidebar-dimmer"></div></header><div class="back-to-top" role="button" aria-label="返回顶部"><i class="fa fa-arrow-up"></i> <span>0%</span></div><div class="reading-progress-bar"></div><noscript><div class="noscript-warning">Theme NexT works best with JavaScript enabled</div></noscript><div class="main-inner post posts-expand"><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN"><link itemprop="mainEntityOfPage" href="http://blog.xyang.xin/hubot-document/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="https://images.xyang.xin/2018-12/war-soldier.jpeg"><meta itemprop="name" content="杨欣雨"><meta itemprop="description" content="韶华易逝，享受这欢乐的美妙时光。"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="韶 光"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">Hubot 官方文档（译）</h1><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i></span> <span class="post-meta-item-text">发表于</span> <time title="创建时间：2021-09-02 20:27:46" itemprop="dateCreated datePublished" datetime="2021-09-02T20:27:46Z">2021-09-02</time></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i></span> <span class="post-meta-item-text">更新于</span> <time title="修改时间：2021-09-07 09:34:51" itemprop="dateModified" datetime="2021-09-07T09:34:51Z">2021-09-07</time></span></div></div></header><div class="post-body" itemprop="articleBody"><h1 id="Hubot-官方文档"><a href="#Hubot-官方文档" class="headerlink" title="Hubot 官方文档"></a>Hubot 官方文档</h1><p><a target="_blank" rel="noopener" href="https://hubot.github.com/docs/">原文链接🔗</a><br><img data-src="https://images.xyang.xin/2021%2F09%2F01%2Fhubot-avatar.png" alt="hubot-avatar.png"></p><h2 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h2><h3 id="Hubot-起步"><a href="#Hubot-起步" class="headerlink" title="Hubot 起步"></a>Hubot 起步</h3><p>您需要<a target="_blank" rel="noopener" href="https://docs.npmjs.com/getting-started/installing-node">node.js和npm</a>。安装它们后，我们就可以安装 hubot 生成器：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> npm install -g yo generator-hubot</span></span><br></pre></td></tr></table></figure><p>这条命令将给我们带来hubot <a target="_blank" rel="noopener" href="http://yeoman.io/">yeoman</a>生成器。现在我们就可以先创建一个的文件夹，然后在里面生成一个新的hubot实例。例如，如果我们想制造一个叫 myhubot的机器人：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> mkdir myhubot</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> myhubot</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> yo hubot</span></span><br></pre></td></tr></table></figure><span id="more"></span><p>执行命令后，您将被问到一些关于谁在创建机器人和您将使用哪个适配器的问题。适配器是hubot与不同聊天提供商集成的方式。</p><p>如果您希望在没有交互提示配置的情况下自动化您的 hubot 构建，您可以将以下选项添加到 <code>yo hubot</code> 命令中：</p><table><thead><tr><th>Option</th><th>Description</th></tr></thead><tbody><tr><td>--owner=”Bot Wrangler <a href="mailto:&#x62;&#x77;&#64;&#101;&#120;&#x61;&#x6d;&#x70;&#x6c;&#x65;&#46;&#99;&#x6f;&#x6d;">&#x62;&#x77;&#64;&#101;&#120;&#x61;&#x6d;&#x70;&#x6c;&#x65;&#46;&#99;&#x6f;&#x6d;</a>“</td><td>Bot owner, e.g. “Bot Wrangler <a href="mailto:bw@example.com">bw@example.com</a>”</td></tr><tr><td>--name=”Hubot”</td><td>bot 名, e.g. “Hubot”</td></tr><tr><td>--description=”Delightfully aware robutt”</td><td>bot 描述, e.g. “Delightfully aware robutt”</td></tr><tr><td>--adapter=campfire</td><td>bot 适配器, e.g. “campfire”</td></tr><tr><td>--defaults</td><td>所有声明都设置为默认值且无需提示</td></tr></tbody></table><p>您现在就拥有了自己的一个多功能的 hubot！为方便起见，有一个<code>bin/hubot</code>命令，用于处理安装 npm 依赖项、加载脚本，然后启动您的 hubot。</p><p>Hubot 需要 Redis 来持久化数据，因此在您可以在自己的计算机上启动 hubot 之前，您应该在本地主机上安装 Redis。如果只是想在没有 Redis 的情况下测试 Hubot，那么您可以从 <code>external-scripts.json</code> 中删除 <code>hubot-redis-brain</code>。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> bin/hubot</span></span><br><span class="line"><span class="meta">Hubot&gt;</span></span><br></pre></td></tr></table></figure><p>这将使用 <a target="_blank" rel="noopener" href="https://hubot.github.com/docs/adapters/shell/">shell 适配器</a>启动 hubot，这对开发非常有用。记下 <code>Hubot&gt;</code>，这是您的 hubot 将用命令响应的名称。例如，列出可用命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> bin/hubot</span></span><br><span class="line"><span class="meta">hubot&gt;</span><span class="bash"> hubot <span class="built_in">help</span></span></span><br><span class="line">hubot adapter - Reply with the adapter</span><br><span class="line">hubot animate me &lt;query&gt; - The same thing as `image me`, except adds a few parameters to try to return an animated GIF instead.</span><br><span class="line">hubot echo &lt;text&gt; - Reply back with &lt;text&gt;</span><br><span class="line">hubot help - Displays all of the help commands that hubot knows about.</span><br><span class="line">hubot help &lt;query&gt; - Displays all help commands that match &lt;query&gt;.</span><br><span class="line">hubot image me &lt;query&gt; - The Original. Queries Google Images for &lt;query&gt; and returns a random top result.</span><br><span class="line">hubot map me &lt;query&gt; - Returns a map view of the area returned by `query`.</span><br><span class="line">hubot mustache me &lt;query&gt; - Searches Google Images for the specified query and mustaches it.</span><br><span class="line">hubot mustache me &lt;url&gt; - Adds a mustache to the specified URL.</span><br><span class="line">hubot ping - Reply with pong</span><br><span class="line">hubot pronounce &lt;phrase&gt; in &lt;language&gt; - Provides pronunciation of &lt;phrase&gt; (&lt;language&gt; is optional)</span><br><span class="line">hubot pug bomb N - get N pugs</span><br><span class="line">hubot pug me - Receive a pug</span><br><span class="line">hubot the rules - Make sure hubot still knows the rules.</span><br><span class="line">hubot time - Reply with current time</span><br><span class="line">hubot translate me &lt;phrase&gt; - Searches for a translation for the &lt;phrase&gt; and then prints that bad boy out.</span><br><span class="line">hubot translate me from &lt;source&gt; into &lt;target&gt; &lt;phrase&gt; - Translates &lt;phrase&gt; from &lt;source&gt; into &lt;target&gt;. Both &lt;source&gt; and &lt;target&gt; are optional</span><br><span class="line">hubot youtube me &lt;query&gt; - Searches YouTube for the query and returns the video embed link.</span><br><span class="line">ship it - Display a motivation squirrel</span><br></pre></td></tr></table></figure><p>您基本上都会想要改变您的 hubot 的名字来添加角色。 bin/hubot 需要一个 <code>--name</code>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">%</span><span class="bash"> bin/hubot --name myhubot</span></span><br><span class="line"><span class="meta">myhubot&gt;</span></span><br></pre></td></tr></table></figure><p>您的 hubot 现在将响应 <code>myhubot</code> 。这是不区分大小写的，可以以 <code>@</code> 为前缀或以 <code>:</code>为后缀。这些是等效的：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">MYHUBOT help</span><br><span class="line">myhubot help</span><br><span class="line">@myhubot help</span><br><span class="line">myhubot: help</span><br></pre></td></tr></table></figure><h3 id="脚本"><a href="#脚本" class="headerlink" title="脚本"></a>脚本</h3><p>Hubot 的力量来自于脚本。社区编写和维护着几百个脚本。通过使用 <code>hubot-scripts &lt;your-search-term&gt;</code> 查找 <a target="_blank" rel="noopener" href="https://www.npmjs.com/browse/keyword/hubot-scripts">NPM registry</a> 找到它们。例如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> npm search hubot-scripts github</span></span><br><span class="line">NAME                  DESCRIPTION</span><br><span class="line">hubot-deployer        Giving Hubot the ability to deploy GitHub repos to PaaS providers hubot hubot-scripts hubot-gith</span><br><span class="line">hubot-gh-release-pr   A hubot script to create GitHub&#x27;s PR for release</span><br><span class="line">hubot-github          Giving Hubot the ability to be a vital member of your github organization</span><br><span class="line">…</span><br></pre></td></tr></table></figure><p>要使用 NPM 包中的脚本：</p><ol><li>运行<code>npm install --save &lt;package-name&gt;</code>去添加该包作为依赖并安装它。</li><li>添加该包到<code>external-scripts.json</code>。</li><li>运行<code>npm home &lt;package-name&gt;</code>以打开脚本主页的浏览器窗口，您可以在其中找到有关配置和安装脚本的更多信息。</li></ol><p>您也可以将您自己的脚本放在<code>scripts/</code>目录下。放在这里的所有脚本都将被 hubot 自动加载和使用。阅读有关通过<a target="_blank" rel="noopener" href="https://hubot.github.com/docs/scripting/">编写自己的脚本</a>自定义 hubot 的更多信息。</p><h3 id="适配器"><a href="#适配器" class="headerlink" title="适配器"></a>适配器</h3><p>Hubot 使用适配器模式来支持多个聊天后端。这是<a target="_blank" rel="noopener" href="https://hubot.github.com/docs/adapters/">可用适配器的列表</a>，以及如何配置它们的详细信息。</p><h3 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h3><p>您可以将 hubot 部署到 Heroku，这是官方支持的方法。此外，您还可以将 hubot 部署到类似 UNIX 的系统或 Windows 中。请注意，部署到 Windows 的支持尚未得到官方支持。</p><ul><li><a target="_blank" rel="noopener" href="https://hubot.github.com/docs/deploying/heroku/">部署 hubot 到 Heroku</a></li><li><a target="_blank" rel="noopener" href="https://hubot.github.com/docs/deploying/unix/">部署 hubot 到 UNIX</a></li><li><a target="_blank" rel="noopener" href="https://hubot.github.com/docs/deploying/windows/">部署 hubot 到 Windows</a></li></ul><h3 id="模式"><a href="#模式" class="headerlink" title="模式"></a>模式</h3><p>使用自定义脚本，您可以快速自定义 hubot，使他（她）成为最具生命力的机器人。当您教您的 hubot 新的技能，阅读<a target="_blank" rel="noopener" href="https://hubot.github.com/docs/patterns/">docs/patterns.md</a> 里的一些漂亮的技巧，可能会派上用场。</p><h2 id="脚本-1"><a href="#脚本-1" class="headerlink" title="脚本"></a>脚本</h2><p>开箱即用的 hubot 不会做太多， 但它是一个可扩展的，可编脚本的机器人朋友。有<a target="_blank" rel="noopener" href="https://hubot.github.com/docs/#scripts">数以百计的脚本由社区编写和维护</a>，并且自己写起来也很容易。您可以在hubot的<code>scripts</code>目录中创建自定义脚本，或<a target="_blank" rel="noopener" href="https://hubot.github.com/docs/scripting/#creating-a-script-package">创建一个脚本包</a>，以便与社区共享！</p><h3 id="脚本剖析"><a href="#脚本剖析" class="headerlink" title="脚本剖析"></a>脚本剖析</h3><p>当您创建 hubot 时，生成器还创建了<code>scripts</code>目录。如果您看了一下那里，您会看到一些脚本的例子。脚本要成为脚本，它需要：</p><ul><li>在 hubot 脚本加载的目录里（默认为<code>src/scripts</code>和<code>scripts</code>）</li><li>是一个<code>.coffee</code>或者<code>.js</code>文件</li><li>导出一个函数</li></ul><p>导出一个函数，我们的意思是：</p><figure class="highlight coffee"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.<span class="built_in">exports</span> = <span class="function"><span class="params">(robot)</span> -&gt;</span></span><br><span class="line">  <span class="comment"># your code here</span></span><br></pre></td></tr></table></figure><p>机器人参数是您的机器人朋友的实例。在这一点上，我们可以开始编写一些很棒的脚本。</p><h3 id="聆听和响应"><a href="#聆听和响应" class="headerlink" title="聆听和响应"></a>聆听和响应</h3><p>由于这是一个聊天机器人，最常见的交互是基于消息。Hubot 可以<code>hear</code>在房间里说的消息，或直接<code>response</code>专门传达给它的消息。这两种方法都以一个正则表达式和一个回调函数作为参数。例如：</p><figure class="highlight coffee"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.<span class="built_in">exports</span> = <span class="function"><span class="params">(robot)</span> -&gt;</span></span><br><span class="line">  robot.hear <span class="regexp">/badger/i</span>, <span class="function"><span class="params">(res)</span> -&gt;</span></span><br><span class="line">    <span class="comment"># your code here</span></span><br><span class="line"></span><br><span class="line">  robot.respond <span class="regexp">/open the pod bay doors/i</span>, <span class="function"><span class="params">(res)</span> -&gt;</span></span><br><span class="line">    <span class="comment"># your code here</span></span><br></pre></td></tr></table></figure><p>每当一个消息的文本匹配时，<code>robot.hear /badger/</code>的回调就会被调用。例如：</p><ul><li>Stop badgering the witness</li><li>badger me</li><li>what exactly is a badger anyways</li></ul><p><code>robot.respond /open the pod bay doors/i</code> 的回调仅当消息紧跟着机器人的名字或者别名被调用。如果机器人的名称是 HAL，别名是 /，则此回调将被以下触发：</p><ul><li>hal open the pod bay doors</li><li>HAL: open the pod bay doors</li><li>@HAL open the pod bay doors</li><li>/open the pod bay doors</li></ul><p>它不会被调用：</p><ul><li>HAL: please open the pod bay doors<ul><li>因为它的响应与机器人名称后紧接着的文本绑定</li></ul></li><li>has anyone ever mentioned how lovely you are when you open the pod bay doors?<ul><li>因为它确少机器人的名字</li></ul></li></ul><h3 id="发送和回复"><a href="#发送和回复" class="headerlink" title="发送和回复"></a>发送和回复</h3><p><code>res</code>参数是<code>Response</code>的实例（在历史上，这个参数是 <code>msg</code>，您可能会看到其他脚本使用它）。有了它，您可以将消息<code>send</code>回 <code>res</code>来的房间，<code>emote</code>一个消息到一个房间（如果给定的适配器支持它），或<code>reply</code>发送消息的人。例如：</p><figure class="highlight coffee"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.<span class="built_in">exports</span> = <span class="function"><span class="params">(robot)</span> -&gt;</span></span><br><span class="line">  robot.hear <span class="regexp">/badger/i</span>, <span class="function"><span class="params">(res)</span> -&gt;</span></span><br><span class="line">    res.send <span class="string">&quot;Badgers? BADGERS? WE DON&#x27;T NEED NO STINKIN BADGERS&quot;</span></span><br><span class="line"></span><br><span class="line">  robot.respond <span class="regexp">/open the pod bay doors/i</span>, <span class="function"><span class="params">(res)</span> -&gt;</span></span><br><span class="line">    res.reply <span class="string">&quot;I&#x27;m afraid I can&#x27;t let you do that.&quot;</span></span><br><span class="line"></span><br><span class="line">  robot.hear <span class="regexp">/I like pie/i</span>, <span class="function"><span class="params">(res)</span> -&gt;</span></span><br><span class="line">    res.emote <span class="string">&quot;makes a freshly baked pie&quot;</span></span><br></pre></td></tr></table></figure><p><code>robot.hear /badgers/</code>的回调发送指定的消息，而不管向谁说： “Badgers? BADGERS? WE DON’T NEED NO STINKIN BADGERS”。</p><p>如果一个用户 Dave 说 “HAL: open the pod bay doors”， <code>robot.respond /open the pod bay doors/i</code> 的回调发送一个消息<code>Dave: I’m afraid I can’t let you do that.</code></p><h3 id="给房间或用户的消息"><a href="#给房间或用户的消息" class="headerlink" title="给房间或用户的消息"></a>给房间或用户的消息</h3><p>消息可以使用 <code>messageRoom</code> 功能发送给指定的房间或用户。</p><figure class="highlight coffee"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.<span class="built_in">exports</span> = <span class="function"><span class="params">(robot)</span> -&gt;</span></span><br><span class="line"></span><br><span class="line">  robot.hear <span class="regexp">/green eggs/i</span>, <span class="function"><span class="params">(res)</span> -&gt;</span></span><br><span class="line">    room = <span class="string">&quot;mytestroom&quot;</span></span><br><span class="line">    robot.messageRoom room, <span class="string">&quot;I do not like green eggs and ham.  I do not like them sam-I-am.&quot;</span></span><br></pre></td></tr></table></figure><p>如果需要，可以明确指定用户名，或使用响应对象，可以向原始发件人发送私人消息。</p><figure class="highlight coffee"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">robot.respond <span class="regexp">/I don&#x27;t like Sam-I-am/i</span>, <span class="function"><span class="params">(res)</span> -&gt;</span></span><br><span class="line">  room =  <span class="string">&#x27;joemanager&#x27;</span></span><br><span class="line">  robot.messageRoom room, <span class="string">&quot;Someone does not like Dr. Seus&quot;</span></span><br><span class="line">  res.reply  <span class="string">&quot;That Sam-I-am\nThat Sam-I-am\nI do not like\nthat Sam-I-am&quot;</span></span><br><span class="line"></span><br><span class="line">robot.hear <span class="regexp">/Sam-I-am/i</span>, <span class="function"><span class="params">(res)</span> -&gt;</span></span><br><span class="line">  room =  res.envelope.user.name</span><br><span class="line">  robot.messageRoom room, <span class="string">&quot;That Sam-I-am\nThat Sam-I-am\nI do not like\nthat Sam-I-am&quot;</span></span><br></pre></td></tr></table></figure><h3 id="捕获数据"><a href="#捕获数据" class="headerlink" title="捕获数据"></a>捕获数据</h3><p>到目前为止，我们的脚本已经有静态响应，这虽然有趣，在功能方面却很薄弱。<code>res.match</code>的结果是将传入的消息与正则表达进行匹配。这只是一个 <a target="_blank" rel="noopener" href="http://www.w3schools.com/jsref/jsref_match.asp">JavaScript thing</a>， 它最终是一个数组， 索引0是与表达式匹配的全文。如果包括捕获组，这些组将填充 <code>res.match</code>。例如，如果我们更新脚本：</p><figure class="highlight coffee"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">robot.respond <span class="regexp">/open the (.*) doors/i</span>, <span class="function"><span class="params">(res)</span> -&gt;</span></span><br><span class="line">    <span class="comment"># your code here</span></span><br></pre></td></tr></table></figure><p>如果Dave说“HAL: open the pod bay doors”，<code>res.match[0]</code>就成了<code>open the pod bay doors</code>，<code>res.match[1]</code>则为<code>pod bay</code>。现在我们可以开始做更多动态的东西了：</p><figure class="highlight coffee"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">robot.respond <span class="regexp">/open the (.*) doors/i</span>, <span class="function"><span class="params">(res)</span> -&gt;</span></span><br><span class="line">  doorType = res.match[<span class="number">1</span>]</span><br><span class="line">  <span class="keyword">if</span> doorType <span class="keyword">is</span> <span class="string">&quot;pod bay&quot;</span></span><br><span class="line">    res.reply <span class="string">&quot;I&#x27;m afraid I can&#x27;t let you do that.&quot;</span></span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    res.reply <span class="string">&quot;Opening <span class="subst">#&#123;doorType&#125;</span> doors&quot;</span></span><br></pre></td></tr></table></figure><h3 id="调用-HTTP"><a href="#调用-HTTP" class="headerlink" title="调用 HTTP"></a>调用 HTTP</h3><p>Hubot 可以为您进行 HTTP 请求，以集成和整合第三方 API 。这能够通过一个在<code>robot.http</code>的<a target="_blank" rel="noopener" href="https://github.com/technoweenie/node-scoped-http-client">node-scoped-http-client</a>实例进行。最简单的例子如：</p><figure class="highlight coffee"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">robot.http(<span class="string">&quot;https://midnight-train&quot;</span>)</span><br><span class="line">    .get() (err, res, body) -&gt;</span><br><span class="line">      <span class="comment"># your code here</span></span><br></pre></td></tr></table></figure><p>post 请求例如：</p><figure class="highlight coffee"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">data = <span class="built_in">JSON</span>.stringify(&#123;</span><br><span class="line">  foo: <span class="string">&#x27;bar&#x27;</span></span><br><span class="line">&#125;)</span><br><span class="line">robot.http(<span class="string">&quot;https://midnight-train&quot;</span>)</span><br><span class="line">  .header(<span class="string">&#x27;Content-Type&#x27;</span>, <span class="string">&#x27;application/json&#x27;</span>)</span><br><span class="line">  .post(data) (err, res, body) -&gt;</span><br><span class="line">    <span class="comment"># your code here</span></span><br></pre></td></tr></table></figure><p>如果遇到错误，<code>err</code> 就是您所遇到的错误。您通常会想要检查这一点，并相应地处理：</p><figure class="highlight coffee"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">robot.http(<span class="string">&quot;https://midnight-train&quot;</span>)</span><br><span class="line">  .get() (err, res, body) -&gt;</span><br><span class="line">    <span class="keyword">if</span> err</span><br><span class="line">      res.send <span class="string">&quot;Encountered an error :( <span class="subst">#&#123;err&#125;</span>&quot;</span></span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    <span class="comment"># your code here, knowing it was successful</span></span><br></pre></td></tr></table></figure><p><code>res</code>是node的<a target="_blank" rel="noopener" href="http://nodejs.org/api/http.html#http_class_http_serverresponse">http.ServerResponse</a>的一个实例。使用node-scoped-http-client的时候大多数方法不是特别关键， 但是有意思的是<code>statusCode</code>和<code>getHeader</code>。使用<code>statusCode</code>去检查HTTP的状态码，当不是200状态码的时候意味着糟糕的事情发生了。使用<code>getHeader</code>查看header，例如去检查服务限流（<code>X-RateLimit-Limit:1 //每秒1次请求</code>）：</p><figure class="highlight coffee"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">robot.http(<span class="string">&quot;https://midnight-train&quot;</span>)</span><br><span class="line">  .get() (err, res, body) -&gt;</span><br><span class="line">    <span class="comment"># pretend there&#x27;s error checking code here</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> res.statusCode <span class="keyword">isnt</span> <span class="number">200</span></span><br><span class="line">      res.send <span class="string">&quot;Request didn&#x27;t come back HTTP 200 :(&quot;</span></span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    rateLimitRemaining = <span class="built_in">parseInt</span> res.getHeader(<span class="string">&#x27;X-RateLimit-Limit&#x27;</span>) <span class="keyword">if</span> res.getHeader(<span class="string">&#x27;X-RateLimit-Limit&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> rateLimitRemaining <span class="keyword">and</span> rateLimitRemaining &lt; <span class="number">1</span></span><br><span class="line">      res.send <span class="string">&quot;Rate Limit hit, stop believing for awhile&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># rest of your code</span></span><br></pre></td></tr></table></figure><p><code>body</code> 是响应体字符串，应该是您最关心的东西。</p><figure class="highlight coffee"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">robot.http(<span class="string">&quot;https://midnight-train&quot;</span>)</span><br><span class="line">  .get() (err, res, body) -&gt;</span><br><span class="line">    <span class="comment"># error checking code here</span></span><br><span class="line"></span><br><span class="line">    res.send <span class="string">&quot;Got back <span class="subst">#&#123;body&#125;</span>&quot;</span></span><br></pre></td></tr></table></figure><h4 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h4><p>与 API 交流，最简单的方法是 JSON，因为它不需要任何额外的依赖。当使用<code>robot.http</code>请求，您通常应该设置<code>Accept</code>头去给API一个希望得到什么的线索。一旦您得到了返回的<code>body</code>，您就可以使用 <code>JSON.parse</code>：</p><figure class="highlight coffee"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">robot.http(<span class="string">&quot;https://midnight-train&quot;</span>)</span><br><span class="line">  .header(<span class="string">&#x27;Accept&#x27;</span>, <span class="string">&#x27;application/json&#x27;</span>)</span><br><span class="line">  .get() (err, res, body) -&gt;</span><br><span class="line">    <span class="comment"># error checking code here</span></span><br><span class="line"></span><br><span class="line">    data = <span class="built_in">JSON</span>.parse body</span><br><span class="line">    res.send <span class="string">&quot;<span class="subst">#&#123;data.passenger&#125;</span> taking midnight train going <span class="subst">#&#123;data.destination&#125;</span>&quot;</span></span><br></pre></td></tr></table></figure><p>得到的返回也可能不是JSON，就像如果这API遇到一个错误并且它试图渲染一个正常的 HTML 错误，而不是 JSON。为了安全起见，您应该检查内容类型，并在解析时发现任何错误。</p><figure class="highlight coffee"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">robot.http(<span class="string">&quot;https://midnight-train&quot;</span>)</span><br><span class="line">  .header(<span class="string">&#x27;Accept&#x27;</span>, <span class="string">&#x27;application/json&#x27;</span>)</span><br><span class="line">  .get() (err, res, body) -&gt;</span><br><span class="line">    <span class="comment"># err &amp; response status checking code here</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> response.getHeader(<span class="string">&#x27;Content-Type&#x27;</span>) <span class="keyword">isnt</span> <span class="string">&#x27;application/json&#x27;</span></span><br><span class="line">      res.send <span class="string">&quot;Didn&#x27;t get back JSON :(&quot;</span></span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    data = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">      data = <span class="built_in">JSON</span>.parse body</span><br><span class="line">    <span class="keyword">catch</span> error</span><br><span class="line">     res.send <span class="string">&quot;Ran into an error parsing JSON :(&quot;</span></span><br><span class="line">     <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># your code here</span></span><br></pre></td></tr></table></figure><h4 id="XML"><a href="#XML" class="headerlink" title="XML"></a>XML</h4><p>XML API 比较难，因为没有捆绑的 XML 解析库。详细介绍此文档的范围超出了此范围，但下面有一些可以查看的库：</p><ul><li><a target="_blank" rel="noopener" href="https://github.com/buglabs/node-xml2json">xml2json</a> (simplest to use, but has some limitations)</li><li><a target="_blank" rel="noopener" href="https://github.com/tmpvar/jsdom">jsdom</a> (JavaScript implementation of the W3C DOM)</li><li><a target="_blank" rel="noopener" href="https://github.com/Leonidas-from-XIV/node-xml2js">xml2js</a></li></ul><h4 id="萤幕抓取"><a href="#萤幕抓取" class="headerlink" title="萤幕抓取"></a>萤幕抓取</h4><p>对于没有 API 的时代，总有可能进行萤幕抓取。详细介绍此文档的范围超出了此范围，但下面是一些可以查看的库：</p><ul><li><a target="_blank" rel="noopener" href="https://github.com/MatthewMueller/cheerio">cheerio</a> (familiar syntax and API to jQuery)</li><li><a target="_blank" rel="noopener" href="https://github.com/tmpvar/jsdom">jsdom</a> (JavaScript implementation of the W3C DOM)</li></ul><h4 id="高级-HTTP-和-HTTPS-设置"><a href="#高级-HTTP-和-HTTPS-设置" class="headerlink" title="高级 HTTP 和 HTTPS 设置"></a>高级 HTTP 和 HTTPS 设置</h4><p>前面提到，hubot 使用<a target="_blank" rel="noopener" href="https://github.com/technoweenie/node-scoped-http-client">node-scoped-http-client</a>来提供一个简单的接口去发起HTTP和HTTPS请求。它封装了node的<a target="_blank" rel="noopener" href="http://nodejs.org/api/http.html">http</a>和<a target="_blank" rel="noopener" href="http://nodejs.org/api/https.html">https</a>库，但为常见的交互类型提供了一个简单的DSL（Domain Specific Language 领域专用语言）。</p><p>如果您需要直接控制http和https的选项，您传第二个参数给<code>robot.http</code>，它将通过 node-scoped-http-client 传递给 http 或者 https：</p><figure class="highlight coffee"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">options =</span><br><span class="line">  <span class="comment"># don&#x27;t verify server certificate against a CA, SCARY!</span></span><br><span class="line">  rejectUnauthorized: <span class="literal">false</span></span><br><span class="line">robot.http(<span class="string">&quot;https://midnight-train&quot;</span>, options)</span><br></pre></td></tr></table></figure><p>另外，如果node-scoped-http-client并不适合您，您可以直接使用<a target="_blank" rel="noopener" href="http://nodejs.org/api/http.html">http</a>和<a target="_blank" rel="noopener" href="http://nodejs.org/api/https.html">https</a>，或者其它的node库，例如：<a target="_blank" rel="noopener" href="https://github.com/request/request">request</a></p><h3 id="随机"><a href="#随机" class="headerlink" title="随机"></a>随机</h3><p>一种常见的模式是聆听或响应命令，并发送随机有趣的图像或文本从一个包含可能性的数组。直接使用JavaScript和CoffeeScript来实现比较麻烦， 所以 hubot 包括一个方便的方法：</p><figure class="highlight coffee"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">lulz = [<span class="string">&#x27;lol&#x27;</span>, <span class="string">&#x27;rofl&#x27;</span>, <span class="string">&#x27;lmao&#x27;</span>]</span><br><span class="line"></span><br><span class="line">res.send res.random lulz</span><br></pre></td></tr></table></figure><h3 id="主题"><a href="#主题" class="headerlink" title="主题"></a>主题</h3><p>Hubot 可以响应一个房间的主题变化，假设适配器支持它：</p><figure class="highlight coffee"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.<span class="built_in">exports</span> = <span class="function"><span class="params">(robot)</span> -&gt;</span></span><br><span class="line">  robot.topic (res) -&gt;</span><br><span class="line">    res.send <span class="string">&quot;<span class="subst">#&#123;res.message.text&#125;</span>? That&#x27;s a Paddlin&#x27;&quot;</span></span><br></pre></td></tr></table></figure><h3 id="加入和离开"><a href="#加入和离开" class="headerlink" title="加入和离开"></a>加入和离开</h3><p>Hubot 能够观察用户的加入和离开，假设适配器支持它。</p><figure class="highlight coffee"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">enterReplies = [<span class="string">&#x27;Hi&#x27;</span>, <span class="string">&#x27;Target Acquired&#x27;</span>, <span class="string">&#x27;Firing&#x27;</span>, <span class="string">&#x27;Hello friend.&#x27;</span>, <span class="string">&#x27;Gotcha&#x27;</span>, <span class="string">&#x27;I see you&#x27;</span>]</span><br><span class="line">leaveReplies = [<span class="string">&#x27;Are you still there?&#x27;</span>, <span class="string">&#x27;Target lost&#x27;</span>, <span class="string">&#x27;Searching&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.<span class="built_in">exports</span> = <span class="function"><span class="params">(robot)</span> -&gt;</span></span><br><span class="line">  robot.enter (res) -&gt;</span><br><span class="line">    res.send res.random enterReplies</span><br><span class="line">  robot.leave (res) -&gt;</span><br><span class="line">    res.send res.random leaveReplies</span><br></pre></td></tr></table></figure><h3 id="自定义监听器"><a href="#自定义监听器" class="headerlink" title="自定义监听器"></a>自定义监听器</h3><p>虽然上面的 helpers 涵盖了普通用户需要的大部分功能（聆听、响应、加入、离开、主题），有时您想为监听器赋予特定的匹配逻辑。如果是这样，您可以使用<code>listen</code>来指定自定义匹配函数来替代正则表达。</p><p>如果监听器回调要被执行，匹配函数必须返回真实值。然后将匹配函数的真实返回值用<code>response.match</code>传递给回调。</p><figure class="highlight coffee"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.<span class="built_in">exports</span> = <span class="function"><span class="params">(robot)</span> -&gt;</span></span><br><span class="line">  robot.listen(</span><br><span class="line">    <span class="function"><span class="params">(message)</span> -&gt;</span> <span class="comment"># Match function</span></span><br><span class="line">      <span class="comment"># Occassionally respond to things that Steve says</span></span><br><span class="line">      message.user.name <span class="keyword">is</span> <span class="string">&quot;Steve&quot;</span> <span class="keyword">and</span> <span class="built_in">Math</span>.random() &gt; <span class="number">0.8</span></span><br><span class="line">    (response) -&gt; <span class="comment"># Standard listener callback</span></span><br><span class="line">      <span class="comment"># Let Steve know how happy you are that he exists</span></span><br><span class="line">      response.reply <span class="string">&quot;HI STEVE! YOU&#x27;RE MY BEST FRIEND! (but only like <span class="subst">#&#123;response.match * <span class="number">100</span>&#125;</span>% of the time)&quot;</span></span><br><span class="line">  )</span><br></pre></td></tr></table></figure><p>有关复杂的匹配器示例，请参阅<a target="_blank" rel="noopener" href="https://hubot.github.com/docs/patterns/">设计模式文档</a>。</p><h3 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h3><p>Hubot 可以使用<a target="_blank" rel="noopener" href="http://nodejs.org/api/process.html#process_process_env">process.env</a>访问他运行的环境，就像任何其他node程序一样。这可用于配置脚本的运行方式，约定使用<code>HUBOT_</code>前缀。</p><figure class="highlight coffee"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">answer = process.env.HUBOT_ANSWER_TO_THE_ULTIMATE_QUESTION_OF_LIFE_THE_UNIVERSE_AND_EVERYTHING</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.<span class="built_in">exports</span> = <span class="function"><span class="params">(robot)</span> -&gt;</span></span><br><span class="line">  robot.respond <span class="regexp">/what is the answer to the ultimate question of life/</span>, <span class="function"><span class="params">(res)</span> -&gt;</span></span><br><span class="line">    res.send <span class="string">&quot;<span class="subst">#&#123;answer&#125;</span>, but what is the question?&quot;</span></span><br></pre></td></tr></table></figure><p>小心的去确保环境变量没有定义时脚本可以加载，给 hubot 开发者去定义该环境变量的提示，或者默认的一些东西。由脚本编写者来决定这是否应该是一个致命的错误（e.g. hubot 退出），也可以制作任何依赖于它的脚本，去表明它需要配置。在尽可能和有意义时，脚本运作不需要任何其它的配置更好。</p><p>在这里，我们可以默认的东西：</p><figure class="highlight coffee"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">answer = process.env.HUBOT_ANSWER_TO_THE_ULTIMATE_QUESTION_OF_LIFE_THE_UNIVERSE_AND_EVERYTHING <span class="keyword">or</span> <span class="number">42</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.<span class="built_in">exports</span> = <span class="function"><span class="params">(robot)</span> -&gt;</span></span><br><span class="line">  robot.respond <span class="regexp">/what is the answer to the ultimate question of life/</span>, <span class="function"><span class="params">(res)</span> -&gt;</span></span><br><span class="line">    res.send <span class="string">&quot;<span class="subst">#&#123;answer&#125;</span>, but what is the question?&quot;</span></span><br></pre></td></tr></table></figure><p>如果环境变量没有定义，在这里我们退出：</p><figure class="highlight coffee"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">answer = process.env.HUBOT_ANSWER_TO_THE_ULTIMATE_QUESTION_OF_LIFE_THE_UNIVERSE_AND_EVERYTHING</span><br><span class="line"><span class="keyword">unless</span> answer?</span><br><span class="line">  <span class="built_in">console</span>.log <span class="string">&quot;Missing HUBOT_ANSWER_TO_THE_ULTIMATE_QUESTION_OF_LIFE_THE_UNIVERSE_AND_EVERYTHING in environment: please set and try again&quot;</span></span><br><span class="line">  process.exit(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.<span class="built_in">exports</span> = <span class="function"><span class="params">(robot)</span> -&gt;</span></span><br><span class="line">  robot.respond <span class="regexp">/what is the answer to the ultimate question of life/</span>, <span class="function"><span class="params">(res)</span> -&gt;</span></span><br><span class="line">    res.send <span class="string">&quot;<span class="subst">#&#123;answer&#125;</span>, but what is the question?&quot;</span></span><br></pre></td></tr></table></figure><p>最后， 我们更新<code>robot.repond</code>去检查它：</p><figure class="highlight coffee"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">answer = process.env.HUBOT_ANSWER_TO_THE_ULTIMATE_QUESTION_OF_LIFE_THE_UNIVERSE_AND_EVERYTHING</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.<span class="built_in">exports</span> = <span class="function"><span class="params">(robot)</span> -&gt;</span></span><br><span class="line">  robot.respond <span class="regexp">/what is the answer to the ultimate question of life/</span>, <span class="function"><span class="params">(res)</span> -&gt;</span></span><br><span class="line">    <span class="keyword">unless</span> answer?</span><br><span class="line">      res.send <span class="string">&quot;Missing HUBOT_ANSWER_TO_THE_ULTIMATE_QUESTION_OF_LIFE_THE_UNIVERSE_AND_EVERYTHING in environment: please set and try again&quot;</span></span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    res.send <span class="string">&quot;<span class="subst">#&#123;answer&#125;</span>, but what is the question?&quot;</span></span><br></pre></td></tr></table></figure><h3 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h3><p>Hubot 使用<a target="_blank" rel="noopener" href="https://github.com/isaacs/npm">npm</a>去管理它的依赖。要去添加额外的包，添加它们到<code>package.json</code>文件的<code>dependencies</code>中。例如，添加<code>lolimadeupthispackage 1.2.3</code>，如：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;dependencies&quot;</span>: &#123;</span><br><span class="line">  <span class="attr">&quot;hubot&quot;</span>:         <span class="string">&quot;2.5.5&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;lolimadeupthispackage&quot;</span>: <span class="string">&quot;1.2.3&quot;</span></span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>如果您使用 hubot-scripts 中的脚本，记下要添加的脚本中的<code>Dependencies</code>文档。它们以可以复制粘贴进<code>package.json</code>的格式列出，只需确保根据需要添加逗号使其成为有效 JSON即可。</p><h3 id="超时和间隔"><a href="#超时和间隔" class="headerlink" title="超时和间隔"></a>超时和间隔</h3><blockquote><p>译者注：这里普及JavaScript的<code>setTimeout</code>和<code>setInterval</code>语法。</p></blockquote><p>Hubot可以使用JavaScript内置的<a target="_blank" rel="noopener" href="http://nodejs.org/api/timers.html#timers_settimeout_callback_delay_arg">setTimeout</a>来延迟运行代码。</p><figure class="highlight coffee"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.<span class="built_in">exports</span> = <span class="function"><span class="params">(robot)</span> -&gt;</span></span><br><span class="line">  robot.respond <span class="regexp">/you are a little slow/</span>, <span class="function"><span class="params">(res)</span> -&gt;</span></span><br><span class="line">    <span class="built_in">setTimeout</span> () -&gt;</span><br><span class="line">      res.send <span class="string">&quot;Who you calling &#x27;slow&#x27;?&quot;</span></span><br><span class="line">    , <span class="number">60</span> * <span class="number">1000</span></span><br></pre></td></tr></table></figure><p>另外，hubot可以用<a target="_blank" rel="noopener" href="http://nodejs.org/api/timers.html#timers_setinterval_callback_delay_arg">setInterval</a>来间隔运行代码。它需要回调方法，以及调用之间的等待时间：</p><figure class="highlight coffee"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.<span class="built_in">exports</span> = <span class="function"><span class="params">(robot)</span> -&gt;</span></span><br><span class="line">  robot.respond <span class="regexp">/annoy me/</span>, <span class="function"><span class="params">(res)</span> -&gt;</span></span><br><span class="line">    res.send <span class="string">&quot;Hey, want to hear the most annoying sound in the world?&quot;</span></span><br><span class="line">    <span class="built_in">setInterval</span> () -&gt;</span><br><span class="line">      res.send <span class="string">&quot;AAAAAAAAAAAEEEEEEEEEEEEEEEEEEEEEEEEIIIIIIIIHHHHHHHHHH&quot;</span></span><br><span class="line">    , <span class="number">1000</span></span><br></pre></td></tr></table></figure><p><code>setTimeout</code>和<code>setInterval</code>创建时，都返回超时或间隔的ID。这可用于<code>clearTimeout</code>和<code>clearInterval</code>。</p><figure class="highlight coffee"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.<span class="built_in">exports</span> = <span class="function"><span class="params">(robot)</span> -&gt;</span></span><br><span class="line">  annoyIntervalId = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">  robot.respond <span class="regexp">/annoy me/</span>, <span class="function"><span class="params">(res)</span> -&gt;</span></span><br><span class="line">    <span class="keyword">if</span> annoyIntervalId</span><br><span class="line">      res.send <span class="string">&quot;AAAAAAAAAAAEEEEEEEEEEEEEEEEEEEEEEEEIIIIIIIIHHHHHHHHHH&quot;</span></span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    res.send <span class="string">&quot;Hey, want to hear the most annoying sound in the world?&quot;</span></span><br><span class="line">    annoyIntervalId = <span class="built_in">setInterval</span> () -&gt;</span><br><span class="line">      res.send <span class="string">&quot;AAAAAAAAAAAEEEEEEEEEEEEEEEEEEEEEEEEIIIIIIIIHHHHHHHHHH&quot;</span></span><br><span class="line">    , <span class="number">1000</span></span><br><span class="line"></span><br><span class="line">  robot.respond <span class="regexp">/unannoy me/</span>, <span class="function"><span class="params">(res)</span> -&gt;</span></span><br><span class="line">    <span class="keyword">if</span> annoyIntervalId</span><br><span class="line">      res.send <span class="string">&quot;GUYS, GUYS, GUYS!&quot;</span></span><br><span class="line">      <span class="built_in">clearInterval</span>(annoyIntervalId)</span><br><span class="line">      annoyIntervalId = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      res.send <span class="string">&quot;Not annoying you right now, am I?&quot;</span></span><br></pre></td></tr></table></figure><h3 id="HTTP-监听器"><a href="#HTTP-监听器" class="headerlink" title="HTTP 监听器"></a>HTTP 监听器</h3><p>Hubot 包括支持<a target="_blank" rel="noopener" href="http://expressjs.com/">express</a>网络框架以满足HTTP请求。它监听<code>EXPRESS_PORT</code>或<code>PORT</code>环境变量指定的端口（按该顺序首选），默认值设置为8080。一个express应用的实例可在<code>robot.router</code>中。可以通过指定<code>EXPRESS_USER</code>和<code>EXPRESS_PASSWORD</code>来保护用户名和密码。通过设置<code>EXPRESS_STATIC</code>它可以自动为静态文件服务。</p><p>最常见的用途是为带有webhooks的服务提供HTTP端点去推送，并让这些出现在聊天中。</p><figure class="highlight coffee"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.<span class="built_in">exports</span> = <span class="function"><span class="params">(robot)</span> -&gt;</span></span><br><span class="line">  <span class="comment"># the expected value of :room is going to vary by adapter, it might be a numeric id, name, token, or some other value</span></span><br><span class="line">  robot.router.post <span class="string">&#x27;/hubot/chatsecrets/:room&#x27;</span>, <span class="function"><span class="params">(req, res)</span> -&gt;</span></span><br><span class="line">    room   = req.params.room</span><br><span class="line">    data   = <span class="keyword">if</span> req.body.payload? <span class="keyword">then</span> <span class="built_in">JSON</span>.parse req.body.payload <span class="keyword">else</span> req.body</span><br><span class="line">    secret = data.secret</span><br><span class="line"></span><br><span class="line">    robot.messageRoom room, <span class="string">&quot;I have a secret: <span class="subst">#&#123;secret&#125;</span>&quot;</span></span><br><span class="line"></span><br><span class="line">    res.send <span class="string">&#x27;OK&#x27;</span></span><br></pre></td></tr></table></figure><p>用curl测试它；另请参阅下面关于<a target="_blank" rel="noopener" href="https://hubot.github.com/docs/scripting/#error-handling">error handling</a>的部分。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// raw json, must specify Content-Type: application/json</span><br><span class="line">curl -X POST -H &quot;Content-Type: application/json&quot; -d &#x27;&#123;&quot;secret&quot;:&quot;C-TECH Astronomy&quot;&#125;&#x27; http://127.0.0.1:8080/hubot/chatsecrets/general</span><br><span class="line"></span><br><span class="line">// defaults Content-Type: application/x-www-form-urlencoded, must st payload=...</span><br><span class="line">curl -d &#x27;payload=%7B%22secret%22%3A%22C-TECH+Astronomy%22%7D&#x27; http://127.0.0.1:8080/hubot/chatsecrets/general</span><br></pre></td></tr></table></figure><p>所有的端点URLs应该以<code>/hubot</code>起头（无论您的机器人及叫什么名字）。这种一致性使得设置webhooks（可复制粘贴的URL）更加容易，并且保证URLs是有效的（并不是所有的bot命名都是URL安全的）。</p><h3 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h3><p>Hubot 还可以响应可用于在脚本之间传递数据的事件。这是通过使用<code>robot.emit</code>和<code>robot.on</code>封装node.js的<a target="_blank" rel="noopener" href="http://nodejs.org/api/events.html#events_class_events_eventemitter">EventEmitter</a>实现的。</p><p>其中一个用例是，有一个脚本用于处理与服务的交互，然后在事件出现时发送。例如，我们有一个脚本从 GitHub <code>post-commit</code> 钩子接收数据，当 commits 来时发送 commits 事件，然后对这些提交进行另一个脚本行为。</p><figure class="highlight coffee"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># src/scripts/github-commits.coffee</span></span><br><span class="line"><span class="built_in">module</span>.<span class="built_in">exports</span> = <span class="function"><span class="params">(robot)</span> -&gt;</span></span><br><span class="line">  robot.router.post <span class="string">&quot;/hubot/gh-commits&quot;</span>, <span class="function"><span class="params">(req, res)</span> -&gt;</span></span><br><span class="line">    robot.emit <span class="string">&quot;commit&quot;</span>, &#123;</span><br><span class="line">        user    : &#123;&#125;, <span class="comment">#hubot user object</span></span><br><span class="line">        repo    : <span class="string">&#x27;https://github.com/github/hubot&#x27;</span>,</span><br><span class="line">        hash  : <span class="string">&#x27;2e1951c089bd865839328592ff673d2f08153643&#x27;</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight coffee"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># src/scripts/heroku.coffee</span></span><br><span class="line"><span class="built_in">module</span>.<span class="built_in">exports</span> = <span class="function"><span class="params">(robot)</span> -&gt;</span></span><br><span class="line">  robot.<span class="literal">on</span> <span class="string">&quot;commit&quot;</span>, <span class="function"><span class="params">(commit)</span> -&gt;</span></span><br><span class="line">    robot.send commit.user, <span class="string">&quot;Will now deploy <span class="subst">#&#123;commit.hash&#125;</span> from <span class="subst">#&#123;commit.repo&#125;</span>!&quot;</span></span><br><span class="line">    <span class="comment">#deploy code goes here</span></span><br></pre></td></tr></table></figure><p>如果您提供一个事件，强烈建议在其数据中包括 hubot user或room对象。这将允许hubot 在聊天中通知用户或房间。</p><h3 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h3><p>没有完美的代码，并且错误和意外是意料之中的。以前，一个未捕获的异常会是您的hubot实例崩溃。Hubot现在包含了一个<code>uncaughtException</code>处理程序，它为脚本提供钩子以此来进行错误处理。</p><figure class="highlight coffee"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># src/scripts/does-not-compute.coffee</span></span><br><span class="line"><span class="built_in">module</span>.<span class="built_in">exports</span> = <span class="function"><span class="params">(robot)</span> -&gt;</span></span><br><span class="line">  robot.error (err, res) -&gt;</span><br><span class="line">    robot.logger.error <span class="string">&quot;DOES NOT COMPUTE&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> res?</span><br><span class="line">      res.reply <span class="string">&quot;DOES NOT COMPUTE&quot;</span></span><br></pre></td></tr></table></figure><p>您可以在这里做任何您想做的事，但您会想采取额外的预防措施来拯救和记录错误，特别是异步代码。否则，您可能会发现自己有递归的错误，却不知道发生了什么事情。</p><p>在头巾之下，‘error’事件发射出来，伴随着的是错误处理程序消费那个事件。<code>uncaughtException</code>处理程序，<a target="_blank" rel="noopener" href="http://nodejs.org/api/process.html#process_event_uncaughtexception">从技术上讲， 使过程处于未知状态。</a>。因此，无论何时您应该尽可能的拯救您自己的异常，并且自己发出它们。第一个参数是发出的错误，第二个参数是生成错误的可选消息。<br>使用前面的例子：</p><figure class="highlight coffee"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">robot.router.post <span class="string">&#x27;/hubot/chatsecrets/:room&#x27;</span>, <span class="function"><span class="params">(req, res)</span> -&gt;</span></span><br><span class="line">  room = req.params.room</span><br><span class="line">  data = <span class="literal">null</span></span><br><span class="line">  <span class="keyword">try</span></span><br><span class="line">    data = <span class="built_in">JSON</span>.parse req.body.payload</span><br><span class="line">  <span class="keyword">catch</span> err</span><br><span class="line">    robot.emit <span class="string">&#x27;error&#x27;</span>, err</span><br><span class="line"></span><br><span class="line">  <span class="comment"># rest of the code here</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">robot.hear <span class="regexp">/midnight train/i</span>, <span class="function"><span class="params">(res)</span> -&gt;</span></span><br><span class="line">  robot.http(<span class="string">&quot;https://midnight-train&quot;</span>)</span><br><span class="line">    .get() (err, res, body) -&gt;</span><br><span class="line">      <span class="keyword">if</span> err</span><br><span class="line">        res.reply <span class="string">&quot;Had problems taking the midnight train&quot;</span></span><br><span class="line">        robot.emit <span class="string">&#x27;error&#x27;</span>, err, res</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">      <span class="comment"># rest of code here</span></span><br></pre></td></tr></table></figure><p>对于第二个例子，值得思考的是用户会看到哪些消息。如果您有回复用户的错误处理程序，您可能不需要添加自定义消息，并且可以发回提供给get()请求的错误消息，当然这取决于您想多么的公开您的错误报告。</p><h3 id="脚本文档"><a href="#脚本文档" class="headerlink" title="脚本文档"></a>脚本文档</h3><p>Hubot 脚本可以用在其文件顶部的注释编写文档，例如：</p><figure class="highlight coffee"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Description:</span></span><br><span class="line"><span class="comment">#   &lt;description of the scripts functionality&gt;</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Dependencies:</span></span><br><span class="line"><span class="comment">#   &quot;&lt;module name&gt;&quot;: &quot;&lt;module version&gt;&quot;</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Configuration:</span></span><br><span class="line"><span class="comment">#   LIST_OF_ENV_VARS_TO_SET</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Commands:</span></span><br><span class="line"><span class="comment">#   hubot &lt;trigger&gt; - &lt;what the respond trigger does&gt;</span></span><br><span class="line"><span class="comment">#   &lt;trigger&gt; - &lt;what the hear trigger does&gt;</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Notes:</span></span><br><span class="line"><span class="comment">#   &lt;optional notes required for the script&gt;</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Author:</span></span><br><span class="line"><span class="comment">#   &lt;github username of the original script author&gt;</span></span><br></pre></td></tr></table></figure><p>这最重要的和用户面向的是<code>Commands</code>。在加载时间，Hubot 查看每个脚本的命令部分，并建立所有命令的列表。包含的<code>help.coffee</code>允许用户在所有命令或搜索中寻求帮助。因此，为这些命令制作文档使用户更容易发现这些命令。</p><p>为命令制作文档的时候，这里有一些最佳实践：</p><ul><li>保持在一行。帮助命令会被排序，因此第二行可能会被插到一个出乎意料的的地方，使得它没有意义。</li><li>将 Hubot 命名为 hubot，即使您的 hubot 被命名为其它。它将被自动替换为正确的名字。这使得无需更新文档即可轻松共享脚本。</li><li>对于<code>robot.respond</code>文档，总是以<code>hubot</code>作为前缀。Hubot将自动用您的机器人名字或者机器人的别名替换。</li><li>查看 man 手册文档是怎样制作自己的文档的。特别是，括号表示可选项，”…”表示任意数量的参数，等。</li></ul><p>文档的其它部分与bot的开发人员更相关，尤其是依赖、配置变量和说明。对<a target="_blank" rel="noopener" href="https://github.com/github/hubot-scripts">hubot-scripts</a>的所有贡献应包含与脚本启动和运行相关的所有这些部分。</p><h3 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h3><p>Hubot暴露<code>robot.brain</code>内存键值存储，可用于通过脚本存储和检索数据。</p><figure class="highlight coffee"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">robot.respond <span class="regexp">/have a soda/i</span>, <span class="function"><span class="params">(res)</span> -&gt;</span></span><br><span class="line">  <span class="comment"># Get number of sodas had (coerced to a number).</span></span><br><span class="line">  sodasHad = robot.brain.get(<span class="string">&#x27;totalSodas&#x27;</span>) * <span class="number">1</span> <span class="keyword">or</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> sodasHad &gt; <span class="number">4</span></span><br><span class="line">    res.reply <span class="string">&quot;I&#x27;m too fizzy..&quot;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    res.reply <span class="string">&#x27;Sure!&#x27;</span></span><br><span class="line"></span><br><span class="line">    robot.brain.set <span class="string">&#x27;totalSodas&#x27;</span>, sodasHad+<span class="number">1</span></span><br><span class="line">robot.respond <span class="regexp">/sleep it off/i</span>, <span class="function"><span class="params">(res)</span> -&gt;</span></span><br><span class="line">  robot.brain.set <span class="string">&#x27;totalSodas&#x27;</span>, <span class="number">0</span></span><br><span class="line">  msg.reply <span class="string">&#x27;zzzzz&#x27;</span></span><br></pre></td></tr></table></figure><p>如果脚本需要检索用户数据，<code>robot.brain</code>上有些方法通过id，name，或者name的模糊匹配：<code>userForName</code>, <code>userForId</code>, <code>userForFuzzyName</code>和<code>usersForFuzzyName</code>去查找一个或者多个用户。</p><figure class="highlight coffee"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.<span class="built_in">exports</span> = <span class="function"><span class="params">(robot)</span> -&gt;</span></span><br><span class="line"></span><br><span class="line">  robot.respond <span class="regexp">/who is @?([\w .\-]+)\?*$/i</span>, <span class="function"><span class="params">(res)</span> -&gt;</span></span><br><span class="line">    name = res.match[<span class="number">1</span>].trim()</span><br><span class="line"></span><br><span class="line">    users = robot.brain.usersForFuzzyName(name)</span><br><span class="line">    <span class="keyword">if</span> users.length <span class="keyword">is</span> <span class="number">1</span></span><br><span class="line">      user = users[<span class="number">0</span>]</span><br><span class="line">      <span class="comment"># Do something interesting here..</span></span><br><span class="line"></span><br><span class="line">      res.send <span class="string">&quot;<span class="subst">#&#123;name&#125;</span> is user - <span class="subst">#&#123;user&#125;</span>&quot;</span></span><br></pre></td></tr></table></figure><h3 id="脚本加载"><a href="#脚本加载" class="headerlink" title="脚本加载"></a>脚本加载</h3><p>加载脚本有三个主要来源：</p><ul><li><code>scripts/</code>目录下的所有脚本都与您的 hubot 绑定。</li><li><code>hubot-scripts.json</code>中指定的社区脚本，并发布在 <code>hubot-scripts</code> npm 包。</li><li>脚本从外部 npm 包加载， 并在 <code>external-scripts.json</code> 中指定。</li></ul><p>从<code>scripts/</code>目录中加载的脚本按字母顺序加载，因此您可以预期脚本的一致加载顺序。例如：</p><ul><li><code>scripts/1-first.coffee</code></li><li><code>scripts/_second.coffee</code></li><li><code>scripts/third.coffee</code></li></ul><h3 id="分享脚本"><a href="#分享脚本" class="headerlink" title="分享脚本"></a>分享脚本</h3><p>一旦您构建了一些新的脚本，以扩大您的机器人朋友的能力，您应该考虑与世界分享他们！至少，您需要打包脚本并将其提交到 <code>Node.js 程序包仓库</code>。您还应查看以下共享脚本的最佳实践。</p><h4 id="查看脚本是否已存在"><a href="#查看脚本是否已存在" class="headerlink" title="查看脚本是否已存在"></a>查看脚本是否已存在</h4><p>首先<a target="_blank" rel="noopener" href="https://hubot.github.com/docs/#scripts">检查像您这样的脚本的 NPM 包是否已经存在</a>。如果您没有看到可以贡献的现有包，则可以轻松地开始使用 hubot 脚本 <a target="_blank" rel="noopener" href="http://yeoman.io/">yeoman</a> 生成器。</p><h4 id="创建一个脚本程序包"><a href="#创建一个脚本程序包" class="headerlink" title="创建一个脚本程序包"></a>创建一个脚本程序包</h4><p>为 hubot 创建脚本包非常简单。首先安装<a target="_blank" rel="noopener" href="http://yeoman.io/">yeoman</a>生成器：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> npm install -g yo generator-hubot</span></span><br></pre></td></tr></table></figure><p>安装hubot生成器后，创建hubot脚本类似于创建一个新的hubot。您为您的hubot脚本创建目录，并在其中生成一个新的<code>hubot:script</code>。例如，如果我们想创建一个 hubot 脚本叫“my-awesome-script”:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> mkdir hubot-my-awesome-script</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> hubot-my-awesome-script</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> yo hubot:script</span></span><br></pre></td></tr></table></figure><p>此时，您会被问到一些有关脚本作者的问题，脚本的名字（由目录名猜测），一个简短的描述，和去查找它的关键字（我们建议至少有<code>hubot</code>，<code>hubot-scripts</code>）。</p><p>如果您使用的是 git，生成的目录包含一个 <code>.gitignore</code>，因此您可以初始化并添加所有内容：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git init</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git add .</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git commit -m <span class="string">&quot;Initial commit&quot;</span></span></span><br></pre></td></tr></table></figure><p>您现在有一个准备好去启动的hubot脚本库。轻松打开预创建的<code>src/awesome-script.coffee</code>文件，并开始构建您的脚本！准备好后，您可以<a target="_blank" rel="noopener" href="https://docs.npmjs.com/getting-started/publishing-npm-packages">按照他们的文档</a>将其发布到 <a target="_blank" rel="noopener" href="http://npmjs.org/">npmjs</a>！</p><p>您可能需要为新脚本编写一些单元测试。测试脚本样例写在<code>test/awesome-script-test.coffee</code>，您可以用<code>grunt</code>运行。有关测试的更多信息，请参阅<a target="_blank" rel="noopener" href="https://hubot.github.com/docs/scripting/#testing-hubot-scripts">测试Hubot脚本</a>部分。</p><h3 id="监听器元数据"><a href="#监听器元数据" class="headerlink" title="监听器元数据"></a>监听器元数据</h3><p>除了正则表达和回调，<code>hear</code>和<code>respond</code>函数还接受一个可选的选项对象，它可以被用于附加任意元数据到生成的监听器对象。此元数据允许在不修改脚本包的情况下轻松扩展脚本的行为。</p><p>最重要和最常用的元数据键是<code>id</code>。每个监听器应该被赋予一个唯一的名字（options.id，默认是<code>null</code>）。名称应按模块划分（e.g. ‘my-module.my-listener’）。这些名称允许其他脚本直接针对单个监听器，并扩展它们的其他功能，如授权和速率限制。</p><p>其他扩展可以定义和处理其他元数据键。更多信息，请参阅<a target="_blank" rel="noopener" href="https://hubot.github.com/docs/scripting/#listener-middleware">Listener Middleware section</a>部分。</p><p>回到到较早的示例：</p><figure class="highlight coffee"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.<span class="built_in">exports</span> = <span class="function"><span class="params">(robot)</span> -&gt;</span></span><br><span class="line">  robot.respond <span class="regexp">/annoy me/</span>, id:<span class="string">&#x27;annoyance.start&#x27;</span>, (msg)</span><br><span class="line">    <span class="comment"># code to annoy someone</span></span><br><span class="line"></span><br><span class="line">  robot.respond <span class="regexp">/unannoy me/</span>, id:<span class="string">&#x27;annoyance.stop&#x27;</span>, (msg)</span><br><span class="line">    <span class="comment"># code to stop annoying someone</span></span><br></pre></td></tr></table></figure><p>这些范围标识符允许您外部指定新行为，如：</p><ul><li>授权政策： “允许<code>annoyers</code>组中的每个人执行<code>annoyance.*</code>命令”</li><li>限速：“只允许30分钟执行一次<code>annoyance.start</code>”</li></ul><h3 id="中间件"><a href="#中间件" class="headerlink" title="中间件"></a>中间件</h3><p>有三种中间件： Receive, Listener and Response。</p><p>在监听器被查看之前，Receive 中间件执行一次。Listener 中间件在监听器匹配到信息后执行。Response 中间件在每次响应一个消息时运行。</p><h4 id="执行过程和-API"><a href="#执行过程和-API" class="headerlink" title="执行过程和 API"></a>执行过程和 API</h4><p>类似于<a target="_blank" rel="noopener" href="http://expressjs.com/api.html#middleware">Express middleware</a>，hubot 按定义顺序执行中间件。每个中间件可以继续链（通过调用<code>next</code>）或中断链（通过调用<code>done</code>）。如果所有中间件继续，监听器回调被执行，并且<code>done</code>会被调用。中间件可以包装<code>done</code>的回调，以便在过程的后半部分执行代码（在执行了监听器回调或更深的中间件中断之后）。</p><p>中间件被调用：</p><ul><li><code>context</code><ul><li>查看每个中间件类型的 API，查看上下文暴露的内容。</li></ul></li><li><code>next</code><ul><li>一个没有额外的属性的函数，它应该被调用从而继续到下一块中间件/执行监听器的回调</li><li><code>next</code>应该用一个单独的、可选的参数调用：要么提供<code>done</code>函数，要么一个最终调用的时候叫<code>done</code>的新函数。如果参数没有指定，那么将假定为<code>done</code>。</li></ul></li><li><code>done</code><ul><li>一个没有附加属性的函数，用于在中断中间件执行时调用，并开始执行完成功能的链。</li><li><code>done</code>在调用时无需任何参数。</li></ul></li></ul><p>每个中间件接收相同的<code>context</code>、<code>next</code>和<code>done</code>的API签名。不同种类的中间件在<code>context</code>对象中可能接收到不同的信息。详细信息，请参阅每种类型的中间件的 API。</p><h4 id="错误处理-1"><a href="#错误处理-1" class="headerlink" title="错误处理"></a>错误处理</h4><p>对于同步中间件（从不产生事件循环），hubot 会自动捕获错误并发出<code>error</code>事件，就像标准的监听器一样。Hubot 还将自动调用最近<code>done</code>的回调以解除中间件堆栈。异步中间件应补捕获自己的异常，发出<code>error</code>事件，并调用<code>done</code>。任何未捕获的异常都会中断所有中间件完成回调的执行。</p><h3 id="Listener-中间件"><a href="#Listener-中间件" class="headerlink" title="Listener 中间件"></a>Listener 中间件</h3><p>Listener 中间件在匹配消息的监听器和监听器执行之间插入逻辑。这允许您创建为每个匹配脚本运行的扩展。示例包括集中授权策略、限速、记录和指标。中间件像其他 hubot 脚本一样实现：中间件不是使用<code>hear</code>和<code>respond</code>方法，而是通过<code>listenerMiddleware</code>注册。</p><h4 id="Listener-中间件示例"><a href="#Listener-中间件示例" class="headerlink" title="Listener 中间件示例"></a>Listener 中间件示例</h4><p>在<a target="_blank" rel="noopener" href="https://github.com/michaelansel/hubot-rate-limit/blob/master/src/rate-limit.coffee">hubot-rate-limit</a>中可以找到一个功能齐全的例子。</p><p>一个中间件logging命令执行的简单示例：</p><figure class="highlight coffee"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.<span class="built_in">exports</span> = <span class="function"><span class="params">(robot)</span> -&gt;</span></span><br><span class="line">  robot.listenerMiddleware (context, next, done) -&gt;</span><br><span class="line">    <span class="comment"># Log commands</span></span><br><span class="line">    robot.logger.info <span class="string">&quot;<span class="subst">#&#123;context.response.message.user.name&#125;</span> asked me to <span class="subst">#&#123;context.response.message.text&#125;</span>&quot;</span></span><br><span class="line">    <span class="comment"># Continue executing middleware</span></span><br><span class="line">    next()</span><br></pre></td></tr></table></figure><p>在此示例，将为与监听器匹配的每个聊天消息写入日志消息。</p><p>做出限速决策的更复杂示例：</p><figure class="highlight coffee"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.<span class="built_in">exports</span> = <span class="function"><span class="params">(robot)</span> -&gt;</span></span><br><span class="line">  <span class="comment"># Map of listener ID to last time it was executed</span></span><br><span class="line">  lastExecutedTime = &#123;&#125;</span><br><span class="line"></span><br><span class="line">  robot.listenerMiddleware (context, next, done) -&gt;</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">      <span class="comment"># Default to 1s unless listener provides a different minimum period</span></span><br><span class="line">      minPeriodMs = context.listener.options?.rateLimits?.minPeriodMs? <span class="keyword">or</span> <span class="number">1000</span></span><br><span class="line"></span><br><span class="line">      <span class="comment"># See if command has been executed recently</span></span><br><span class="line">      <span class="keyword">if</span> lastExecutedTime.hasOwnProperty(context.listener.options.id) <span class="keyword">and</span></span><br><span class="line">         lastExecutedTime[context.listener.options.id] &gt; <span class="built_in">Date</span>.now() - minPeriodMs</span><br><span class="line">        <span class="comment"># Command is being executed too quickly!</span></span><br><span class="line">        done()</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        next -&gt;</span><br><span class="line">          lastExecutedTime[context.listener.options.id] = <span class="built_in">Date</span>.now()</span><br><span class="line">          done()</span><br><span class="line">    <span class="keyword">catch</span> err</span><br><span class="line">      robot.emit(<span class="string">&#x27;error&#x27;</span>, err, context.response)</span><br></pre></td></tr></table></figure><p>在这个例子中，中间件检查监听器是否在过去1000ms中执行过。如果有，中间件立马调用<code>done</code>，防止监听器回调被调用。如果监听器允许被执行，中间件附加一个<code>done</code>处理器，以便它可以记录监听器完成执行的时间。</p><p>此示例还显示了如何利用特定于监听器的元数据创建非常强大的扩展：脚本开发人员只需添加中间件并设置监听器选项，即可使用速率限制中间件去以不同速率轻松率限制命令。</p><figure class="highlight coffee"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.<span class="built_in">exports</span> = <span class="function"><span class="params">(robot)</span> -&gt;</span></span><br><span class="line">  robot.hear <span class="regexp">/hello/</span>, id: <span class="string">&#x27;my-hello&#x27;</span>, rateLimits: &#123;minPeriodMs: <span class="number">10000</span>&#125;, <span class="function"><span class="params">(msg)</span> -&gt;</span></span><br><span class="line">    <span class="comment"># This will execute no faster than once every ten seconds</span></span><br><span class="line">    msg.reply <span class="string">&#x27;Why, hello there!&#x27;</span></span><br></pre></td></tr></table></figure><h4 id="Listener-中间件-API"><a href="#Listener-中间件-API" class="headerlink" title="Listener 中间件 API"></a>Listener 中间件 API</h4><p>Listener 中间件回调接收三个参数，<code>context</code>、<code>next</code>、<code>done</code>。有关<code>next</code>和<code>done</code>的描述，查看<a target="_blank" rel="noopener" href="https://hubot.github.com/docs/scripting/#execution-process-and-api">中间件API</a>。Listener 中间件上下文包含这些字段：</p><ul><li><code>listener</code><ul><li><code>options</code>：定义监听器时设置的一个简单的包含选项的对象。查看<a target="_blank" rel="noopener" href="https://hubot.github.com/docs/scripting/#listener-metadata">监听器元数据</a>。</li><li>所有其他属性应视为内部属性。</li></ul></li><li><code>response</code><ul><li>标准response API 的所有部分都包含在中间件 API 中。查看<a target="_blank" rel="noopener" href="https://hubot.github.com/docs/scripting/#send--reply">发送和回复</a>。</li><li>中间件可以用其他信息装饰（但不修改）响应对象（e.g. 例如将携带用户的 LDAP 组的属性添加到<code>response.message.user</code>）</li><li>注意：文本消息（<code>response.message.text</code>）在监听器中间件中应该被认为是不可变的。</li></ul></li></ul><h3 id="Receive-中间件"><a href="#Receive-中间件" class="headerlink" title="Receive 中间件"></a>Receive 中间件</h3><p>在任何监听器之行之前 Receive 中间件运行。它适用于尚未更新的黑名单命令以添加 ID、指标等。</p><h4 id="Receive-中间件示例"><a href="#Receive-中间件示例" class="headerlink" title="Receive 中间件示例"></a>Receive 中间件示例</h4><p>这个简单的中间件禁止特定用户使用 hubot，包括<code>hear</code>监听器。如果用户尝试明确地运行命令，它将返回错误消息。</p><figure class="highlight coffee"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">BLACKLISTED_USERS = [</span><br><span class="line">  <span class="string">&#x27;12345&#x27;</span> <span class="comment"># Restrict access for a user ID for a contractor</span></span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">robot.receiveMiddleware (context, next, done) -&gt;</span><br><span class="line">  <span class="keyword">if</span> context.response.message.user.id <span class="keyword">in</span> BLACKLISTED_USERS</span><br><span class="line">    <span class="comment"># Don&#x27;t process this message further.</span></span><br><span class="line">    context.response.message.finish()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># If the message starts with &#x27;hubot&#x27; or the alias pattern, this user was</span></span><br><span class="line">    <span class="comment"># explicitly trying to run a command, so respond with an error message.</span></span><br><span class="line">    <span class="keyword">if</span> context.response.message.text?.match(robot.respondPattern(<span class="string">&#x27;&#x27;</span>))</span><br><span class="line">      context.response.reply <span class="string">&quot;I&#x27;m sorry @<span class="subst">#&#123;context.response.message.user.name&#125;</span>, but I&#x27;m configured to ignore your commands.&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Don&#x27;t process further middleware.</span></span><br><span class="line">    done()</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    next(done)</span><br></pre></td></tr></table></figure><h4 id="Receive-中间件-API"><a href="#Receive-中间件-API" class="headerlink" title="Receive 中间件 API"></a>Receive 中间件 API</h4><p>Receive 中间件回调接收三个参数，<code>context</code>、<code>next</code>、<code>done</code>。有关<code>next</code>和<code>done</code>的描述，请参阅<a target="_blank" rel="noopener" href="https://hubot.github.com/docs/scripting/#execution-process-and-api">中间件 API</a>。Receive 中间件上下文包括这些字段：</p><ul><li><code>response</code><ul><li>response 对象没有<code>match</code>对象，因为还没有监听器运行。</li><li>中间件可能通过附加信息（e.g. 添加一个携带用户的LDAP组的属性到<code>response.message.user</code> ）来修饰response 对象。</li><li>中间件可能修改<code>response.message</code>对象。</li></ul></li></ul><h3 id="Response-中间件"><a href="#Response-中间件" class="headerlink" title="Response 中间件"></a>Response 中间件</h3><p>Response 中间件与 hubot 发送到聊天室的每个消息背道而驰。它有助于消息格式化、防止密码泄露、度量等。</p><h4 id="Response-中间件示例"><a href="#Response-中间件示例" class="headerlink" title="Response 中间件示例"></a>Response 中间件示例</h4><p>此简单示例将发送到聊天室的链接格式从markdown链接（如<a target="_blank" rel="noopener" href="https://example.com/">示例</a>）更改为 <a target="_blank" rel="noopener" href="https://slack.com/">Slack</a> 支持的格式，<a target="_blank" rel="noopener" href="https://example.com|示例./">https://example.com|示例。</a></p><figure class="highlight coffee"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.<span class="built_in">exports</span> = <span class="function"><span class="params">(robot)</span> -&gt;</span></span><br><span class="line">  robot.responseMiddleware (context, next, done) -&gt;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">unless</span> context.plaintext?</span><br><span class="line">    context.strings = (string.replace(<span class="regexp">/\[([^\[\]]*?)\]\((https?:\/\/.*?)\)/</span>, <span class="string">&quot;&lt;$2|$1&gt;&quot;</span>) <span class="keyword">for</span> string <span class="keyword">in</span> context.strings)</span><br><span class="line">    next()</span><br></pre></td></tr></table></figure><h4 id="Response-中间件-API"><a href="#Response-中间件-API" class="headerlink" title="Response 中间件 API"></a>Response 中间件 API</h4><p>Response 中间件回调接收三个参数，<code>context</code>、<code>next</code>、<code>done</code>。请参阅中间件 API 以了解<code>next</code>和<code>done</code>。Receive 中间件的上下文包括这些字段：</p><ul><li><code>response</code><ul><li>此响应对象可用于从中间件发送新消息。在这些新响应中，将调用中间件。小心不要创建无限循环。</li></ul></li><li><code>strings</code><ul><li>一个字符串数组被发送到聊天室适配器。您可以编辑这些，或者使用<code>context.strings = [&quot;new strings&quot;]</code>去替代它们。</li></ul></li><li><code>method</code><ul><li>表示监听器发送的响应消息类型的字符串，例如<code>send</code>、<code>reply</code>、<code>emot</code>或者<code>topic</code>。</li></ul></li><li><code>plaintext</code><ul><li><code>true</code>或者<code>undefined</code>。这将被设置为<code>true</code>，如果消息是正常的纯文本类型，例如<code>send</code>和<code>reply</code>。此属性应被视为仅读。</li></ul></li></ul><h3 id="测试-hubot-脚本"><a href="#测试-hubot-脚本" class="headerlink" title="测试 hubot 脚本"></a>测试 hubot 脚本</h3><p><a target="_blank" rel="noopener" href="https://github.com/mtsmfm/hubot-test-helper">hubot-test-helper</a>是一个用来单元测试hubot脚本的好框架。（请注意，为了使用 <code>hubot-test-helper,</code>，您需要一个支持Promises的最近Node版本。）</p><p>在 Hubot 实例中安装包：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install hubot-test-helper --save-dev</span><br></pre></td></tr></table></figure><p>您还需要安装：</p><ul><li>一个JavaScript测试框架，例如<em>Mocha</em></li><li>一个断言库，例如<em>chai</em>或者<em>expect.js</em></li></ul><p>您或许还想安装：</p><ul><li><em>coffee-script</em>（如果您用CoffeeScript写您的测试而不是JavaScript）</li><li>一个mocking库例如<em>Sinon.js</em>（如果您的脚本执行网络请求或其他异步操作）</li></ul><p>下面是一个示例脚本，测试 <a target="_blank" rel="noopener" href="https://github.com/github/generator-hubot/blob/master/generators/app/templates/scripts/example.coffee">Hubot 示例脚本</a>中的前几个命令。这个脚本使用<em>Mocha</em>、<em>chai</em>、<em>coffeescript</em>，当然还有<em>hubot-test-helper</em>。</p><p><strong>test/example-test.coffee</strong></p><figure class="highlight coffee"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">Helper = <span class="built_in">require</span>(<span class="string">&#x27;hubot-test-helper&#x27;</span>)</span><br><span class="line">chai = <span class="built_in">require</span> <span class="string">&#x27;chai&#x27;</span></span><br><span class="line"></span><br><span class="line">expect = chai.expect</span><br><span class="line"></span><br><span class="line">helper = <span class="keyword">new</span> Helper(<span class="string">&#x27;../scripts/example.coffee&#x27;</span>)</span><br><span class="line"></span><br><span class="line">describe <span class="string">&#x27;example script&#x27;</span>, <span class="function">-&gt;</span></span><br><span class="line">  beforeEach -&gt;</span><br><span class="line">    @room = helper.createRoom()</span><br><span class="line"></span><br><span class="line">  afterEach -&gt;</span><br><span class="line">    @room.destroy()</span><br><span class="line"></span><br><span class="line">  it <span class="string">&#x27;doesn\&#x27;t need badgers&#x27;</span>, <span class="function">-&gt;</span></span><br><span class="line">    @room.user.say(<span class="string">&#x27;alice&#x27;</span>, <span class="string">&#x27;did someone call for a badger?&#x27;</span>).<span class="keyword">then</span> =&gt;</span><br><span class="line">      expect(@room.messages).to.eql [</span><br><span class="line">        [<span class="string">&#x27;alice&#x27;</span>, <span class="string">&#x27;did someone call for a badger?&#x27;</span>]</span><br><span class="line">        [<span class="string">&#x27;hubot&#x27;</span>, <span class="string">&#x27;Badgers? BADGERS? WE DON\&#x27;T NEED NO STINKIN BADGERS&#x27;</span>]</span><br><span class="line">      ]</span><br><span class="line"></span><br><span class="line">  it <span class="string">&#x27;won\&#x27;t open the pod bay doors&#x27;</span>, <span class="function">-&gt;</span></span><br><span class="line">    @room.user.say(<span class="string">&#x27;bob&#x27;</span>, <span class="string">&#x27;@hubot open the pod bay doors&#x27;</span>).<span class="keyword">then</span> =&gt;</span><br><span class="line">      expect(@room.messages).to.eql [</span><br><span class="line">        [<span class="string">&#x27;bob&#x27;</span>, <span class="string">&#x27;@hubot open the pod bay doors&#x27;</span>]</span><br><span class="line">        [<span class="string">&#x27;hubot&#x27;</span>, <span class="string">&#x27;@bob I\&#x27;m afraid I can\&#x27;t let you do that.&#x27;</span>]</span><br><span class="line">      ]</span><br><span class="line"></span><br><span class="line">  it <span class="string">&#x27;will open the dutch doors&#x27;</span>, <span class="function">-&gt;</span></span><br><span class="line">    @room.user.say(<span class="string">&#x27;bob&#x27;</span>, <span class="string">&#x27;@hubot open the dutch doors&#x27;</span>).<span class="keyword">then</span> =&gt;</span><br><span class="line">      expect(@room.messages).to.eql [</span><br><span class="line">        [<span class="string">&#x27;bob&#x27;</span>, <span class="string">&#x27;@hubot open the dutch doors&#x27;</span>]</span><br><span class="line">        [<span class="string">&#x27;hubot&#x27;</span>, <span class="string">&#x27;@bob Opening dutch doors&#x27;</span>]</span><br><span class="line">      ]</span><br></pre></td></tr></table></figure><p><strong>输出示例</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ mocha --compilers &quot;coffee:coffee-script/register&quot; test/*.coffee</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  example script</span><br><span class="line">    ✓ doesn&#x27;t need badgers</span><br><span class="line">    ✓ won&#x27;t open the pod bay doors</span><br><span class="line">    ✓ will open the dutch doors</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  3 passing (212ms)</span><br></pre></td></tr></table></figure><h2 id="模式-1"><a href="#模式-1" class="headerlink" title="模式"></a>模式</h2><p>用共享模式处理常见hubot场景。</p><h3 id="重命名hubot实例"><a href="#重命名hubot实例" class="headerlink" title="重命名hubot实例"></a>重命名hubot实例</h3><p>当您重命名hubot时，他将不再回应他以前的名字。为了训练用户使用新名称，您可以选择在用户尝试说出旧名称时添加弃用通知。这里的模式逻辑是：</p><ul><li>收听所有以旧名称开头的消息</li><li>回复用户，让他们知道新名称</li></ul><p>设置这个非常简单：</p><ol><li>在您的 hubot 实例的<code>scripts/</code>目录下创建一个<a target="_blank" rel="noopener" href="https://hubot.github.com/docs/scripting/">捆绑脚本</a>，叫<code>rename-hubot.coffee</code></li><li>添加以下代码，根据您的需要修改：</li></ol><figure class="highlight coffee"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Description:</span></span><br><span class="line"><span class="comment">#   Tell people hubot&#x27;s new name if they use the old one</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Commands:</span></span><br><span class="line"><span class="comment">#   None</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="built_in">module</span>.<span class="built_in">exports</span> = <span class="function"><span class="params">(robot)</span> -&gt;</span></span><br><span class="line">  robot.hear <span class="regexp">/^hubot:? (.+)/i</span>, <span class="function"><span class="params">(res)</span> -&gt;</span></span><br><span class="line">    response = <span class="string">&quot;Sorry, I&#x27;m a diva and only respond to <span class="subst">#&#123;robot.name&#125;</span>&quot;</span></span><br><span class="line">    response += <span class="string">&quot; or <span class="subst">#&#123;robot.alias&#125;</span>&quot;</span> <span class="keyword">if</span> robot.alias</span><br><span class="line">    res.reply response</span><br><span class="line">    <span class="keyword">return</span></span><br></pre></td></tr></table></figure><p>在上述模式中，修改 hubot 监听器和响应消息以满足您的需求。</p><p>此外，请务必注意，监听器应该基于 hubot 实际听到的内容，而不是在 hubot 适配器处理之前键入到聊天程序中的内容。例如，<a target="_blank" rel="noopener" href="https://github.com/hipchat/hubot-hipchat">HipChat Adapter</a>转换<code>@hubot</code>为<code>hubot:</code>在传递给hubot之前。</p><h3 id="弃用或重命名监听器"><a href="#弃用或重命名监听器" class="headerlink" title="弃用或重命名监听器"></a>弃用或重命名监听器</h3><p>如果您删除脚本或更改了脚本的命令，让用户知道更改可能会有用。一种方式是在聊天中告诉他们，或者让他们通过尝试使用不再存在的命令来发现变化。另一种方式是使 Hubot 让人们知道他们何时使用了不再工作的命令。</p><p>此模式类似于上述重命名 Hubot 实例模式：</p><ul><li>收听与旧命令匹配的所有消息</li><li>回复用户，让他们知道，它已被弃用</li></ul><p>设置如下：</p><ol><li>在hubot实例的<code>scripts/</code>目录下创建一个叫<code>deprecations.coffee</code>的<a target="_blank" rel="noopener" href="https://hubot.github.com/docs/scripting/">捆绑脚本</a></li><li>复制一切旧的命令监听器，并将其添加到该文件中。例如，如果您出于某种糊涂的原因重新命名帮助命令：<figure class="highlight coffee"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Description:</span></span><br><span class="line"><span class="comment">#   Tell users when they have used commands that are deprecated or renamed</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Commands:</span></span><br><span class="line"><span class="comment">#   None</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="built_in">module</span>.<span class="built_in">exports</span> = <span class="function"><span class="params">(robot)</span> -&gt;</span></span><br><span class="line">  robot.respond <span class="regexp">/help\s*(.*)?$/i</span>, <span class="function"><span class="params">(res)</span> -&gt;</span></span><br><span class="line">    res.reply <span class="string">&quot;That means nothing to me anymore. Perhaps you meant `docs` instead?&quot;</span></span><br><span class="line">    <span class="keyword">return</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="通过代理转发所有-HTTP-请求"><a href="#通过代理转发所有-HTTP-请求" class="headerlink" title="通过代理转发所有 HTTP 请求"></a>通过代理转发所有 HTTP 请求</h3><p>在许多企业环境中，访问互联网和（或）受保护的资源需要网络代理。对于一次性的控制，可以指定一个<a target="_blank" rel="noopener" href="https://nodejs.org/api/http.html">Agent</a>与<code>robot.http</code>一起使用。但是，这需要修改您的机器人用于指向代理的每个脚本。相反，您可以在全局层次指定代理，并默认使所有 HTTP 请求使用代理。</p><p>由于 node.js 处理 HTTP 和 HTTPS 请求的方式，您需要为每一种协议指定一个不同的 Agent。ScopedHTTPClient 将自动的选择正确的 ProxyAgent 为每种请求。</p><ol><li>安装 ProxyAgent。<code>npm install proxy-agent</code></li><li>在您的 hubot 实例的<code>scripts/</code>目录下创建一个<a target="_blank" rel="noopener" href="https://hubot.github.com/docs/scripting/">捆绑脚本</a></li><li>添加后面的代码，并按需修改：</li></ol><figure class="highlight coffee"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">proxy = <span class="built_in">require</span> <span class="string">&#x27;proxy-agent&#x27;</span></span><br><span class="line"><span class="built_in">module</span>.<span class="built_in">exports</span> = <span class="function"><span class="params">(robot)</span> -&gt;</span></span><br><span class="line">  robot.globalHttpOptions.httpAgent  = proxy(<span class="string">&#x27;http://my-proxy-server.internal&#x27;</span>, <span class="literal">false</span>)</span><br><span class="line">  robot.globalHttpOptions.httpsAgent = proxy(<span class="string">&#x27;http://my-proxy-server.internal&#x27;</span>, <span class="literal">true</span>)</span><br></pre></td></tr></table></figure><h3 id="消息的动态匹配"><a href="#消息的动态匹配" class="headerlink" title="消息的动态匹配"></a>消息的动态匹配</h3><p>在某些情况下，您希望动态匹配不同的消息（e.g. factoids, JIRA projects）。而不是定义一个过于宽泛的总是匹配的正则表达，您可以告诉 hubot 只有在满足某些条件时才匹配。</p><p>在一个简单的机器人中，这与仅仅把条件放在监听器回调中没什么不同，但是在处理中间件时却有很大的不同：用基本的模型，正则表达式每次匹配中间件将执行。用这个动态匹配模型，中间件仅当动态条件匹配时执行。</p><p>例如，<a target="_blank" rel="noopener" href="https://github.com/github/hubot-scripts/blob/bd810f99f9394818a9dcc2ea3729427e4101b96d/src/scripts/factoid.coffee#L95-L99">factoid lookup command</a>可以被重新实现为：</p><figure class="highlight coffee"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.<span class="built_in">exports</span> = <span class="function"><span class="params">(robot)</span> -&gt;</span></span><br><span class="line">  <span class="comment"># Dynamically populated list of factoids</span></span><br><span class="line">  facts =</span><br><span class="line">    fact1: <span class="string">&#x27;stuff&#x27;</span></span><br><span class="line">    fact2: <span class="string">&#x27;other stuff&#x27;</span></span><br><span class="line"></span><br><span class="line">  robot.listen(</span><br><span class="line">    <span class="comment"># Matcher</span></span><br><span class="line">    (message) -&gt;</span><br><span class="line">      match = message.match(<span class="regexp">/^~(.*)$/</span>)</span><br><span class="line">      <span class="comment"># Only match if there is a matching factoid</span></span><br><span class="line">      <span class="keyword">if</span> match <span class="keyword">and</span> match[<span class="number">1</span>] <span class="keyword">in</span> facts</span><br><span class="line">        match[<span class="number">1</span>]</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        <span class="literal">false</span></span><br><span class="line">    <span class="comment"># Callback</span></span><br><span class="line">    (response) -&gt;</span><br><span class="line">      fact = response.match</span><br><span class="line">      res.reply <span class="string">&quot;<span class="subst">#&#123;fact&#125;</span> is <span class="subst">#&#123;facts[fact]&#125;</span>&quot;</span></span><br><span class="line">  )</span><br></pre></td></tr></table></figure><h3 id="限制命令访问"><a href="#限制命令访问" class="headerlink" title="限制命令访问"></a>限制命令访问</h3><p>Hubot 的一个了不起的特色是它能够通过一条聊天消息改变生产环境。但是，并非每个访问您的聊天服务的人都能够触发生产环境改变。</p><p>有多种不同的模式来限制访问，您可以根据您的需求来选择：</p><ul><li>两个访问 buckets：完整的和用黑白名单限制的</li><li>为每个命令定制访问规则（基于角色的权限控制）</li><li>特定房间的黑白名单命令</li></ul><h4 id="简单的每个监听器访问"><a href="#简单的每个监听器访问" class="headerlink" title="简单的每个监听器访问"></a>简单的每个监听器访问</h4><p>在某些组织中，几乎所有员工都获得了相同级别的访问权限，只有少数员工需要受到限制（e.g. 新员工，外包员工等）。在这种模式下，您划分所有监听器集合，将“权力命令（power commands）”与“常规命令（normal commands）”分开。</p><p>一旦您将监听器分开了，您需要围绕黑白名单用户和监听器做出一些权衡。</p><p>选择用户白名单模式与用户黑名单模式的关键因素是：每个类别中的用户数量、任一类别的变化频率以及您的组织愿意接受的安全风险级别。</p><ul><li>白名单用户模式（用户X、Y、Z有权访问权力命令；所有的其他用户只能访问常规命令）是一种更安全的访问方法（新用户没有默认的权限去执行权力命令），但有更高的维护成本（您需要将每个新用户添加到”审批”列表中）</li><li>黑名单用户模式（所有的用户都可以执行权力命令，除了用户X、Y、Z只能访问常规命令）是一种不太安全的方法（新的用户默认有权执行权力命令除非他们被加入了黑名单），却有较低的维护成本，在黑名单是小或者很少改变的情况下。</li></ul><p>决定使用选择性的允许监听器和限制监听器的关键因素是：在每个分类中监听器的数量、内部和外部脚本的比例以及您的组织愿意接受的安全风险级别。</p><ul><li>选择性的允许监听器（所有的监听器都是权力命令，除了监听器A、B、C被视为常规命令）是更安全的（新的监听器默认被限制），但维护成本却高得多（每个愚蠢/有趣的监听器需要被明确的降级到“常规”状态）。</li><li>选择性的限制监听器（监听器A、B、C是权力命令，其它的都是常规命令）是安全性更差的一种方式（新的监听器默认被放进常规分类，它能够被意想不到的访问；外部脚本在这里特别可怕），不过有更低的维护成本（无需修改/列举访问策略中的所有fun/culture脚本）。</li></ul><p>作为额外的考虑，大多数脚本目前没有监听器 ID，因此您可能需要打开您使用的外部脚本的 PRs（或 fork）来添加监听器 ID。实际修改很容易，但与许多维护人员协调可能很费时。</p><p>一旦您决定遵循这四种模型的某一种，您需要构建适当的用户和监听器列表，以插入到您的授权中间件。</p><p>例如：用白名单用户模式去选择性的限制权力命令。</p><figure class="highlight coffee"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">POWER_COMMANDS = [</span><br><span class="line">  <span class="string">&#x27;deploy.web&#x27;</span> <span class="comment"># String that matches the listener ID</span></span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">POWER_USERS = [</span><br><span class="line">  <span class="string">&#x27;jdoe&#x27;</span> <span class="comment"># String that matches the user ID set by the adapter</span></span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.<span class="built_in">exports</span> = <span class="function"><span class="params">(robot)</span> -&gt;</span></span><br><span class="line">  robot.listenerMiddleware (context, next, done) -&gt;</span><br><span class="line">    <span class="keyword">if</span> context.listener.options.id <span class="keyword">in</span> POWER_COMMANDS</span><br><span class="line">      <span class="keyword">if</span> context.response.message.user.id <span class="keyword">in</span> POWER_USERS</span><br><span class="line">        <span class="comment"># User is allowed access to this command</span></span><br><span class="line">        next()</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        <span class="comment"># Restricted command, but user isn&#x27;t in whitelist</span></span><br><span class="line">        context.response.reply <span class="string">&quot;I&#x27;m sorry, @<span class="subst">#&#123;context.response.message.user.name&#125;</span>, but you don&#x27;t have access to do that.&quot;</span></span><br><span class="line">        done()</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="comment"># This is not a restricted command; allow everyone</span></span><br><span class="line">      next()</span><br></pre></td></tr></table></figure><p>记住所有匹配给定消息的监听器（包括<code>robot.hear /.+/</code>）执行的中间件，在对监听器进行分类时，请确保包含它们。</p><h4 id="每个监听器特定的访问规则"><a href="#每个监听器特定的访问规则" class="headerlink" title="每个监听器特定的访问规则"></a>每个监听器特定的访问规则</h4><p>对于较大的组织，访问的二元分类通常是不够的，需要更复杂的访问规则。</p><p>访问策略示例：</p><ul><li>每个开发团队都有权编译处于某个状态的代码(cut releases)并部署其服务</li><li>运营组有权部署所有服务（但是不能 cut releases）</li><li>前台无法cut releases或部署服务</li></ul><p>像这样的复杂政策目前最好直接在代码中实现，尽管这是<a target="_blank" rel="noopener" href="https://github.com/michaelansel/hubot-rbac">正在进行中的工作</a>为访问管理建立一个通用的框架。</p><h4 id="每个房间特定的访问规则"><a href="#每个房间特定的访问规则" class="headerlink" title="每个房间特定的访问规则"></a>每个房间特定的访问规则</h4><p>拥有多个不同用途的聊天室的组织通常希望能够使用相同的 hubot 实例，但每个房间允许使用不同的命令集。</p><p>广泛的黑名单的解决方案<a target="_blank" rel="noopener" href="https://github.com/kristenmills/hubot-command-blacklist">正在进行中</a>。白名单的解决方案可以采取类似的方法。</p><h2 id="适配器-1"><a href="#适配器-1" class="headerlink" title="适配器"></a>适配器</h2><p>适配器是您希望 hubot 所运行的服务的界面。</p><p>Hubot 包含两个官方的适配器：</p><ul><li><a target="_blank" rel="noopener" href="https://hubot.github.com/docs/adapters/shell/">Shell</a>，用于开发</li><li><a target="_blank" rel="noopener" href="https://hubot.github.com/docs/adapters/campfire/">Campfire</a></li></ul><p>对于大多数聊天服务，有许多第三方适配器。这是其中最受欢迎的一些：</p><ul><li><a target="_blank" rel="noopener" href="https://github.com/huafu/hubot-gitter2">Gitter</a></li><li><a target="_blank" rel="noopener" href="https://github.com/hipchat/hubot-hipchat">HipChat</a></li><li><a target="_blank" rel="noopener" href="https://github.com/nandub/hubot-irc">IRC</a></li><li><a target="_blank" rel="noopener" href="https://github.com/RocketChat/hubot-rocketchat">Rocket.Chat</a></li><li><a target="_blank" rel="noopener" href="https://github.com/slackhq/hubot-slack">Slack</a></li><li><a target="_blank" rel="noopener" href="https://github.com/markstory/hubot-xmpp">XMPP</a></li></ul><p>浏览所有的仓库通过<a target="_blank" rel="noopener" href="https://github.com/search?q=topic:hubot-adapter&type=Repositories">在 Github 上的 <code>hubot-adapter</code> topic</a> 或者<a target="_blank" rel="noopener" href="https://www.npmjs.com/search?q=hubot%20adapter&ranking=popularity">在 NPM 上搜索适配器</a>。添加<code>hubot-adapter</code> <a target="_blank" rel="noopener" href="https://help.github.com/articles/classifying-your-repository-with-topics/">topic</a>到您Github上的个人仓库，以将其包含在此列表中。</p><h3 id="编写您自己的适配器"><a href="#编写您自己的适配器" class="headerlink" title="编写您自己的适配器"></a>编写您自己的适配器</h3><p>有兴趣添加自己的适配器？查看我们用于<a target="_blank" rel="noopener" href="https://hubot.github.com/docs/adapters/development/">开发适配器</a>的文档。</p><h3 id="Campfire-适配器"><a href="#Campfire-适配器" class="headerlink" title="Campfire 适配器"></a>Campfire 适配器</h3><p><a target="_blank" rel="noopener" href="http://campfirenow.com/">Campfire</a>是一个由<a target="_blank" rel="noopener" href="http://37signals.com/">37signals</a>构建的基于 web 的聊天应用。Campfire 是 hubot 的一个原装适配器。</p><h4 id="起步"><a href="#起步" class="headerlink" title="起步"></a>起步</h4><p>您将需要一个Campfire帐户来开始，你可以<a target="_blank" rel="noopener" href="https://signup.37signals.com/campfire/free/signup/new">免费注册</a>。</p><p>下一步，你需要为你的 hubot 在 Campfire 账户上创建一个用户，然后给它访问权限，以便它可以加入您的房间。如果您尚未创建房间，则需要创建一个房间。</p><p>Hubot 默认使用它的 <a target="_blank" rel="noopener" href="https://hubot.github.com/docs/adapters/shell/">shell</a>，用 Campfire 替代，你需要带上 <code>-a campfire</code> 运行 hubot：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> bin/hubot -a campfire</span></span><br></pre></td></tr></table></figure><p>如果你部署到 Heroku 或者使用 foreman，你需要确保在 <code>Procfile</code> 中携带<code>-a campfire</code> 被调用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">web: bin/hubot -a campfire -n Hubot</span><br></pre></td></tr></table></figure><h4 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h4><p>适配器需要以下环境变量：</p><ul><li><code>HUBOT_CAMPFIRE_ACCOUNT</code></li><li><code>HUBOT_CAMPFIRE_TOKEN</code></li><li><code>HUBOT_CAMPFIRE_ROOMS</code></li></ul><h5 id="Campfire-API-令牌"><a href="#Campfire-API-令牌" class="headerlink" title="Campfire API 令牌"></a>Campfire API 令牌</h5><p>这可以通过登录您的 hubot 的帐户，点击 <code>My Info</code> 链接来找到， 并记下 API 令牌。</p><h5 id="Campfire-房间号"><a href="#Campfire-房间号" class="headerlink" title="Campfire 房间号"></a>Campfire 房间号</h5><p>如果你加入了你希望你的hubot加入的房间，你可以看见在URL中的房间的数字 ID。记下你想你的 hubot 加入的每个房间 ID。</p><h5 id="Campfire-账户"><a href="#Campfire-账户" class="headerlink" title="Campfire 账户"></a>Campfire 账户</h5><p>这只是您访问 Campfire 帐户的域名的第一部分。例如，如果您的 Campfire 是<code>hubot.campfirenow.com</code>，你的二级域名是<code>hubot</code>。记下这个二级域名。</p><h5 id="在-Heroku-上配置环境变量"><a href="#在-Heroku-上配置环境变量" class="headerlink" title="在 Heroku 上配置环境变量"></a>在 Heroku 上配置环境变量</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> heroku config:<span class="built_in">set</span> HUBOT_CAMPFIRE_TOKEN=<span class="string">&quot;...&quot;</span></span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> heroku config:<span class="built_in">set</span> HUBOT_CAMPFIRE_ROOMS=<span class="string">&quot;123,321&quot;</span></span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> heroku config:<span class="built_in">set</span> HUBOT_CAMPFIRE_ACCOUNT=<span class="string">&quot;...&quot;</span></span></span><br></pre></td></tr></table></figure><h5 id="在-Unix-上配置环境变量"><a href="#在-Unix-上配置环境变量" class="headerlink" title="在 Unix 上配置环境变量"></a>在 Unix 上配置环境变量</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">export</span> HUBOT_CAMPFIRE_TOKEN=<span class="string">&quot;...&quot;</span></span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">export</span> HUBOT_CAMPFIRE_ROOMS=<span class="string">&quot;123,321&quot;</span></span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">export</span> HUBOT_CAMPFIRE_ACCOUNT=<span class="string">&quot;...&quot;</span></span></span><br></pre></td></tr></table></figure><h5 id="在-Windows-上配置环境变量"><a href="#在-Windows-上配置环境变量" class="headerlink" title="在 Windows 上配置环境变量"></a>在 Windows 上配置环境变量</h5><p>使用 PowerShell：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">setx HUBOT_CAMPFIRE_TOKEN &quot;...&quot; /m</span><br><span class="line"></span><br><span class="line">setx HUBOT_CAMPFIRE_ROOMS &quot;123,321&quot; /m</span><br><span class="line"></span><br><span class="line">setx HUBOT_CAMPFIRE_ACCOUNT &quot;...&quot; /m</span><br></pre></td></tr></table></figure><h3 id="Shell-适配器"><a href="#Shell-适配器" class="headerlink" title="Shell 适配器"></a>Shell 适配器</h3><p>Shell 适配器提供一个简单的读取打印循环，用于与本地 hubot 进行交互。它可用于在hubot 上使用脚本之前测试脚本。</p><h4 id="起步-1"><a href="#起步-1" class="headerlink" title="起步"></a>起步</h4><p>要使用外壳适配器，您可以在运行 hubot 时简单地省略 -a 选项，因为它默认会使用 Shell 适配器。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> bin/hubot</span></span><br></pre></td></tr></table></figure><h4 id="配置-1"><a href="#配置-1" class="headerlink" title="配置"></a>配置</h4><p>这个适配器不需要任何配置。</p><p>它支持两个环境变量以支持作为不同的用户测试脚本：</p><ul><li>HUBOT_SHELL_USER_ID: default is 1</li><li>HUBOT_SHELL_USER_NAME: default is Shell</li></ul><h3 id="开发适配器"><a href="#开发适配器" class="headerlink" title="开发适配器"></a>开发适配器</h3><h4 id="适配器基础"><a href="#适配器基础" class="headerlink" title="适配器基础"></a>适配器基础</h4><p>所有适配器继承自在 <code>src/adapter.coffee</code> 文件中的适配器类。有明确的你想去重写的方法。下面是扩展适配器类的基本桩代码：</p><figure class="highlight coffee"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sample</span> <span class="keyword">extends</span> <span class="title">Adapter</span></span></span><br><span class="line"></span><br><span class="line">  constructor: <span class="function">-&gt;</span></span><br><span class="line">    <span class="built_in">super</span></span><br><span class="line">    @robot.logger.info <span class="string">&quot;Constructor&quot;</span></span><br><span class="line"></span><br><span class="line">  send: <span class="function"><span class="params">(envelope, strings...)</span> -&gt;</span></span><br><span class="line">    @robot.logger.info <span class="string">&quot;Send&quot;</span></span><br><span class="line"></span><br><span class="line">  reply: <span class="function"><span class="params">(envelope, strings...)</span> -&gt;</span></span><br><span class="line">    @robot.logger.info <span class="string">&quot;Reply&quot;</span></span><br><span class="line"></span><br><span class="line">  run: <span class="function">-&gt;</span></span><br><span class="line">    @robot.logger.info <span class="string">&quot;Run&quot;</span></span><br><span class="line">    @emit <span class="string">&quot;connected&quot;</span></span><br><span class="line">    user = <span class="keyword">new</span> User <span class="number">1001</span>, name: <span class="string">&#x27;Sample User&#x27;</span></span><br><span class="line">    message = <span class="keyword">new</span> TextMessage user, <span class="string">&#x27;Some Sample Message&#x27;</span>, <span class="string">&#x27;MSG-001&#x27;</span></span><br><span class="line">    @robot.receive message</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">exports</span>.use = <span class="function"><span class="params">(robot)</span> -&gt;</span></span><br><span class="line">  <span class="keyword">new</span> Sample robot</span><br></pre></td></tr></table></figure><h4 id="配置您的开发环境"><a href="#配置您的开发环境" class="headerlink" title="配置您的开发环境"></a>配置您的开发环境</h4><ol><li>为您的适配器<code>hubot-sample</code>创建一个新的文件夹。<ul><li><code>mkdir hubot-sample</code></li></ul></li><li>切换您的工作路径到<code>hubot-sample</code><ul><li><code>cd hubot-sample</code></li></ul></li><li>运行<code>npm init</code>去创建您的 package.json<ul><li>确保入口是<code>src/sample.coffee</code></li></ul></li><li>添加您的<code>.gitignore</code>去包含<code>node_modules</code>。</li><li>编辑 <code>src/sample.coffee</code> 文件为您的适配器去包含上述的桩代码。</li><li>编辑<code>package.json</code>去为hubot添加 peer 依赖。<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;dependencies&quot;</span>: &#123;</span><br><span class="line">&#125;,</span><br><span class="line"><span class="string">&quot;peerDependencies&quot;</span>: &#123;</span><br><span class="line">  <span class="attr">&quot;hubot&quot;</span>: <span class="string">&quot;&gt;=2.0&quot;</span></span><br><span class="line">&#125;,</span><br><span class="line"><span class="string">&quot;devDependencies&quot;</span>: &#123;</span><br><span class="line">  <span class="attr">&quot;coffee-script&quot;</span>: <span class="string">&quot;&gt;=1.2.0&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>用<code>yo hubot</code><a target="_blank" rel="noopener" href="https://hubot.github.com/docs/">命令</a>生成您的hubot。</li><li>切换工作目录到<code>hubot</code>你在第七步创建的。</li><li>现在执行<code>npm link</code>去添加您的适配器到<code>hubot</code><ul><li><code>npm link ../hubot-sample</code></li></ul></li><li>运行<code>hubot -a sample</code>。</li></ol><h4 id="Gochas"><a href="#Gochas" class="headerlink" title="Gochas"></a>Gochas</h4><p>在 node 社区有一个开放的议题围绕<a target="_blank" rel="noopener" href="https://github.com/npm/npm/issues/5875">npm 链接的 peer 依赖不工作</a>。要让我们的项目工作，您的代码需要做一些小的修改。</p><ol><li>引入您的 <code>hubot-sample</code> 适配器，添加下面的代码：<figure class="highlight coffee"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span></span><br><span class="line">  &#123;Robot,Adapter,TextMessage,User&#125; = <span class="built_in">require</span> <span class="string">&#x27;hubot&#x27;</span></span><br><span class="line"><span class="keyword">catch</span></span><br><span class="line">  prequire = <span class="built_in">require</span>(<span class="string">&#x27;parent-require&#x27;</span>)</span><br><span class="line">  &#123;Robot,Adapter,TextMessage,User&#125; = prequire <span class="string">&#x27;hubot&#x27;</span></span><br></pre></td></tr></table></figure></li><li>在您的<code>hubot-sample</code>文件夹，修改<code>package.json</code>去包含下面的依赖以至于这种自定义导入机制将起作用<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;dependencies&quot;</span>: &#123;</span><br><span class="line">  <span class="attr">&quot;parent-require&quot;</span>: <span class="string">&quot;^1.0.0&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>现在尝试再运行<code>hubot -a sample</code>并看到引入正常加载了。</li><li>一旦这工作正常，您可以根据您认为合适的情况构建适配器的功能。看看其他一些适配器，获取一些实现想法。<ul><li>一旦通过 <code>npm</code> 进行打包和部署，您就不再需要在 <code>hubot</code> 中的依赖性了，因为 peer 依赖应该作为官方模块工作。</li></ul></li></ol><h2 id="部署-1"><a href="#部署-1" class="headerlink" title="部署"></a>部署</h2><h3 id="部署到-Heroku"><a href="#部署到-Heroku" class="headerlink" title="部署到 Heroku"></a>部署到 Heroku</h3><p>如果你一直跟着<a target="_blank" rel="noopener" href="https://hubot.github.com/docs/">官方文档</a>到了这里，是时候部署了，这样你就不仅在你的本地机器能使用它了。<a target="_blank" rel="noopener" href="http://www.heroku.com/">Heroku</a>是部署hubot的最简单和支持的方式。</p><p>安装 <a target="_blank" rel="noopener" href="https://toolbelt.heroku.com/">Heroku Toolbelt</a> 去开始，然后跟着他们的“Getting Started”操作指南，包括第一次登录：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ heroku login</span><br><span class="line">Enter your Heroku credentials.</span><br><span class="line">Email: youremail@example.com</span><br><span class="line">Password:</span><br><span class="line">Could not find an existing public key.</span><br><span class="line">Would you like to generate one? [Yn]</span><br><span class="line">Generating new SSH public key.</span><br><span class="line">Uploading ssh public key /Users/you/.ssh/id_rsa.pub</span><br></pre></td></tr></table></figure><p>在新的 hubot 目录中，请确保您创建了 git 仓库，并且您的代码已经被 commit：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git init</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git add .</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git commit -m <span class="string">&quot;Initial commit&quot;</span></span></span><br></pre></td></tr></table></figure><p>创建一个 Heroku 应用：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> heroku create</span></span><br><span class="line">Creating rosemary-britches-123... done, stack is cedar</span><br><span class="line">http://rosemary-britches-123.herokuapp.com/ | git@heroku.com:rosemary-britches-123.git</span><br><span class="line">Git remote heroku added</span><br></pre></td></tr></table></figure><p>在您部署应用之前，您需要配置一些环境变量，供 hubot 使用。您需要的特定变量取决于您正在使用的适配器和脚本。对于 Campfire，没有其它脚本的话，你需要去设置以下环境变量：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> heroku config:<span class="built_in">set</span> HUBOT_CAMPFIRE_ACCOUNT=yourcampfireaccount</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> heroku config:<span class="built_in">set</span> HUBOT_CAMPFIRE_TOKEN=yourcampfiretoken</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> heroku config:<span class="built_in">set</span> HUBOT_CAMPFIRE_ROOMS=comma,separated,list,of,rooms,to,join</span></span><br></pre></td></tr></table></figure><p>此时，您已准备好部署并开始聊天。使用 Heroku，就是执行 git push：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git push heroku master</span></span><br></pre></td></tr></table></figure><p>您会看到一些文本飞过，最终是成功的。此时您应该可以在您配置的聊天室，看见您的机器人。如果没有，您可以看一看日志去调试：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> heroku logs</span></span><br></pre></td></tr></table></figure><p>如果您对您的 hubot 做了一些改变，在 push 它们之前，commit 一下就好：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git commit -am <span class="string">&quot;Awesome scripts OMG&quot;</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git push heroku master</span></span><br></pre></td></tr></table></figure><p>一些脚本需要 redis 来运行，Heroku 提供一个叫 <a target="_blank" rel="noopener" href="https://addons.heroku.com/rediscloud">Redis Cloud</a> 的附加装置，它是有免费计划的。使用它：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> heroku addons:create rediscloud</span></span><br></pre></td></tr></table></figure><p>在Heroku上的免费的dyno在<a target="_blank" rel="noopener" href="https://devcenter.heroku.com/articles/dyno-sleeping">不活跃30分钟后将休眠</a>。那意味着您的hubot将离开聊天室并且仅重新加入当它获得流量。这是极度不方便的因为大多数交互都是通过聊天完成的，hubot 必须在线、在房间里回复消息。解决这个问题的一个临时方案是，你可以使用<a target="_blank" rel="noopener" href="https://github.com/hubot-scripts/hubot-heroku-keepalive">hubot-heroku-keepalive</a>脚本，它可以让您免费的dyno活跃时间提升到18小时每天。如果你不想你的 hubot 休眠，你可能就需要<a target="_blank" rel="noopener" href="https://www.heroku.com/pricing">升级到 Heroku 的 bobby 计划</a>。</p><h3 id="部署到-Unix"><a href="#部署到-Unix" class="headerlink" title="部署到 Unix"></a>部署到 Unix</h3><p>由于 Linux 的变种很多，以及 UNIX，因此 hubot 团队很难拥有规范文档，用于安装和部署到每个版本。因此，这试图概述部署所需的内容。</p><p>有3个主要的东西去部署和运行 hubot：</p><ul><li>node 和 npm</li><li>在服务器上更新源代码的方法</li><li>启动 hubot 的方法， 在崩溃时启动它， 并在代码更新时重新启动它</li></ul><h4 id="node-和-npm"><a href="#node-和-npm" class="headerlink" title="node 和 npm"></a>node 和 npm</h4><p>首先，您的 UNIX 服务器将需要 node 和 npm。查看node.js 的 wiki：<a target="_blank" rel="noopener" href="https://github.com/joyent/node/wiki/Installing-Node.js-via-package-manager">通过包管理器安装 Node.js</a>，<a target="_blank" rel="noopener" href="https://github.com/joyent/node/wiki/Installation#building-on-gnulinux-and-other-unix">在 GNU/Linux 和 其它 UNIX 上编译</a>。</p><h4 id="在服务器上更新代码"><a href="#在服务器上更新代码" class="headerlink" title="在服务器上更新代码"></a>在服务器上更新代码</h4><p>更新 hubot 代码的最简单方法是对 hubot 的源代码进行 git checkout（您在阅读<a target="_blank" rel="noopener" href="https://hubot.github.com/docs/">官方文档</a>期间创建的源代码，而不是 github/hubot 仓库），只需 git pull 即可获取更改。这可能感觉不够优雅，但是刚开始的时候是有用的。</p><p>如果您有 Ruby 背景，使用 <a target="_blank" rel="noopener" href="https://github.com/capistrano/capistrano">capistrano</a> 会让您感到更舒服。</p><p>如果您有 <a target="_blank" rel="noopener" href="http://www.chef.io/chef/">Chef</a> 背景，有一个用于管理部署的<a target="_blank" rel="noopener" href="https://docs.chef.io/resource_deploy.html">部署</a>资源。</p><h4 id="启动、停止和重启-hubot"><a href="#启动、停止和重启-hubot" class="headerlink" title="启动、停止和重启 hubot"></a>启动、停止和重启 hubot</h4><p>每个hubot安装有一个<code>bin/hubot</code>脚本来处理启动hubot。您可以在服务器上的 git checkout 处运行此命令，但是您可能会遭遇一些问题：</p><ul><li>你断开终端连接，hubot 挂掉</li><li>hubot 因为一些原因挂掉，不会自己重新启动</li><li>它不会开机自启</li></ul><p>要处理断开连接，你可以在<a target="_blank" rel="noopener" href="http://www.gnu.org/software/screen/">screen session</a>中运行<code>bin/hubot</code>，或者使用<a target="_blank" rel="noopener" href="http://linux.die.net/man/1/nohup">nohup</a>。</p><p>要处理 hubot 挂掉，和自动重启，你可以想象运行<code>bin/hubot</code>在一个<a target="_blank" rel="noopener" href="http://tldp.org/HOWTO/Bash-Prog-Intro-HOWTO-7.html#ss7.3">bash while 循环</a>。但真的，你可能想要一些进程监控工具， 如 <a target="_blank" rel="noopener" href="http://mmonit.com/monit/">monit</a>、<a target="_blank" rel="noopener" href="http://godrb.com/">god</a>、<a target="_blank" rel="noopener" href="https://github.com/arya/bluepill">bluepill</a>、<a target="_blank" rel="noopener" href="http://upstart.ubuntu.com/">upstart</a>、<a target="_blank" rel="noopener" href="http://smarden.org/runit/">runit</a>、 <a target="_blank" rel="noopener" href="http://freedesktop.org/wiki/Software/systemd/">systemd</a>。</p><p>要处理开机自启，您可以创建适合 UNIX 分发的初始化脚本。如果您正在使用上面的进程监控工具之一，请确保它在启动时启动。有关配置<a target="_blank" rel="noopener" href="https://github.com/github/hubot/tree/master/examples">示例</a>，请参阅示例。</p><h4 id="建议"><a href="#建议" class="headerlink" title="建议"></a>建议</h4><p>本文档有意淡化强烈建议。不过在高层次上，强烈建议避免任何过于手动和不可复现的东西。尽可能使用操作系统的包和工具，并使用适当的部署工具来更新 hubot，以及进程管理以保持 hubot 的运行。</p><h3 id="部署到-Windows"><a href="#部署到-Windows" class="headerlink" title="部署到 Windows"></a>部署到 Windows</h3><p>尚未完全测试 —— 你的历程可能有所不同（YMMV）</p><p>在 Windows 机器上，有四个主要的部署运行 hubot 的步骤：</p><ul><li>node 和 npm</li><li>在服务器上更新源代码的方法</li><li>为 hubot 设置环境变量</li><li>启动 hubot， 在崩溃时启动它，在代码更新时重新启动它的方法</li></ul><h4 id="node-和-npm-1"><a href="#node-和-npm-1" class="headerlink" title="node 和 npm"></a>node 和 npm</h4><p>首先，您的 windows server 需要 node 和 npm。最佳方式是用 <a target="_blank" rel="noopener" href="http://chocolatey.org/">chocolately</a> 使用 <a target="_blank" rel="noopener" href="http://chocolatey.org/packages/nodejs.install">nodejs.install</a> 包 。我发现在系统上的 path 变量没有设置正确；确保你能通过命令行运行 node/npm。如果你需要设置 path 变量，就用“setx PATH “%PATH%;C:\Program Files\nodejs””。</p><p>你也可以直接通过<a target="_blank" rel="noopener" href="https://nodejs.org/">NodeJS</a> 安装，这可以为你设置path 变量。</p><blockquote><p>译者注：chocolately 和 scoop 都是 windows 下的包管理软件，译者使用的是 scoop。</p></blockquote><h4 id="更新服务器上的代码"><a href="#更新服务器上的代码" class="headerlink" title="更新服务器上的代码"></a>更新服务器上的代码</h4><p>在您的本地机器或直接在服务器上，去获取您服务器上的代码，您可以跟着在<a target="_blank" rel="noopener" href="https://hubot.github.com/docs/">官方文档</a>上的操作指南。如果您本地构建，推送您的hubot到Github并且克隆仓库到您的服务器上。不要克隆这标准的<a target="_blank" rel="noopener" href="http://github.com/github/hubot">github/hubot repository</a>，确保您用 Yo Generator 去构建您自己的 hubot。</p><h4 id="设置环境变量"><a href="#设置环境变量" class="headerlink" title="设置环境变量"></a>设置环境变量</h4><p>您会想设置您的 hubot 环境变量，在它运行的服务器上。您可以实现这个通过打开一个有管理员权限的 PowerShell 并且键入如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[Environment]::SetEnvironmentVariable(&quot;HUBOT_ADAPTER&quot;, &quot;Campfire&quot;, &quot;Machine&quot;)</span><br></pre></td></tr></table></figure><p>这相当于去系统菜单 -&gt; 选择高级系统设置 -&gt; 环境变量并且添加一个新的系统变量叫 HUBOT_ADAPTER，值为 Campfire。</p><h4 id="启动、停止和重启-hubot-1"><a href="#启动、停止和重启-hubot-1" class="headerlink" title="启动、停止和重启 hubot"></a>启动、停止和重启 hubot</h4><p>每个hubot安装有一个 <code>bin/hubot</code> 脚本去处理hubot的启动。您可以在您的 hubot 的文件夹下直接执行以下命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.\bin\hubot –adapter campfire</span><br></pre></td></tr></table></figure><p>不过，如果您手动调用，则存在一些问题。</p><ul><li>你断开连接，hubot 也挂掉</li><li>hubot 因为某些原因挂掉，不会重启</li><li>hubot 不开机自启</li></ul><p>解决这些，您可能想创建一个您将从您的hubot路径调用的 .ps1 文件，用您喜欢的名字。<a target="_blank" rel="noopener" href="https://hubot.github.com/_submodules/hubot/examples/hubot-start.ps1">此</a><code>examples</code>目录中有此文件的副本。它应包含以下内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Write-Host &quot;Starting Hubot Watcher&quot;</span><br><span class="line">While (1)</span><br><span class="line">&#123;</span><br><span class="line">    Write-Host &quot;Starting Hubot&quot;</span><br><span class="line">    Start-Process powershell -ArgumentList &quot;.\bin\hubot –adapter slack&quot; -wait</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果您使用 .ps1 文件来运行 hubot，记得允许本地未签名的 PowerShell 脚本。在一个管理员权限的 PowerShell 窗口运行下面的命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Set-ExecutionPolicy RemoteSigned</span><br></pre></td></tr></table></figure><p>如果您想用一些其它的方式去启动您的进程，您可以设置这个 .ps1 文件为一个预启动项。</p><h4 id="扩充文档"><a href="#扩充文档" class="headerlink" title="扩充文档"></a>扩充文档</h4><p>还不够完整，感谢您，<a target="_blank" rel="noopener" href="https://github.com/github/hubot/pull/new/master">帮助贡献提交一个 pull request？</a></p><h3 id="部署到-Azure"><a href="#部署到-Azure" class="headerlink" title="部署到 Azure"></a>部署到 Azure</h3><p>如果你一直跟随着<a target="_blank" rel="noopener" href="https://hubot.github.com/docs/">本文档</a>到现在。是时候部署了，这样您就可以在本地机器之外使用它。<a target="_blank" rel="noopener" href="http://azure.microsoft.com/">Azure</a>是部署 hubot 的一种方式，是 Heroku 的替代方案。</p><p>按照hubot的初始说明进行操作后，您将需要通过npm安装azure-cli。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install -g azure-cli</span><br></pre></td></tr></table></figure><p>在新的 hubot 目录中，请确保您创建了 git 仓库，并且您代码已经 commit：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git init</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git add .</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git commit -m <span class="string">&quot;Initial commit&quot;</span></span></span><br></pre></td></tr></table></figure><p>然后，为您的 hubot 创建一个 <a target="_blank" rel="noopener" href="https://help.github.com/articles/create-a-repo/">Github repository</a>。Azure 就可以从这个 git 仓库，而不是直接从您的开发机器拉取代码了。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git remote add origin _your GitHub repo_</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git push -u origin master</span></span><br></pre></td></tr></table></figure><p>一旦您拥有了您的 Github 仓库，创建一个 Azure 网站链接到您的仓库。在 Azure，创建一个网站并且选择源码控制。当它询问“您的源码控制在哪里”，选择 Github 并且链接这个网站到您在上一步创建的 git 仓库。如果你下载过 Azure PowerShell 模块，你可以通过PowerShell 做这些。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ $creds = Get-Credential</span><br><span class="line">$ New-AzureWebsite mynewhubot -github -githubrepository yourgithubaccount/yourhubotreponame -githubcredentials $creds</span><br></pre></td></tr></table></figure><p>一旦您完成了这个，Azure 将在您任何时间推送代码到 Github 部署您的网站。不过您的 hubot 还不能正常运行。下一步，您需要您配置部署， 告诉 Azure 如何运行hubot。</p><p>首先，运行下面的命令去添加 <code>deploy.cmd</code> 到您的hubot路径。这是 Azure 用来知道如何部署 node 应用程序的文件。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> azure site deploymentscript --node</span></span><br></pre></td></tr></table></figure><p>然后，编辑此文件并查找为您提供步骤 1、2 和 3 的部分。您将添加第 4 步：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">:: 4. Create Hubot file with a coffee extension</span><br><span class="line">copy /Y &quot;%DEPLOYMENT_TARGET%\node_modules\hubot\bin\hubot&quot; &quot;%DEPLOYMENT_TARGET%\node_modules\hubot\bin\hubot.coffee&quot;</span><br></pre></td></tr></table></figure><p>现在，在hubot的根路径下创建一个新文件叫<code>server.js</code>，并添加下列两行：</p><figure class="highlight coffee"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">require</span>(<span class="string">&#x27;coffee-script/register&#x27;</span>);</span><br><span class="line"><span class="built_in">module</span>.<span class="built_in">exports</span> = <span class="built_in">require</span>(<span class="string">&#x27;hubot/bin/hubot.coffee&#x27;</span>);</span><br></pre></td></tr></table></figure><p>最后，您需要添加环境变量到网站去确保它能够运行。下面的配置，您也可以通过图像界面来配置，或者用 Azure PowerShell 命令行，如下所示（示例显示：适配器为slack， 网站名称为mynewhubot）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ $settings = New-Object Hashtable</span><br><span class="line">$ $settings[&quot;HUBOT_ADAPTER&quot;] = &quot;Slack&quot;</span><br><span class="line">$ $settings[&quot;HUBOT_SLACK_TOKEN&quot;] = &quot;yourslackapikey&quot;</span><br><span class="line">$ Set-AzureWebsite -AppSettings $settings mynewhubot</span><br></pre></td></tr></table></figure><p>Commit 你的改变在git 仓库，并推送到Github，Azure 将自动获取改变并且部署到网站。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git commit -m &quot;Add Azure settings for hubot&quot;</span><br><span class="line">$ git push</span><br></pre></td></tr></table></figure><p>Azure 提供了一个市场，您可以在其中使用 Redis Labs 提供的 Redis Cloud 使用默认的 heroku-redis-brain。或者，要添加 Azure 存储大脑，您需要创建 Azure 存储帐户和帐户密钥。然后您可以在您的 hubot 根目录中执行以下操作。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> npm install hubot-azure-scripts --save</span></span><br></pre></td></tr></table></figure><p>然后 <code>external-scripts.json</code> 中添加以下行以及其它外部脚本</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;hubot-azure-scripts/brain/storage-blob-brain&quot;</span><br></pre></td></tr></table></figure><p>最后，在您的网站中再添加两个环境变量。您可以通过图形界面或以下PowerShell命令做到这一点。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ $settings = New-Object Hashtable</span><br><span class="line">$ $settings[&quot;HUBOT_BRAIN_AZURE_STORAGE_ACCOUNT&quot;] = &quot;your Azure storage account&quot;</span><br><span class="line">$ $settings[&quot;HUBOT_BRAIN_AZURE_STORAGE_ACCESS_KEY&quot;] = &quot;your Azure storage account key&quot;</span><br><span class="line">$ Set-AzureWebsite -AppSettings $settings mynewhubot</span><br></pre></td></tr></table></figure><p>现在任何需要大脑的脚本都可以运行。您应该查找其他脚本或通过查看<a target="_blank" rel="noopener" href="https://hubot.github.com/docs/scripting/">文档</a>编写自己的脚本。 Hubot 的所有普通脚本都与 Azure 上的托管 hubot 兼容。</p><h4 id="故障排除提示和技巧"><a href="#故障排除提示和技巧" class="headerlink" title="故障排除提示和技巧"></a>故障排除提示和技巧</h4><p>由于 Azure 基于 Windows，您可能会遇到路径长度问题。要解决此问题，您可以将环境变量 <code>IN_PLACE_DEPLOYMENT</code> 设置为 1，并使用<a target="_blank" rel="noopener" href="https://github.com/felixrieseberg/azure-npm3">自定义部署脚本来利用 NPM3</a> 和 flat 模块安装。</p><p>如果使用 Azure 的免费 tier，还可以添加部署后步骤，通过使用诸如 <code>startup.sh</code> 之类的脚本（相对于 src 目录）设置环境变量 <code>POST_DEPLOYMENT_ACTION</code> 来在启动时 ping 服务器。</p><p>启动脚本示例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">let retrys=0</span><br><span class="line">while : ; do</span><br><span class="line">    STATUSCODE=$(curl --silent --output /dev/stderr --write-out &quot;%&#123;http_code&#125;&quot; https://$&#123;WEBSITE_SITE_NAME&#125;.azurewebsites.net/heroku/keepalive)</span><br><span class="line">    echo $STATUSCODE</span><br><span class="line">    [[ $retrys -ne 5 ]] || break</span><br><span class="line">    echo $retrys</span><br><span class="line">    ((retrys++))</span><br><span class="line">    [[ $STATUSCODE -ne 200 ]] || break</span><br><span class="line">done</span><br></pre></td></tr></table></figure></div><footer class="post-footer"><div class="followme"><span>欢迎关注我的其它发布渠道</span><div class="social-list"><div class="social-item"><a target="_blank" class="social-link" href="/atom.xml"><span class="icon"><i class="fa fa-rss"></i></span> <span class="label">RSS</span></a></div></div></div><div class="post-tags"><a href="/tags/hubot/" rel="tag"># hubot</a> <a href="/tags/chatops/" rel="tag"># chatops</a></div><div class="post-nav"><div class="post-nav-item"><a href="/leetcode-142/" rel="prev" title="环形链表"><i class="fa fa-chevron-left"></i> 环形链表</a></div><div class="post-nav-item"></div></div></footer></article></div><div class="comments gitalk-container"></div></div></main><footer class="footer"><div class="footer-inner"><div class="beian"><a href="https://beian.miit.gov.cn/" rel="noopener" target="_blank">渝ICP备17015144号</a></div><div class="copyright">&copy; 2018 – <span itemprop="copyrightYear">2021</span><span class="with-love"><i class="fa fa-heart"></i></span> <span class="author" itemprop="copyrightHolder">杨欣雨</span></div></div></footer><script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script><script src="https://cdn.jsdelivr.net/npm/@next-theme/pjax@0.5.0/pjax.min.js" integrity="sha256-3NkoLDrmHLTYj7csHIZSr0MHAFTXth7Ua/DDt4MRUAg=" crossorigin="anonymous"></script><script src="https://cdn.jsdelivr.net/npm/lozad@1.16.0/dist/lozad.min.js" integrity="sha256-mOFREFhqmHeQbXpK2lp4nA3qooVgACfh88fpJftLBbc=" crossorigin="anonymous"></script><script src="https://cdn.jsdelivr.net/npm/pangu@4.0.7/dist/browser/pangu.min.js" integrity="sha256-j+yj56cdEY2CwkVtGyz18fNybFGpMGJ8JxG3GSyO2+I=" crossorigin="anonymous"></script><script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script><script src="/js/pjax.js"></script><script src="/js/third-party/search/local-search.js"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1.7.2/dist/gitalk.css" integrity="sha256-AJnUHL7dBv6PGaeyPQJcgQPDjt/Hn/PvYZde1iqfp8U=" crossorigin="anonymous"><script class="next-config" data-name="gitalk" type="application/json">{"enable":true,"github_id":"yangxyo","repo":"gitalk","client_id":"d132f60a332d75ac74e8","client_secret":"e1b396f1311291af51db16ed51308c275bc383e7","admin_user":"yangxyo","distraction_free_mode":true,"proxy":"https://cors-anywhere.azm.workers.dev/https://github.com/login/oauth/access_token","language":null,"js":{"url":"https://cdn.jsdelivr.net/npm/gitalk@1.7.2/dist/gitalk.min.js","integrity":"sha256-Pmj85ojLaPOWwRtlMJwmezB/Qg8BzvJp5eTzvXaYAfA="},"path_md5":"7e6e13a0b02d5bc3d23b7bcaa559faa3"}</script><script src="/js/third-party/comments/gitalk.js"></script></body></html>