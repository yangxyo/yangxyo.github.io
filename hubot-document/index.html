<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 5.4.0"><link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png"><link rel="mask-icon" href="/images/safari-pinned-tab.svg" color="#222"><link rel="manifest" href="/images/site.webmanifest"><meta name="google-site-verification" content="k5HBUjLU81xJuWb8xJnZv0UgiQblDBrNU3i_164wuTI"><meta name="msvalidate.01" content="B8100FBA99CDE591E1C042A3608C96E9"><meta name="yandex-verification" content="d950e9c7ce2375f9"><meta name="baidu-site-verification" content="7CEDnF5GIr"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.3/css/all.min.css" integrity="sha256-2H3fkXt6FEmrReK448mDVGKb3WW2ZZw35gI7vqHOE4Y=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous"><script class="next-config" data-name="main" type="application/json">{"hostname":"blog.xyang.xin","root":"/","images":"/images","scheme":"Mist","version":"8.7.0","exturl":false,"sidebar":{"position":"right","display":"post","padding":18,"offset":12},"copycode":true,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":true,"pangu":true,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":true,"nav":null},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script><meta name="description" content="Hubot 官方文档原文链接🔗 概览Hubot 起步你需要node.js和npm。安装它们后，我们就可以安装 hubot 生成器： 1$ npm install -g yo generator-hubot  这条命令将给我们带来hubot yeoman生成器。现在我们就可以先创建一个的文件夹，然后在里面生成一个新的hubot实例。例如，如果我们想制造一个叫 myhubot的🤖️： 123$ m"><meta property="og:type" content="article"><meta property="og:title" content="Hubot 官方文档"><meta property="og:url" content="http://blog.xyang.xin/hubot-document/index.html"><meta property="og:site_name" content="韶 光"><meta property="og:description" content="Hubot 官方文档原文链接🔗 概览Hubot 起步你需要node.js和npm。安装它们后，我们就可以安装 hubot 生成器： 1$ npm install -g yo generator-hubot  这条命令将给我们带来hubot yeoman生成器。现在我们就可以先创建一个的文件夹，然后在里面生成一个新的hubot实例。例如，如果我们想制造一个叫 myhubot的🤖️： 123$ m"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://images.xyang.xin/2021%2F09%2F01%2Fhubot-avatar.png"><meta property="article:published_time" content="2021-09-02T20:27:46.000Z"><meta property="article:modified_time" content="2021-09-02T12:29:08.490Z"><meta property="article:author" content="杨欣雨"><meta property="article:tag" content="hubot"><meta property="article:tag" content="chatops"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://images.xyang.xin/2021%2F09%2F01%2Fhubot-avatar.png"><link rel="canonical" href="http://blog.xyang.xin/hubot-document/"><script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"http://blog.xyang.xin/hubot-document/","path":"hubot-document/","title":"Hubot 官方文档"}</script><script class="next-config" data-name="calendar" type="application/json">""</script><title>Hubot 官方文档 | 韶 光</title><noscript><link rel="stylesheet" href="/css/noscript.css"></noscript><link rel="alternate" href="/atom.xml" title="韶 光" type="application/atom+xml"></head><body itemscope itemtype="http://schema.org/WebPage" class="use-motion"><div class="headband"></div><main class="main"><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏" role="button"><span class="toggle-line"></span><span class="toggle-line"></span><span class="toggle-line"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><i class="logo-line"></i><h1 class="site-title">韶 光</h1><i class="logo-line"></i></a><p class="site-subtitle" itemprop="description">Yang Xinyu's Personal Blog</p></div><div class="site-nav-right"><div class="toggle popup-trigger"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class="site-nav"><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-信息技术"><a href="/categories/%E4%BF%A1%E6%81%AF%E6%8A%80%E6%9C%AF/" rel="section"><i class="fa fa-bolt fa-fw"></i>信息技术</a></li><li class="menu-item menu-item-思想文化"><a href="/categories/%E6%80%9D%E6%83%B3%E6%96%87%E5%8C%96/" rel="section"><i class="fa fa-bookmark fa-fw"></i>思想文化</a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i> 搜索</a></li></ul></nav><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"><input autocomplete="off" autocapitalize="off" maxlength="80" placeholder="搜索..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close" role="button"><i class="fa fa-times-circle"></i></span></div><div class="search-result-container no-result"><div class="search-result-icon"><i class="fa fa-spinner fa-pulse fa-5x"></i></div></div></div></div></div><div class="toggle sidebar-toggle" role="button"><span class="toggle-line"></span><span class="toggle-line"></span><span class="toggle-line"></span></div><aside class="sidebar"><div class="sidebar-inner sidebar-nav-active sidebar-toc-active"><ul class="sidebar-nav"><li class="sidebar-nav-toc">文章目录</li><li class="sidebar-nav-overview">站点概览</li></ul><div class="sidebar-panel-container"><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Hubot-%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3"><span class="nav-number">1.</span> <span class="nav-text">Hubot 官方文档</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A6%82%E8%A7%88"><span class="nav-number">1.1.</span> <span class="nav-text">概览</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Hubot-%E8%B5%B7%E6%AD%A5"><span class="nav-number">1.1.1.</span> <span class="nav-text">Hubot 起步</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%84%9A%E6%9C%AC"><span class="nav-number">1.1.2.</span> <span class="nav-text">脚本</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%82%E9%85%8D%E5%99%A8"><span class="nav-number">1.1.3.</span> <span class="nav-text">适配器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%83%A8%E7%BD%B2"><span class="nav-number">1.1.4.</span> <span class="nav-text">部署</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A8%A1%E5%BC%8F"><span class="nav-number">1.1.5.</span> <span class="nav-text">模式</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%84%9A%E6%9C%AC-1"><span class="nav-number">1.2.</span> <span class="nav-text">脚本</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%84%9A%E6%9C%AC%E5%89%96%E6%9E%90"><span class="nav-number">1.2.1.</span> <span class="nav-text">脚本剖析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%81%86%E5%90%AC%E5%92%8C%E5%93%8D%E5%BA%94"><span class="nav-number">1.2.2.</span> <span class="nav-text">聆听和响应</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%91%E9%80%81%E5%92%8C%E5%9B%9E%E5%A4%8D"><span class="nav-number">1.2.3.</span> <span class="nav-text">发送和回复</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%99%E6%88%BF%E9%97%B4%E6%88%96%E7%94%A8%E6%88%B7%E7%9A%84%E6%B6%88%E6%81%AF"><span class="nav-number">1.2.4.</span> <span class="nav-text">给房间或用户的消息</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8D%95%E8%8E%B7%E6%95%B0%E6%8D%AE"><span class="nav-number">1.2.5.</span> <span class="nav-text">捕获数据</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B0%83%E7%94%A8-HTTP"><span class="nav-number">1.2.6.</span> <span class="nav-text">调用 HTTP</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#JSON"><span class="nav-number">1.2.6.1.</span> <span class="nav-text">JSON</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#XML"><span class="nav-number">1.2.6.2.</span> <span class="nav-text">XML</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%90%A4%E5%B9%95%E6%8A%93%E5%8F%96"><span class="nav-number">1.2.6.3.</span> <span class="nav-text">萤幕抓取</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%AB%98%E7%BA%A7-HTTP-%E5%92%8C-HTTPS-%E8%AE%BE%E7%BD%AE"><span class="nav-number">1.2.6.4.</span> <span class="nav-text">高级 HTTP 和 HTTPS 设置</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9A%8F%E6%9C%BA"><span class="nav-number">1.2.7.</span> <span class="nav-text">随机</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BB%E9%A2%98"><span class="nav-number">1.2.8.</span> <span class="nav-text">主题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8A%A0%E5%85%A5%E5%92%8C%E7%A6%BB%E5%BC%80"><span class="nav-number">1.2.9.</span> <span class="nav-text">加入和离开</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E7%9B%91%E5%90%AC%E5%99%A8"><span class="nav-number">1.2.10.</span> <span class="nav-text">自定义监听器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F"><span class="nav-number">1.2.11.</span> <span class="nav-text">环境变量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BE%9D%E8%B5%96"><span class="nav-number">1.2.12.</span> <span class="nav-text">依赖</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B6%85%E6%97%B6%E5%92%8C%E9%97%B4%E9%9A%94"><span class="nav-number">1.2.13.</span> <span class="nav-text">超时和间隔</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#HTTP-%E7%9B%91%E5%90%AC%E5%99%A8"><span class="nav-number">1.2.14.</span> <span class="nav-text">HTTP 监听器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8B%E4%BB%B6"><span class="nav-number">1.2.15.</span> <span class="nav-text">事件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86"><span class="nav-number">1.2.16.</span> <span class="nav-text">错误处理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%84%9A%E6%9C%AC%E6%96%87%E6%A1%A3"><span class="nav-number">1.2.17.</span> <span class="nav-text">脚本文档</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8C%81%E4%B9%85%E5%8C%96"><span class="nav-number">1.2.18.</span> <span class="nav-text">持久化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%84%9A%E6%9C%AC%E5%8A%A0%E8%BD%BD"><span class="nav-number">1.2.19.</span> <span class="nav-text">脚本加载</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%86%E4%BA%AB%E8%84%9A%E6%9C%AC"><span class="nav-number">1.2.20.</span> <span class="nav-text">分享脚本</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9F%A5%E7%9C%8B%E8%84%9A%E6%9C%AC%E6%98%AF%E5%90%A6%E5%B7%B2%E5%AD%98%E5%9C%A8"><span class="nav-number">1.2.20.1.</span> <span class="nav-text">查看脚本是否已存在</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E8%84%9A%E6%9C%AC%E7%A8%8B%E5%BA%8F%E5%8C%85"><span class="nav-number">1.2.20.2.</span> <span class="nav-text">创建一个脚本程序包</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%9B%91%E5%90%AC%E5%99%A8%E5%85%83%E6%95%B0%E6%8D%AE"><span class="nav-number">1.2.21.</span> <span class="nav-text">监听器元数据</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%AD%E9%97%B4%E4%BB%B6"><span class="nav-number">1.2.22.</span> <span class="nav-text">中间件</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B%E5%92%8C-API"><span class="nav-number">1.2.22.1.</span> <span class="nav-text">执行过程和 API</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86-1"><span class="nav-number">1.2.22.2.</span> <span class="nav-text">错误处理</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Listener-%E4%B8%AD%E9%97%B4%E4%BB%B6"><span class="nav-number">1.2.23.</span> <span class="nav-text">Listener 中间件</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Listener-%E4%B8%AD%E9%97%B4%E4%BB%B6%E7%A4%BA%E4%BE%8B"><span class="nav-number">1.2.23.1.</span> <span class="nav-text">Listener 中间件示例</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Listener-%E4%B8%AD%E9%97%B4%E4%BB%B6-API"><span class="nav-number">1.2.23.2.</span> <span class="nav-text">Listener 中间件 API</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Receive-%E4%B8%AD%E9%97%B4%E4%BB%B6"><span class="nav-number">1.2.24.</span> <span class="nav-text">Receive 中间件</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Receive-%E4%B8%AD%E9%97%B4%E4%BB%B6%E7%A4%BA%E4%BE%8B"><span class="nav-number">1.2.24.1.</span> <span class="nav-text">Receive 中间件示例</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Receive-%E4%B8%AD%E9%97%B4%E4%BB%B6-API"><span class="nav-number">1.2.24.2.</span> <span class="nav-text">Receive 中间件 API</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Response-%E4%B8%AD%E9%97%B4%E4%BB%B6"><span class="nav-number">1.2.25.</span> <span class="nav-text">Response 中间件</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Response-%E4%B8%AD%E9%97%B4%E4%BB%B6%E7%A4%BA%E4%BE%8B"><span class="nav-number">1.2.25.1.</span> <span class="nav-text">Response 中间件示例</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Response-%E4%B8%AD%E9%97%B4%E4%BB%B6-API"><span class="nav-number">1.2.25.2.</span> <span class="nav-text">Response 中间件 API</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B5%8B%E8%AF%95-hubot-%E8%84%9A%E6%9C%AC"><span class="nav-number">1.2.26.</span> <span class="nav-text">测试 hubot 脚本</span></a></li></ol></li></ol></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-overview"><div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="site-author-image" itemprop="image" alt="杨欣雨" src="https://images.xyang.xin/2018-12/war-soldier.jpeg"><p class="site-author-name" itemprop="name">杨欣雨</p><div class="site-description" itemprop="description">韶华易逝，享受这欢乐的美妙时光。</div></div><div class="site-state-wrap site-overview-item animated"><nav class="site-state"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">42</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/"><span class="site-state-item-count">2</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/"><span class="site-state-item-count">45</span> <span class="site-state-item-name">标签</span></a></div></nav></div><div class="links-of-author site-overview-item animated"><span class="links-of-author-item"><a href="https://github.com/yangxyo" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;yangxyo" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i> GitHub</a></span></div><div class="cc-license site-overview-item animated" itemprop="license"><a href="https://creativecommons.org/licenses/by-nc-nd/4.0/deed.zsh" class="cc-opacity" rel="noopener" target="_blank"><img src="https://cdn.jsdelivr.net/npm/@creativecommons/vocabulary@2020.11.3/assets/license_badges/small/by_nc_nd.svg" alt="Creative Commons"></a></div><div class="links-of-blogroll site-overview-item animated"><div class="links-of-blogroll-title"><i class="fa fa-globe fa-fw"></i> Links</div><ul class="links-of-blogroll-list"><li class="links-of-blogroll-item"><a href="http://www.ruanyifeng.com/blog/" title="http:&#x2F;&#x2F;www.ruanyifeng.com&#x2F;blog&#x2F;" rel="noopener" target="_blank">阮一峰的网络日志</a></li></ul></div></div></div></div></div></aside><div class="sidebar-dimmer"></div></header><div class="back-to-top" role="button" aria-label="返回顶部"><i class="fa fa-arrow-up"></i> <span>0%</span></div><div class="reading-progress-bar"></div><noscript><div class="noscript-warning">Theme NexT works best with JavaScript enabled</div></noscript><div class="main-inner post posts-expand"><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN"><link itemprop="mainEntityOfPage" href="http://blog.xyang.xin/hubot-document/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="https://images.xyang.xin/2018-12/war-soldier.jpeg"><meta itemprop="name" content="杨欣雨"><meta itemprop="description" content="韶华易逝，享受这欢乐的美妙时光。"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="韶 光"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">Hubot 官方文档</h1><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i></span> <span class="post-meta-item-text">发表于</span> <time title="创建时间：2021-09-02 20:27:46 / 修改时间：12:29:08" itemprop="dateCreated datePublished" datetime="2021-09-02T20:27:46Z">2021-09-02</time></span></div></div></header><div class="post-body" itemprop="articleBody"><h1 id="Hubot-官方文档"><a href="#Hubot-官方文档" class="headerlink" title="Hubot 官方文档"></a>Hubot 官方文档</h1><p><a target="_blank" rel="noopener" href="https://hubot.github.com/docs/">原文链接🔗</a><br><img data-src="https://images.xyang.xin/2021%2F09%2F01%2Fhubot-avatar.png" alt="hubot-avatar.png"></p><h2 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h2><h3 id="Hubot-起步"><a href="#Hubot-起步" class="headerlink" title="Hubot 起步"></a>Hubot 起步</h3><p>你需要<a target="_blank" rel="noopener" href="https://docs.npmjs.com/getting-started/installing-node">node.js和npm</a>。安装它们后，我们就可以安装 hubot 生成器：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> npm install -g yo generator-hubot</span></span><br></pre></td></tr></table></figure><p>这条命令将给我们带来hubot <a target="_blank" rel="noopener" href="http://yeoman.io/">yeoman</a>生成器。现在我们就可以先创建一个的文件夹，然后在里面生成一个新的hubot实例。例如，如果我们想制造一个叫 myhubot的🤖️：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> mkdir myhubot</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> myhubot</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> yo hubot</span></span><br></pre></td></tr></table></figure><span id="more"></span><p>执行命令后，您将被问到一些关于谁在创建机器人和您将使用哪个适配器的问题。适配器是hubot与不同聊天提供商集成的方式。</p><p>如果您希望在没有交互提示配置的情况下自动化您的 hubot 构建，您可以将以下选项添加到 <code>yo hubot</code> 命令中：</p><table><thead><tr><th>Option</th><th>Description</th></tr></thead><tbody><tr><td>--owner=”Bot Wrangler <a href="mailto:&#98;&#119;&#x40;&#x65;&#x78;&#x61;&#109;&#x70;&#108;&#x65;&#x2e;&#99;&#111;&#x6d;">&#98;&#119;&#x40;&#x65;&#x78;&#x61;&#109;&#x70;&#108;&#x65;&#x2e;&#99;&#111;&#x6d;</a>“</td><td>Bot owner, e.g. “Bot Wrangler <a href="mailto:bw@example.com">bw@example.com</a>”</td></tr><tr><td>--name=”Hubot”</td><td>🤖️名, e.g. “Hubot”</td></tr><tr><td>--description=”Delightfully aware robutt”</td><td>🤖️描述, e.g. “Delightfully aware robutt”</td></tr><tr><td>--adapter=campfire</td><td>🤖️ 适配器, e.g. “campfire”</td></tr><tr><td>--defaults</td><td>所有声明都设置为默认值且无需提示</td></tr></tbody></table><p>你先在就拥有了自己的一个多功能的 hubot！为方便起见，有一个 bin/hubot 命令，用于处理安装 npm 依赖项、加载脚本，然后启动您的 hubot。</p><p>Hubot 需要 Redis 来持久化数据，因此在您可以在自己的计算机上启动 hubot 之前，您应该在本地主机上安装 Redis。如果只是想在没有 Redis 的情况下测试 Hubot，那么您可以从 <code>external-scripts.json</code> 中删除 <code>hubot-redis-brain</code>。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> bin/hubot</span></span><br><span class="line"><span class="meta">Hubot&gt;</span></span><br></pre></td></tr></table></figure><p>这将使用 <a target="_blank" rel="noopener" href="https://hubot.github.com/docs/adapters/shell/">shell 适配器</a>启动 hubot，这对开发非常有用。记下 <code>Hubot&gt;</code>，这是您的 hubot 将用命令响应的名称。例如，列出可用命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> bin/hubot</span></span><br><span class="line"><span class="meta">hubot&gt;</span><span class="bash"> hubot <span class="built_in">help</span></span></span><br><span class="line">hubot adapter - Reply with the adapter</span><br><span class="line">hubot animate me &lt;query&gt; - The same thing as `image me`, except adds a few parameters to try to return an animated GIF instead.</span><br><span class="line">hubot echo &lt;text&gt; - Reply back with &lt;text&gt;</span><br><span class="line">hubot help - Displays all of the help commands that hubot knows about.</span><br><span class="line">hubot help &lt;query&gt; - Displays all help commands that match &lt;query&gt;.</span><br><span class="line">hubot image me &lt;query&gt; - The Original. Queries Google Images for &lt;query&gt; and returns a random top result.</span><br><span class="line">hubot map me &lt;query&gt; - Returns a map view of the area returned by `query`.</span><br><span class="line">hubot mustache me &lt;query&gt; - Searches Google Images for the specified query and mustaches it.</span><br><span class="line">hubot mustache me &lt;url&gt; - Adds a mustache to the specified URL.</span><br><span class="line">hubot ping - Reply with pong</span><br><span class="line">hubot pronounce &lt;phrase&gt; in &lt;language&gt; - Provides pronunciation of &lt;phrase&gt; (&lt;language&gt; is optional)</span><br><span class="line">hubot pug bomb N - get N pugs</span><br><span class="line">hubot pug me - Receive a pug</span><br><span class="line">hubot the rules - Make sure hubot still knows the rules.</span><br><span class="line">hubot time - Reply with current time</span><br><span class="line">hubot translate me &lt;phrase&gt; - Searches for a translation for the &lt;phrase&gt; and then prints that bad boy out.</span><br><span class="line">hubot translate me from &lt;source&gt; into &lt;target&gt; &lt;phrase&gt; - Translates &lt;phrase&gt; from &lt;source&gt; into &lt;target&gt;. Both &lt;source&gt; and &lt;target&gt; are optional</span><br><span class="line">hubot youtube me &lt;query&gt; - Searches YouTube for the query and returns the video embed link.</span><br><span class="line">ship it - Display a motivation squirrel</span><br></pre></td></tr></table></figure><p>你基本上都会想要改变你的 hubot 的名字来添加角色。 bin/hubot 需要一个 <code>--name</code>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">%</span><span class="bash"> bin/hubot --name myhubot</span></span><br><span class="line"><span class="meta">myhubot&gt;</span></span><br></pre></td></tr></table></figure><p>您的 hubot 现在将响应 <code>myhubot</code> 。这是不区分大小写的，可以以 <code>@</code> 为前缀或以 <code>:</code>为后缀。这些是等效的：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">MYHUBOT help</span><br><span class="line">myhubot help</span><br><span class="line">@myhubot help</span><br><span class="line">myhubot: help</span><br></pre></td></tr></table></figure><h3 id="脚本"><a href="#脚本" class="headerlink" title="脚本"></a>脚本</h3><p>Hubot 的力量来自于脚本。社区编写和维护着几百个脚本。通过使用 <code>hubot-scripts &lt;your-search-term&gt;</code> 查找 <a target="_blank" rel="noopener" href="https://www.npmjs.com/browse/keyword/hubot-scripts">NPM registry</a> 找到它们。例如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> npm search hubot-scripts github</span></span><br><span class="line">NAME                  DESCRIPTION</span><br><span class="line">hubot-deployer        Giving Hubot the ability to deploy GitHub repos to PaaS providers hubot hubot-scripts hubot-gith</span><br><span class="line">hubot-gh-release-pr   A hubot script to create GitHub&#x27;s PR for release</span><br><span class="line">hubot-github          Giving Hubot the ability to be a vital member of your github organization</span><br><span class="line">…</span><br></pre></td></tr></table></figure><p>要使用 NPM 包中的脚本：</p><ol><li>运行<code>npm install --save &lt;package-name&gt;</code>去添加该包作为依赖并安装它。</li><li>添加该包到<code>external-scripts.json</code>。</li><li>运行<code>npm home &lt;package-name&gt;</code>以打开脚本主页的浏览器窗口，您可以在其中找到有关配置和安装脚本的更多信息。</li></ol><p>你也可以将你自己的脚本放在<code>scripts/</code>目录下。放在这里的所有脚本都将被 hubot 自动加载和使用。阅读有关通过<a target="_blank" rel="noopener" href="https://hubot.github.com/docs/scripting/">编写自己的脚本</a>自定义 hubot 的更多信息。</p><h3 id="适配器"><a href="#适配器" class="headerlink" title="适配器"></a>适配器</h3><p>Hubot 使用适配器模式来支持多个聊天后端。这是<a target="_blank" rel="noopener" href="https://hubot.github.com/docs/adapters/">可用适配器的列表</a>，以及如何配置它们的详细信息。</p><h3 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h3><p>您可以将 hubot 部署到 Heroku，这是官方支持的方法。此外，您还可以将 hubot 部署到类似 UNIX 的系统或 Windows 中。请注意，部署到 Windows 的支持尚未得到官方支持。</p><ul><li><a target="_blank" rel="noopener" href="https://hubot.github.com/docs/deploying/heroku/">部署 hubot 到 Heroku</a></li><li><a target="_blank" rel="noopener" href="https://hubot.github.com/docs/deploying/unix/">部署 hubot 到 UNIX</a></li><li><a target="_blank" rel="noopener" href="https://hubot.github.com/docs/deploying/windows/">部署 hubot 到 Windows</a></li></ul><h3 id="模式"><a href="#模式" class="headerlink" title="模式"></a>模式</h3><p>使用自定义脚本，您可以快速自定义 hubot，使他（她）成为最具生命力的机器人。当你教你的 hubot 新的技能，阅读<a target="_blank" rel="noopener" href="https://hubot.github.com/docs/patterns/">docs/patterns.md</a> 里的一些漂亮的技巧，可能会派上用场。</p><h2 id="脚本-1"><a href="#脚本-1" class="headerlink" title="脚本"></a>脚本</h2><p>开箱即用的 hubot 不会做太多， 但它是一个可扩展的，可编脚本的机器人朋友。有<a target="_blank" rel="noopener" href="https://hubot.github.com/docs/#scripts">数以百计的脚本由社区编写和维护</a>，并且自己写起来也很容易。您可以在hubot的<code>scripts</code>目录中创建自定义脚本，或<a target="_blank" rel="noopener" href="https://hubot.github.com/docs/scripting/#creating-a-script-package">创建一个脚本包</a>，以便与社区共享！</p><h3 id="脚本剖析"><a href="#脚本剖析" class="headerlink" title="脚本剖析"></a>脚本剖析</h3><p>当您创建 hubot 时，生成器还创建了<code>scripts</code>目录。如果你看了一下那里，你会看到一些脚本的例子。脚本要成为脚本，它需要：</p><ul><li>在 hubot 脚本加载的目录里（默认为<code>src/scripts</code>和<code>scripts</code>）</li><li>是一个<code>.coffee</code>或者<code>.js</code>文件</li><li>导出一个函数</li></ul><p>导出一个函数，我们的意思是：</p><figure class="highlight coffee"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.<span class="built_in">exports</span> = <span class="function"><span class="params">(robot)</span> -&gt;</span></span><br><span class="line">  <span class="comment"># your code here</span></span><br></pre></td></tr></table></figure><p>机器人参数是您的机器人朋友的实例。在这一点上，我们可以开始编写一些很棒的脚本。</p><h3 id="聆听和响应"><a href="#聆听和响应" class="headerlink" title="聆听和响应"></a>聆听和响应</h3><p>由于这是一个聊天机器人，最常见的交互是基于消息。Hubot 可以<code>hear</code>在房间里说的消息，或直接<code>response</code>专门传达给它的消息。这两种方法都以一个正则表达式和一个回调函数作为参数。例如：</p><figure class="highlight coffee"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.<span class="built_in">exports</span> = <span class="function"><span class="params">(robot)</span> -&gt;</span></span><br><span class="line">  robot.hear <span class="regexp">/badger/i</span>, <span class="function"><span class="params">(res)</span> -&gt;</span></span><br><span class="line">    <span class="comment"># your code here</span></span><br><span class="line"></span><br><span class="line">  robot.respond <span class="regexp">/open the pod bay doors/i</span>, <span class="function"><span class="params">(res)</span> -&gt;</span></span><br><span class="line">    <span class="comment"># your code here</span></span><br></pre></td></tr></table></figure><p>每当一个消息的文本匹配时，<code>robot.hear /badger/</code>的回调就会被调用。例如：</p><ul><li>Stop badgering the witness</li><li>badger me</li><li>what exactly is a badger anyways</li></ul><p><code>robot.respond /open the pod bay doors/i</code> 的回调仅当消息紧跟着机器人的名字或者别名被调用。如果机器人的名称是 HAL，别名是 /，则此回调将被以下触发：</p><ul><li>hal open the pod bay doors</li><li>HAL: open the pod bay doors</li><li>@HAL open the pod bay doors</li><li>/open the pod bay doors</li></ul><p>它不会被调用：</p><ul><li>HAL: please open the pod bay doors<ul><li>因为它的响应与机器人名称后紧接着的文本绑定</li></ul></li><li>has anyone ever mentioned how lovely you are when you open the pod bay doors?<ul><li>因为它确少机器人的名字</li></ul></li></ul><h3 id="发送和回复"><a href="#发送和回复" class="headerlink" title="发送和回复"></a>发送和回复</h3><p><code>res</code>参数是<code>Response</code>的实例（在历史上，这个参数是 <code>msg</code>，你可能会看到其他脚本使用它）。有了它，您可以将消息<code>send</code>回 <code>res</code>来的房间，<code>emote</code>一个消息到一个房间（如果给定的适配器支持它），或<code>reply</code>发送消息的人。例如：</p><figure class="highlight coffee"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.<span class="built_in">exports</span> = <span class="function"><span class="params">(robot)</span> -&gt;</span></span><br><span class="line">  robot.hear <span class="regexp">/badger/i</span>, <span class="function"><span class="params">(res)</span> -&gt;</span></span><br><span class="line">    res.send <span class="string">&quot;Badgers? BADGERS? WE DON&#x27;T NEED NO STINKIN BADGERS&quot;</span></span><br><span class="line"></span><br><span class="line">  robot.respond <span class="regexp">/open the pod bay doors/i</span>, <span class="function"><span class="params">(res)</span> -&gt;</span></span><br><span class="line">    res.reply <span class="string">&quot;I&#x27;m afraid I can&#x27;t let you do that.&quot;</span></span><br><span class="line"></span><br><span class="line">  robot.hear <span class="regexp">/I like pie/i</span>, <span class="function"><span class="params">(res)</span> -&gt;</span></span><br><span class="line">    res.emote <span class="string">&quot;makes a freshly baked pie&quot;</span></span><br></pre></td></tr></table></figure><p><code>robot.hear /badgers/</code>的回调发送指定的消息，而不管向谁说： “Badgers? BADGERS? WE DON’T NEED NO STINKIN BADGERS”。</p><p>如果一个用户 Dave 说 “HAL: open the pod bay doors”， <code>robot.respond /open the pod bay doors/i</code> 的回调发送一个消息<code>Dave: I’m afraid I can’t let you do that.</code></p><h3 id="给房间或用户的消息"><a href="#给房间或用户的消息" class="headerlink" title="给房间或用户的消息"></a>给房间或用户的消息</h3><p>消息可以使用 <code>messageRoom</code> 功能发送给指定的房间或用户。</p><figure class="highlight coffee"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.<span class="built_in">exports</span> = <span class="function"><span class="params">(robot)</span> -&gt;</span></span><br><span class="line"></span><br><span class="line">  robot.hear <span class="regexp">/green eggs/i</span>, <span class="function"><span class="params">(res)</span> -&gt;</span></span><br><span class="line">    room = <span class="string">&quot;mytestroom&quot;</span></span><br><span class="line">    robot.messageRoom room, <span class="string">&quot;I do not like green eggs and ham.  I do not like them sam-I-am.&quot;</span></span><br></pre></td></tr></table></figure><p>如果需要，可以明确指定用户名，或使用响应对象，可以向原始发件人发送私人消息。</p><figure class="highlight coffee"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">robot.respond <span class="regexp">/I don&#x27;t like Sam-I-am/i</span>, <span class="function"><span class="params">(res)</span> -&gt;</span></span><br><span class="line">  room =  <span class="string">&#x27;joemanager&#x27;</span></span><br><span class="line">  robot.messageRoom room, <span class="string">&quot;Someone does not like Dr. Seus&quot;</span></span><br><span class="line">  res.reply  <span class="string">&quot;That Sam-I-am\nThat Sam-I-am\nI do not like\nthat Sam-I-am&quot;</span></span><br><span class="line"></span><br><span class="line">robot.hear <span class="regexp">/Sam-I-am/i</span>, <span class="function"><span class="params">(res)</span> -&gt;</span></span><br><span class="line">  room =  res.envelope.user.name</span><br><span class="line">  robot.messageRoom room, <span class="string">&quot;That Sam-I-am\nThat Sam-I-am\nI do not like\nthat Sam-I-am&quot;</span></span><br></pre></td></tr></table></figure><h3 id="捕获数据"><a href="#捕获数据" class="headerlink" title="捕获数据"></a>捕获数据</h3><p>到目前为止，我们的脚本已经有静态响应，这虽然有趣，在功能方面却很薄弱。<code>res.match</code>的结果是将传入的消息与正则表达进行匹配。这只是一个 <a target="_blank" rel="noopener" href="http://www.w3schools.com/jsref/jsref_match.asp">JavaScript thing</a>， 它最终是一个数组， 索引0是与表达式匹配的全文。如果包括捕获组，这些组将填充 <code>res.match</code>。例如，如果我们更新脚本：</p><figure class="highlight coffee"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">robot.respond <span class="regexp">/open the (.*) doors/i</span>, <span class="function"><span class="params">(res)</span> -&gt;</span></span><br><span class="line">    <span class="comment"># your code here</span></span><br></pre></td></tr></table></figure><p>如果Dave说“HAL: open the pod bay doors”，<code>res.match[0]</code>就成了<code>open the pod bay doors</code>，<code>res.match[1]</code>则为<code>pod bay</code>。现在我们可以开始做更多动态的东西了：</p><figure class="highlight coffee"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">robot.respond <span class="regexp">/open the (.*) doors/i</span>, <span class="function"><span class="params">(res)</span> -&gt;</span></span><br><span class="line">  doorType = res.match[<span class="number">1</span>]</span><br><span class="line">  <span class="keyword">if</span> doorType <span class="keyword">is</span> <span class="string">&quot;pod bay&quot;</span></span><br><span class="line">    res.reply <span class="string">&quot;I&#x27;m afraid I can&#x27;t let you do that.&quot;</span></span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    res.reply <span class="string">&quot;Opening <span class="subst">#&#123;doorType&#125;</span> doors&quot;</span></span><br></pre></td></tr></table></figure><h3 id="调用-HTTP"><a href="#调用-HTTP" class="headerlink" title="调用 HTTP"></a>调用 HTTP</h3><p>Hubot 可以为您进行 HTTP 请求，以集成和整合第三方 API 。这能够通过一个在<code>robot.http</code>的<a target="_blank" rel="noopener" href="https://github.com/technoweenie/node-scoped-http-client">node-scoped-http-client</a>实例进行。最简单的例子如：</p><figure class="highlight coffee"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">robot.http(<span class="string">&quot;https://midnight-train&quot;</span>)</span><br><span class="line">    .get() (err, res, body) -&gt;</span><br><span class="line">      <span class="comment"># your code here</span></span><br></pre></td></tr></table></figure><p>post 请求例如：</p><figure class="highlight coffee"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">data = <span class="built_in">JSON</span>.stringify(&#123;</span><br><span class="line">  foo: <span class="string">&#x27;bar&#x27;</span></span><br><span class="line">&#125;)</span><br><span class="line">robot.http(<span class="string">&quot;https://midnight-train&quot;</span>)</span><br><span class="line">  .header(<span class="string">&#x27;Content-Type&#x27;</span>, <span class="string">&#x27;application/json&#x27;</span>)</span><br><span class="line">  .post(data) (err, res, body) -&gt;</span><br><span class="line">    <span class="comment"># your code here</span></span><br></pre></td></tr></table></figure><p>如果遇到错误，<code>err</code> 就是你所遇到的错误。您通常会想要检查这一点，并相应地处理：</p><figure class="highlight coffee"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">robot.http(<span class="string">&quot;https://midnight-train&quot;</span>)</span><br><span class="line">  .get() (err, res, body) -&gt;</span><br><span class="line">    <span class="keyword">if</span> err</span><br><span class="line">      res.send <span class="string">&quot;Encountered an error :( <span class="subst">#&#123;err&#125;</span>&quot;</span></span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    <span class="comment"># your code here, knowing it was successful</span></span><br></pre></td></tr></table></figure><p><code>res</code>是node的<a target="_blank" rel="noopener" href="http://nodejs.org/api/http.html#http_class_http_serverresponse">http.ServerResponse</a>的一个实例。使用node-scoped-http-client的时候大多数方法不是特别关键， 但是有意思的是<code>statusCode</code>和<code>getHeader</code>。使用<code>statusCode</code>去检查HTTP的状态码，当不是200状态码的时候意味着糟糕的事情发生了。使用<code>getHeader</code>查看header，例如去检查服务限流（<code>X-RateLimit-Limit:1 //每秒1次请求</code>）：</p><figure class="highlight coffee"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">robot.http(<span class="string">&quot;https://midnight-train&quot;</span>)</span><br><span class="line">  .get() (err, res, body) -&gt;</span><br><span class="line">    <span class="comment"># pretend there&#x27;s error checking code here</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> res.statusCode <span class="keyword">isnt</span> <span class="number">200</span></span><br><span class="line">      res.send <span class="string">&quot;Request didn&#x27;t come back HTTP 200 :(&quot;</span></span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    rateLimitRemaining = <span class="built_in">parseInt</span> res.getHeader(<span class="string">&#x27;X-RateLimit-Limit&#x27;</span>) <span class="keyword">if</span> res.getHeader(<span class="string">&#x27;X-RateLimit-Limit&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> rateLimitRemaining <span class="keyword">and</span> rateLimitRemaining &lt; <span class="number">1</span></span><br><span class="line">      res.send <span class="string">&quot;Rate Limit hit, stop believing for awhile&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># rest of your code</span></span><br></pre></td></tr></table></figure><p><code>body</code> 是响应体字符串，应该是你最关心的东西。</p><figure class="highlight coffee"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">robot.http(<span class="string">&quot;https://midnight-train&quot;</span>)</span><br><span class="line">  .get() (err, res, body) -&gt;</span><br><span class="line">    <span class="comment"># error checking code here</span></span><br><span class="line"></span><br><span class="line">    res.send <span class="string">&quot;Got back <span class="subst">#&#123;body&#125;</span>&quot;</span></span><br></pre></td></tr></table></figure><h4 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h4><p>与 API 交流，最简单的方法是 JSON，因为它不需要任何额外的依赖。当使用<code>robot.http</code>请求，您通常应该设置<code>Accept</code>头去给API一个希望得到什么的线索。一旦你得到了返回的<code>body</code>，你就可以使用 <code>JSON.parse</code>：</p><figure class="highlight coffee"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">robot.http(<span class="string">&quot;https://midnight-train&quot;</span>)</span><br><span class="line">  .header(<span class="string">&#x27;Accept&#x27;</span>, <span class="string">&#x27;application/json&#x27;</span>)</span><br><span class="line">  .get() (err, res, body) -&gt;</span><br><span class="line">    <span class="comment"># error checking code here</span></span><br><span class="line"></span><br><span class="line">    data = <span class="built_in">JSON</span>.parse body</span><br><span class="line">    res.send <span class="string">&quot;<span class="subst">#&#123;data.passenger&#125;</span> taking midnight train going <span class="subst">#&#123;data.destination&#125;</span>&quot;</span></span><br></pre></td></tr></table></figure><p>得到的返回也可能不是JSON，就像如果这API遇到一个错误并且它试图渲染一个正常的 HTML 错误，而不是 JSON。为了安全起见，您应该检查内容类型，并在解析时发现任何错误。</p><figure class="highlight coffee"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">robot.http(<span class="string">&quot;https://midnight-train&quot;</span>)</span><br><span class="line">  .header(<span class="string">&#x27;Accept&#x27;</span>, <span class="string">&#x27;application/json&#x27;</span>)</span><br><span class="line">  .get() (err, res, body) -&gt;</span><br><span class="line">    <span class="comment"># err &amp; response status checking code here</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> response.getHeader(<span class="string">&#x27;Content-Type&#x27;</span>) <span class="keyword">isnt</span> <span class="string">&#x27;application/json&#x27;</span></span><br><span class="line">      res.send <span class="string">&quot;Didn&#x27;t get back JSON :(&quot;</span></span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    data = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">      data = <span class="built_in">JSON</span>.parse body</span><br><span class="line">    <span class="keyword">catch</span> error</span><br><span class="line">     res.send <span class="string">&quot;Ran into an error parsing JSON :(&quot;</span></span><br><span class="line">     <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># your code here</span></span><br></pre></td></tr></table></figure><h4 id="XML"><a href="#XML" class="headerlink" title="XML"></a>XML</h4><p>XML API 比较难，因为没有捆绑的 XML 解析库。详细介绍此文档的范围超出了此范围，但下面有一些可以查看的库：</p><ul><li><a target="_blank" rel="noopener" href="https://github.com/buglabs/node-xml2json">xml2json</a> (simplest to use, but has some limitations)</li><li><a target="_blank" rel="noopener" href="https://github.com/tmpvar/jsdom">jsdom</a> (JavaScript implementation of the W3C DOM)</li><li><a target="_blank" rel="noopener" href="https://github.com/Leonidas-from-XIV/node-xml2js">xml2js</a></li></ul><h4 id="萤幕抓取"><a href="#萤幕抓取" class="headerlink" title="萤幕抓取"></a>萤幕抓取</h4><p>对于没有 API 的时代，总有可能进行萤幕抓取。详细介绍此文档的范围超出了此范围，但下面是一些可以查看的库：</p><ul><li><a target="_blank" rel="noopener" href="https://github.com/MatthewMueller/cheerio">cheerio</a> (familiar syntax and API to jQuery)</li><li><a target="_blank" rel="noopener" href="https://github.com/tmpvar/jsdom">jsdom</a> (JavaScript implementation of the W3C DOM)</li></ul><h4 id="高级-HTTP-和-HTTPS-设置"><a href="#高级-HTTP-和-HTTPS-设置" class="headerlink" title="高级 HTTP 和 HTTPS 设置"></a>高级 HTTP 和 HTTPS 设置</h4><p>前面提到，hubot 使用<a target="_blank" rel="noopener" href="https://github.com/technoweenie/node-scoped-http-client">node-scoped-http-client</a>来提供一个简单的接口去发起HTTP和HTTPS请求。它封装了node的<a target="_blank" rel="noopener" href="http://nodejs.org/api/http.html">http</a>和<a target="_blank" rel="noopener" href="http://nodejs.org/api/https.html">https</a>库，但为常见的交互类型提供了一个简单的DSL（Domain Specific Language 领域专用语言）。</p><p>如果你需要直接控制http和https的选项，你传第二个参数给<code>robot.http</code>，它将通过 node-scoped-http-client 传递给 http 或者 https：</p><figure class="highlight coffee"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">options =</span><br><span class="line">  <span class="comment"># don&#x27;t verify server certificate against a CA, SCARY!</span></span><br><span class="line">  rejectUnauthorized: <span class="literal">false</span></span><br><span class="line">robot.http(<span class="string">&quot;https://midnight-train&quot;</span>, options)</span><br></pre></td></tr></table></figure><p>另外，如果node-scoped-http-client并不适合你，你可以直接使用<a target="_blank" rel="noopener" href="http://nodejs.org/api/http.html">http</a>和<a target="_blank" rel="noopener" href="http://nodejs.org/api/https.html">https</a>，或者其它的node库，例如：<a target="_blank" rel="noopener" href="https://github.com/request/request">request</a></p><h3 id="随机"><a href="#随机" class="headerlink" title="随机"></a>随机</h3><p>一种常见的模式是聆听或响应命令，并发送随机有趣的图像或文本从一个包含可能性的数组。直接使用JavaScript和CoffeeScript来实现比较麻烦， 所以 hubot 包括一个方便的方法：</p><figure class="highlight coffee"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">lulz = [<span class="string">&#x27;lol&#x27;</span>, <span class="string">&#x27;rofl&#x27;</span>, <span class="string">&#x27;lmao&#x27;</span>]</span><br><span class="line"></span><br><span class="line">res.send res.random lulz</span><br></pre></td></tr></table></figure><h3 id="主题"><a href="#主题" class="headerlink" title="主题"></a>主题</h3><p>Hubot 可以响应一个房间的主题变化，假设适配器支持它：</p><figure class="highlight coffee"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.<span class="built_in">exports</span> = <span class="function"><span class="params">(robot)</span> -&gt;</span></span><br><span class="line">  robot.topic (res) -&gt;</span><br><span class="line">    res.send <span class="string">&quot;<span class="subst">#&#123;res.message.text&#125;</span>? That&#x27;s a Paddlin&#x27;&quot;</span></span><br></pre></td></tr></table></figure><h3 id="加入和离开"><a href="#加入和离开" class="headerlink" title="加入和离开"></a>加入和离开</h3><p>Hubot 能够观察用户的加入和离开，假设适配器支持它。</p><figure class="highlight coffee"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">enterReplies = [<span class="string">&#x27;Hi&#x27;</span>, <span class="string">&#x27;Target Acquired&#x27;</span>, <span class="string">&#x27;Firing&#x27;</span>, <span class="string">&#x27;Hello friend.&#x27;</span>, <span class="string">&#x27;Gotcha&#x27;</span>, <span class="string">&#x27;I see you&#x27;</span>]</span><br><span class="line">leaveReplies = [<span class="string">&#x27;Are you still there?&#x27;</span>, <span class="string">&#x27;Target lost&#x27;</span>, <span class="string">&#x27;Searching&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.<span class="built_in">exports</span> = <span class="function"><span class="params">(robot)</span> -&gt;</span></span><br><span class="line">  robot.enter (res) -&gt;</span><br><span class="line">    res.send res.random enterReplies</span><br><span class="line">  robot.leave (res) -&gt;</span><br><span class="line">    res.send res.random leaveReplies</span><br></pre></td></tr></table></figure><h3 id="自定义监听器"><a href="#自定义监听器" class="headerlink" title="自定义监听器"></a>自定义监听器</h3><p>虽然上面的 helpers 涵盖了普通用户需要的大部分功能（聆听、响应、加入、离开、主题），有时你想为监听器赋予特定的匹配逻辑。如果是这样，您可以使用<code>listen</code>来指定自定义匹配函数来替代正则表达。</p><p>如果监听器回调要被执行，匹配函数必须返回真实值。然后将匹配函数的真实返回值用<code>response.match</code>传递给回调。</p><figure class="highlight coffee"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.<span class="built_in">exports</span> = <span class="function"><span class="params">(robot)</span> -&gt;</span></span><br><span class="line">  robot.listen(</span><br><span class="line">    (message) -&gt; <span class="comment"># Match function</span></span><br><span class="line">      <span class="comment"># Occassionally respond to things that Steve says</span></span><br><span class="line">      message.user.name <span class="keyword">is</span> <span class="string">&quot;Steve&quot;</span> <span class="keyword">and</span> <span class="built_in">Math</span>.random() &gt; <span class="number">0.8</span></span><br><span class="line">    (response) -&gt; <span class="comment"># Standard listener callback</span></span><br><span class="line">      <span class="comment"># Let Steve know how happy you are that he exists</span></span><br><span class="line">      response.reply <span class="string">&quot;HI STEVE! YOU&#x27;RE MY BEST FRIEND! (but only like <span class="subst">#&#123;response.match * <span class="number">100</span>&#125;</span>% of the time)&quot;</span></span><br><span class="line">  )</span><br></pre></td></tr></table></figure><p>有关复杂的匹配器示例，请参阅<a target="_blank" rel="noopener" href="https://hubot.github.com/docs/patterns/">设计模式文档</a>。</p><h3 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h3><p>Hubot 可以使用<a target="_blank" rel="noopener" href="http://nodejs.org/api/process.html#process_process_env">process.env</a>访问他运行的环境，就像任何其他node程序一样。这可用于配置脚本的运行方式，约定使用<code>HUBOT_</code>前缀。</p><figure class="highlight coffee"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">answer = process.env.HUBOT_ANSWER_TO_THE_ULTIMATE_QUESTION_OF_LIFE_THE_UNIVERSE_AND_EVERYTHING</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.<span class="built_in">exports</span> = <span class="function"><span class="params">(robot)</span> -&gt;</span></span><br><span class="line">  robot.respond <span class="regexp">/what is the answer to the ultimate question of life/</span>, <span class="function"><span class="params">(res)</span> -&gt;</span></span><br><span class="line">    res.send <span class="string">&quot;<span class="subst">#&#123;answer&#125;</span>, but what is the question?&quot;</span></span><br></pre></td></tr></table></figure><p>小心的去确保环境变量没有定义时脚本可以加载，给 hubot 开发者去定义该环境变量的提示，或者默认的一些东西。由脚本编写者来决定这是否应该是一个致命的错误（e.g. hubot 退出），也可以制作任何依赖于它的脚本，去表明它需要配置。在尽可能和有意义时，脚本运作不需要任何其它的配置更好。</p><p>在这里，我们可以默认的东西：</p><figure class="highlight coffee"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">answer = process.env.HUBOT_ANSWER_TO_THE_ULTIMATE_QUESTION_OF_LIFE_THE_UNIVERSE_AND_EVERYTHING <span class="keyword">or</span> <span class="number">42</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.<span class="built_in">exports</span> = <span class="function"><span class="params">(robot)</span> -&gt;</span></span><br><span class="line">  robot.respond <span class="regexp">/what is the answer to the ultimate question of life/</span>, <span class="function"><span class="params">(res)</span> -&gt;</span></span><br><span class="line">    res.send <span class="string">&quot;<span class="subst">#&#123;answer&#125;</span>, but what is the question?&quot;</span></span><br></pre></td></tr></table></figure><p>如果环境变量没有定义，在这里我们退出：</p><figure class="highlight coffee"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">answer = process.env.HUBOT_ANSWER_TO_THE_ULTIMATE_QUESTION_OF_LIFE_THE_UNIVERSE_AND_EVERYTHING</span><br><span class="line"><span class="keyword">unless</span> answer?</span><br><span class="line">  <span class="built_in">console</span>.log <span class="string">&quot;Missing HUBOT_ANSWER_TO_THE_ULTIMATE_QUESTION_OF_LIFE_THE_UNIVERSE_AND_EVERYTHING in environment: please set and try again&quot;</span></span><br><span class="line">  process.exit(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.<span class="built_in">exports</span> = <span class="function"><span class="params">(robot)</span> -&gt;</span></span><br><span class="line">  robot.respond <span class="regexp">/what is the answer to the ultimate question of life/</span>, <span class="function"><span class="params">(res)</span> -&gt;</span></span><br><span class="line">    res.send <span class="string">&quot;<span class="subst">#&#123;answer&#125;</span>, but what is the question?&quot;</span></span><br></pre></td></tr></table></figure><p>最后， 我们更新<code>robot.repond</code>去检查它：</p><figure class="highlight coffee"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">answer = process.env.HUBOT_ANSWER_TO_THE_ULTIMATE_QUESTION_OF_LIFE_THE_UNIVERSE_AND_EVERYTHING</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.<span class="built_in">exports</span> = <span class="function"><span class="params">(robot)</span> -&gt;</span></span><br><span class="line">  robot.respond <span class="regexp">/what is the answer to the ultimate question of life/</span>, <span class="function"><span class="params">(res)</span> -&gt;</span></span><br><span class="line">    <span class="keyword">unless</span> answer?</span><br><span class="line">      res.send <span class="string">&quot;Missing HUBOT_ANSWER_TO_THE_ULTIMATE_QUESTION_OF_LIFE_THE_UNIVERSE_AND_EVERYTHING in environment: please set and try again&quot;</span></span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    res.send <span class="string">&quot;<span class="subst">#&#123;answer&#125;</span>, but what is the question?&quot;</span></span><br></pre></td></tr></table></figure><h3 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h3><p>Hubot 使用<a target="_blank" rel="noopener" href="https://github.com/isaacs/npm">npm</a>去管理它的依赖。要去添加额外的包，添加它们到<code>package.json</code>文件的<code>dependencies</code>中。例如，添加<code>lolimadeupthispackage 1.2.3</code>，如：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&quot;dependencies&quot;: &#123;</span><br><span class="line">  &quot;hubot&quot;:         &quot;2.5.5&quot;,</span><br><span class="line">  &quot;lolimadeupthispackage&quot;: &quot;1.2.3&quot;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>如果您使用 hubot-scripts 中的脚本，记下要添加的脚本中的<code>Dependencies</code>文档。它们以可以复制粘贴进<code>package.json</code>的格式列出，只需确保根据需要添加逗号使其成为有效 JSON即可。</p><h3 id="超时和间隔"><a href="#超时和间隔" class="headerlink" title="超时和间隔"></a>超时和间隔</h3><blockquote><p>译者注：这里普及JavaScript的<code>setTimeout</code>和<code>setInterval</code>语法。</p></blockquote><p>Hubot可以使用JavaScript内置的<a target="_blank" rel="noopener" href="http://nodejs.org/api/timers.html#timers_settimeout_callback_delay_arg">setTimeout</a>来延迟运行代码。</p><figure class="highlight coffee"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.<span class="built_in">exports</span> = <span class="function"><span class="params">(robot)</span> -&gt;</span></span><br><span class="line">  robot.respond <span class="regexp">/you are a little slow/</span>, <span class="function"><span class="params">(res)</span> -&gt;</span></span><br><span class="line">    <span class="built_in">setTimeout</span> () -&gt;</span><br><span class="line">      res.send <span class="string">&quot;Who you calling &#x27;slow&#x27;?&quot;</span></span><br><span class="line">    , <span class="number">60</span> * <span class="number">1000</span></span><br></pre></td></tr></table></figure><p>另外，hubot可以用<a target="_blank" rel="noopener" href="http://nodejs.org/api/timers.html#timers_setinterval_callback_delay_arg">setInterval</a>来间隔运行代码。它需要回调方法，以及调用之间的等待时间：</p><figure class="highlight coffee"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.<span class="built_in">exports</span> = <span class="function"><span class="params">(robot)</span> -&gt;</span></span><br><span class="line">  robot.respond <span class="regexp">/annoy me/</span>, <span class="function"><span class="params">(res)</span> -&gt;</span></span><br><span class="line">    res.send <span class="string">&quot;Hey, want to hear the most annoying sound in the world?&quot;</span></span><br><span class="line">    <span class="built_in">setInterval</span> () -&gt;</span><br><span class="line">      res.send <span class="string">&quot;AAAAAAAAAAAEEEEEEEEEEEEEEEEEEEEEEEEIIIIIIIIHHHHHHHHHH&quot;</span></span><br><span class="line">    , <span class="number">1000</span></span><br></pre></td></tr></table></figure><p><code>setTimeout</code>和<code>setInterval</code>创建时，都返回超时或间隔的ID。这可用于<code>clearTimeout</code>和<code>clearInterval</code>。</p><figure class="highlight coffee"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.<span class="built_in">exports</span> = <span class="function"><span class="params">(robot)</span> -&gt;</span></span><br><span class="line">  annoyIntervalId = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">  robot.respond <span class="regexp">/annoy me/</span>, <span class="function"><span class="params">(res)</span> -&gt;</span></span><br><span class="line">    <span class="keyword">if</span> annoyIntervalId</span><br><span class="line">      res.send <span class="string">&quot;AAAAAAAAAAAEEEEEEEEEEEEEEEEEEEEEEEEIIIIIIIIHHHHHHHHHH&quot;</span></span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    res.send <span class="string">&quot;Hey, want to hear the most annoying sound in the world?&quot;</span></span><br><span class="line">    annoyIntervalId = <span class="built_in">setInterval</span> () -&gt;</span><br><span class="line">      res.send <span class="string">&quot;AAAAAAAAAAAEEEEEEEEEEEEEEEEEEEEEEEEIIIIIIIIHHHHHHHHHH&quot;</span></span><br><span class="line">    , <span class="number">1000</span></span><br><span class="line"></span><br><span class="line">  robot.respond <span class="regexp">/unannoy me/</span>, <span class="function"><span class="params">(res)</span> -&gt;</span></span><br><span class="line">    <span class="keyword">if</span> annoyIntervalId</span><br><span class="line">      res.send <span class="string">&quot;GUYS, GUYS, GUYS!&quot;</span></span><br><span class="line">      <span class="built_in">clearInterval</span>(annoyIntervalId)</span><br><span class="line">      annoyIntervalId = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      res.send <span class="string">&quot;Not annoying you right now, am I?&quot;</span></span><br></pre></td></tr></table></figure><h3 id="HTTP-监听器"><a href="#HTTP-监听器" class="headerlink" title="HTTP 监听器"></a>HTTP 监听器</h3><p>Hubot 包括支持<a target="_blank" rel="noopener" href="http://expressjs.com/">express</a>网络框架以满足HTTP请求。它监听<code>EXPRESS_PORT</code>或<code>PORT</code>环境变量指定的端口（按该顺序首选），默认值设置为8080。一个express应用的实例可在<code>robot.router</code>中。可以通过指定<code>EXPRESS_USER</code>和<code>EXPRESS_PASSWORD</code>来保护用户名和密码。通过设置<code>EXPRESS_STATIC</code>它可以自动为静态文件服务。</p><p>最常见的用途是为带有webhooks的服务提供HTTP端点去推送，并让这些出现在聊天中。</p><figure class="highlight coffee"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.<span class="built_in">exports</span> = <span class="function"><span class="params">(robot)</span> -&gt;</span></span><br><span class="line">  <span class="comment"># the expected value of :room is going to vary by adapter, it might be a numeric id, name, token, or some other value</span></span><br><span class="line">  robot.router.post <span class="string">&#x27;/hubot/chatsecrets/:room&#x27;</span>, <span class="function"><span class="params">(req, res)</span> -&gt;</span></span><br><span class="line">    room   = req.params.room</span><br><span class="line">    data   = <span class="keyword">if</span> req.body.payload? <span class="keyword">then</span> <span class="built_in">JSON</span>.parse req.body.payload <span class="keyword">else</span> req.body</span><br><span class="line">    secret = data.secret</span><br><span class="line"></span><br><span class="line">    robot.messageRoom room, <span class="string">&quot;I have a secret: <span class="subst">#&#123;secret&#125;</span>&quot;</span></span><br><span class="line"></span><br><span class="line">    res.send <span class="string">&#x27;OK&#x27;</span></span><br></pre></td></tr></table></figure><p>用curl测试它；另请参阅下面关于<a target="_blank" rel="noopener" href="https://hubot.github.com/docs/scripting/#error-handling">error handling</a>的部分。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; raw json, must specify Content-Type: application&#x2F;json</span><br><span class="line">curl -X POST -H &quot;Content-Type: application&#x2F;json&quot; -d &#39;&#123;&quot;secret&quot;:&quot;C-TECH Astronomy&quot;&#125;&#39; http:&#x2F;&#x2F;127.0.0.1:8080&#x2F;hubot&#x2F;chatsecrets&#x2F;general</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; defaults Content-Type: application&#x2F;x-www-form-urlencoded, must st payload&#x3D;...</span><br><span class="line">curl -d &#39;payload&#x3D;%7B%22secret%22%3A%22C-TECH+Astronomy%22%7D&#39; http:&#x2F;&#x2F;127.0.0.1:8080&#x2F;hubot&#x2F;chatsecrets&#x2F;general</span><br></pre></td></tr></table></figure><p>所有的端点URLs应该以<code>/hubot</code>起头（无论你的机器人及叫什么名字）。这种一致性使得设置webhooks（可复制粘贴的URL）更加容易，并且保证URLs是有效的（并不是所有的bot命名都是URL安全的）。</p><h3 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h3><p>Hubot 还可以响应可用于在脚本之间传递数据的事件。这是通过使用<code>robot.emit</code>和<code>robot.on</code>封装node.js的<a target="_blank" rel="noopener" href="http://nodejs.org/api/events.html#events_class_events_eventemitter">EventEmitter</a>实现的。</p><p>其中一个用例是，有一个脚本用于处理与服务的交互，然后在事件出现时发送。例如，我们有一个脚本从 GitHub <code>post-commit</code> 钩子接收数据，当 commits 来时发送 commits 事件，然后对这些提交进行另一个脚本行为。</p><figure class="highlight coffee"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># src/scripts/github-commits.coffee</span></span><br><span class="line"><span class="built_in">module</span>.<span class="built_in">exports</span> = <span class="function"><span class="params">(robot)</span> -&gt;</span></span><br><span class="line">  robot.router.post <span class="string">&quot;/hubot/gh-commits&quot;</span>, <span class="function"><span class="params">(req, res)</span> -&gt;</span></span><br><span class="line">    robot.emit <span class="string">&quot;commit&quot;</span>, &#123;</span><br><span class="line">        user    : &#123;&#125;, <span class="comment">#hubot user object</span></span><br><span class="line">        repo    : <span class="string">&#x27;https://github.com/github/hubot&#x27;</span>,</span><br><span class="line">        hash  : <span class="string">&#x27;2e1951c089bd865839328592ff673d2f08153643&#x27;</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight coffee"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># src/scripts/heroku.coffee</span></span><br><span class="line"><span class="built_in">module</span>.<span class="built_in">exports</span> = <span class="function"><span class="params">(robot)</span> -&gt;</span></span><br><span class="line">  robot.<span class="literal">on</span> <span class="string">&quot;commit&quot;</span>, <span class="function"><span class="params">(commit)</span> -&gt;</span></span><br><span class="line">    robot.send commit.user, <span class="string">&quot;Will now deploy <span class="subst">#&#123;commit.hash&#125;</span> from <span class="subst">#&#123;commit.repo&#125;</span>!&quot;</span></span><br><span class="line">    <span class="comment">#deploy code goes here</span></span><br></pre></td></tr></table></figure><p>如果您提供一个事件，强烈建议在其数据中包括 hubot user或room对象。这将允许hubot 在聊天中通知用户或房间。</p><h3 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h3><p>没有完美的代码，并且错误和意外是意料之中的。以前，一个未捕获的异常会是您的hubot实例崩溃。Hubot现在包含了一个<code>uncaughtException</code>处理程序，它为脚本提供钩子以此来进行错误处理。</p><figure class="highlight coffee"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># src/scripts/does-not-compute.coffee</span></span><br><span class="line"><span class="built_in">module</span>.<span class="built_in">exports</span> = <span class="function"><span class="params">(robot)</span> -&gt;</span></span><br><span class="line">  robot.error (err, res) -&gt;</span><br><span class="line">    robot.logger.error <span class="string">&quot;DOES NOT COMPUTE&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> res?</span><br><span class="line">      res.reply <span class="string">&quot;DOES NOT COMPUTE&quot;</span></span><br></pre></td></tr></table></figure><p>你可以在这里做任何你想做的事，但你会想采取额外的预防措施来拯救和记录错误，特别是异步代码。否则，你可能会发现自己有递归的错误，却不知道发生了什么事情。</p><p>在头巾之下，‘error’事件发射出来，伴随着的是错误处理程序消费那个事件。<code>uncaughtException</code>处理程序，<a target="_blank" rel="noopener" href="http://nodejs.org/api/process.html#process_event_uncaughtexception">从技术上讲， 使过程处于未知状态。</a>。因此，无论何时你应该尽可能的拯救你自己的异常，并且自己发出它们。第一个参数是发出的错误，第二个参数是生成错误的可选消息。<br>使用前面的例子：</p><figure class="highlight coffee"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">robot.router.post <span class="string">&#x27;/hubot/chatsecrets/:room&#x27;</span>, <span class="function"><span class="params">(req, res)</span> -&gt;</span></span><br><span class="line">  room = req.params.room</span><br><span class="line">  data = <span class="literal">null</span></span><br><span class="line">  <span class="keyword">try</span></span><br><span class="line">    data = <span class="built_in">JSON</span>.parse req.body.payload</span><br><span class="line">  <span class="keyword">catch</span> err</span><br><span class="line">    robot.emit <span class="string">&#x27;error&#x27;</span>, err</span><br><span class="line"></span><br><span class="line">  <span class="comment"># rest of the code here</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">robot.hear <span class="regexp">/midnight train/i</span>, <span class="function"><span class="params">(res)</span> -&gt;</span></span><br><span class="line">  robot.http(<span class="string">&quot;https://midnight-train&quot;</span>)</span><br><span class="line">    .get() (err, res, body) -&gt;</span><br><span class="line">      <span class="keyword">if</span> err</span><br><span class="line">        res.reply <span class="string">&quot;Had problems taking the midnight train&quot;</span></span><br><span class="line">        robot.emit <span class="string">&#x27;error&#x27;</span>, err, res</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">      <span class="comment"># rest of code here</span></span><br></pre></td></tr></table></figure><p>对于第二个例子，值得思考的是用户会看到哪些消息。如果您有回复用户的错误处理程序，您可能不需要添加自定义消息，并且可以发回提供给get()请求的错误消息，当然这取决于你想多么的公开你的错误报告。</p><h3 id="脚本文档"><a href="#脚本文档" class="headerlink" title="脚本文档"></a>脚本文档</h3><p>Hubot 脚本可以用在其文件顶部的注释编写文档，例如：</p><figure class="highlight coffee"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Description:</span></span><br><span class="line"><span class="comment">#   &lt;description of the scripts functionality&gt;</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Dependencies:</span></span><br><span class="line"><span class="comment">#   &quot;&lt;module name&gt;&quot;: &quot;&lt;module version&gt;&quot;</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Configuration:</span></span><br><span class="line"><span class="comment">#   LIST_OF_ENV_VARS_TO_SET</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Commands:</span></span><br><span class="line"><span class="comment">#   hubot &lt;trigger&gt; - &lt;what the respond trigger does&gt;</span></span><br><span class="line"><span class="comment">#   &lt;trigger&gt; - &lt;what the hear trigger does&gt;</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Notes:</span></span><br><span class="line"><span class="comment">#   &lt;optional notes required for the script&gt;</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Author:</span></span><br><span class="line"><span class="comment">#   &lt;github username of the original script author&gt;</span></span><br></pre></td></tr></table></figure><p>这最重要的和用户面向的是<code>Commands</code>。在加载时间，Hubot 查看每个脚本的命令部分，并建立所有命令的列表。包含的<code>help.coffee</code>允许用户在所有命令或搜索中寻求帮助。因此，为这些命令制作文档使用户更容易发现这些命令。</p><p>为命令制作文档的时候，这里有一些最佳实践：</p><ul><li>保持在一行。帮助命令会被排序，因此第二行可能会被插到一个出乎意料的的地方，使得它没有意义。</li><li>将 Hubot 命名为 hubot，即使你的 hubot 被命名为其它。它将被自动替换为正确的名字。这使得无需更新文档即可轻松共享脚本。</li><li>对于<code>robot.respond</code>文档，总是以<code>hubot</code>作为前缀。Hubot将自动用你的机器人名字或者机器人的别名替换。</li><li>查看 man 手册文档是怎样制作自己的文档的。特别是，括号表示可选项，”…”表示任意数量的参数，等。</li></ul><p>文档的其它部分与bot的开发人员更相关，尤其是依赖、配置变量和说明。对<a target="_blank" rel="noopener" href="https://github.com/github/hubot-scripts">hubot-scripts</a>的所有贡献应包含与脚本启动和运行相关的所有这些部分。</p><h3 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h3><p>Hubot暴露<code>robot.brain</code>内存键值存储，可用于通过脚本存储和检索数据。</p><figure class="highlight coffee"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">robot.respond <span class="regexp">/have a soda/i</span>, <span class="function"><span class="params">(res)</span> -&gt;</span></span><br><span class="line">  <span class="comment"># Get number of sodas had (coerced to a number).</span></span><br><span class="line">  sodasHad = robot.brain.get(<span class="string">&#x27;totalSodas&#x27;</span>) * <span class="number">1</span> <span class="keyword">or</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> sodasHad &gt; <span class="number">4</span></span><br><span class="line">    res.reply <span class="string">&quot;I&#x27;m too fizzy..&quot;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    res.reply <span class="string">&#x27;Sure!&#x27;</span></span><br><span class="line"></span><br><span class="line">    robot.brain.set <span class="string">&#x27;totalSodas&#x27;</span>, sodasHad+<span class="number">1</span></span><br><span class="line">robot.respond <span class="regexp">/sleep it off/i</span>, <span class="function"><span class="params">(res)</span> -&gt;</span></span><br><span class="line">  robot.brain.set <span class="string">&#x27;totalSodas&#x27;</span>, <span class="number">0</span></span><br><span class="line">  msg.reply <span class="string">&#x27;zzzzz&#x27;</span></span><br></pre></td></tr></table></figure><p>如果脚本需要检索用户数据，<code>robot.brain</code>上有些方法通过id，name，或者name的模糊匹配：<code>userForName</code>, <code>userForId</code>, <code>userForFuzzyName</code>和<code>usersForFuzzyName</code>去查找一个或者多个用户。</p><figure class="highlight coffee"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.<span class="built_in">exports</span> = <span class="function"><span class="params">(robot)</span> -&gt;</span></span><br><span class="line"></span><br><span class="line">  robot.respond <span class="regexp">/who is @?([\w .\-]+)\?*$/i</span>, <span class="function"><span class="params">(res)</span> -&gt;</span></span><br><span class="line">    name = res.match[<span class="number">1</span>].trim()</span><br><span class="line"></span><br><span class="line">    users = robot.brain.usersForFuzzyName(name)</span><br><span class="line">    <span class="keyword">if</span> users.length <span class="keyword">is</span> <span class="number">1</span></span><br><span class="line">      user = users[<span class="number">0</span>]</span><br><span class="line">      <span class="comment"># Do something interesting here..</span></span><br><span class="line"></span><br><span class="line">      res.send <span class="string">&quot;<span class="subst">#&#123;name&#125;</span> is user - <span class="subst">#&#123;user&#125;</span>&quot;</span></span><br></pre></td></tr></table></figure><h3 id="脚本加载"><a href="#脚本加载" class="headerlink" title="脚本加载"></a>脚本加载</h3><p>加载脚本有三个主要来源：</p><ul><li><code>scripts/</code>目录下的所有脚本都与你的 hubot 绑定。</li><li><code>hubot-scripts.json</code>中指定的社区脚本，并发布在 <code>hubot-scripts</code> npm 包。</li><li>脚本从外部 npm 包加载， 并在 <code>external-scripts.json</code> 中指定。</li></ul><p>从<code>scripts/</code>目录中加载的脚本按字母顺序加载，因此您可以预期脚本的一致加载顺序。例如：</p><ul><li><code>scripts/1-first.coffee</code></li><li><code>scripts/_second.coffee</code></li><li><code>scripts/third.coffee</code></li></ul><h3 id="分享脚本"><a href="#分享脚本" class="headerlink" title="分享脚本"></a>分享脚本</h3><p>一旦你构建了一些新的脚本，以扩大你的机器人朋友的能力，你应该考虑与世界分享他们！至少，您需要打包脚本并将其提交到 <code>Node.js 程序包仓库</code>。您还应查看以下共享脚本的最佳实践。</p><h4 id="查看脚本是否已存在"><a href="#查看脚本是否已存在" class="headerlink" title="查看脚本是否已存在"></a>查看脚本是否已存在</h4><p>首先<a target="_blank" rel="noopener" href="https://hubot.github.com/docs/#scripts">检查像您这样的脚本的 NPM 包是否已经存在</a>。如果您没有看到可以贡献的现有包，则可以轻松地开始使用 hubot 脚本 <a target="_blank" rel="noopener" href="http://yeoman.io/">yeoman</a> 生成器。</p><h4 id="创建一个脚本程序包"><a href="#创建一个脚本程序包" class="headerlink" title="创建一个脚本程序包"></a>创建一个脚本程序包</h4><p>为 hubot 创建脚本包非常简单。首先安装<a target="_blank" rel="noopener" href="http://yeoman.io/">yeoman</a>生成器：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> npm install -g yo generator-hubot</span></span><br></pre></td></tr></table></figure><p>安装hubot生成器后，创建hubot脚本类似于创建一个新的hubot。您为您的hubot脚本创建目录，并在其中生成一个新的<code>hubot:script</code>。例如，如果我们想创建一个 hubot 脚本叫“my-awesome-script”:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> mkdir hubot-my-awesome-script</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> hubot-my-awesome-script</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> yo hubot:script</span></span><br></pre></td></tr></table></figure><p>此时，您会被问到一些有关脚本作者的问题，脚本的名字（由目录名猜测），一个简短的描述，和去查找它的关键字（我们建议至少有<code>hubot</code>，<code>hubot-scripts</code>）。</p><p>如果您使用的是 git，生成的目录包含一个 .gitignore，因此您可以初始化并添加所有内容：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git init</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git add .</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git commit -m <span class="string">&quot;Initial commit&quot;</span></span></span><br></pre></td></tr></table></figure><p>您现在有一个准备好去启动的hubot脚本库。轻松打开预创建的<code>src/awesome-script.coffee</code>文件，并开始构建您的脚本！准备好后，您可以<a target="_blank" rel="noopener" href="https://docs.npmjs.com/getting-started/publishing-npm-packages">按照他们的文档</a>将其发布到 <a target="_blank" rel="noopener" href="http://npmjs.org/">npmjs</a>！</p><p>您可能需要为新脚本编写一些单元测试。测试脚本样例写在<code>test/awesome-script-test.coffee</code>，你可以用<code>grunt</code>运行。有关测试的更多信息，请参阅<a target="_blank" rel="noopener" href="https://hubot.github.com/docs/scripting/#testing-hubot-scripts">测试Hubot脚本</a>部分。</p><h3 id="监听器元数据"><a href="#监听器元数据" class="headerlink" title="监听器元数据"></a>监听器元数据</h3><p>除了正则表达和回调，<code>hear</code>和<code>respond</code>函数还接受一个可选的选项对象，它可以被用于附加任意元数据到生成的监听器对象。此元数据允许在不修改脚本包的情况下轻松扩展脚本的行为。</p><p>最重要和最常用的元数据键是<code>id</code>。每个监听器应该被赋予一个唯一的名字（options.id，默认是<code>null</code>）。名称应按模块划分（e.g. ‘my-module.my-listener’）。这些名称允许其他脚本直接针对单个监听器，并扩展它们的其他功能，如授权和速率限制。</p><p>其他扩展可以定义和处理其他元数据键。更多信息，请参阅<a target="_blank" rel="noopener" href="https://hubot.github.com/docs/scripting/#listener-middleware">Listener Middleware section</a>部分。</p><p>回到到较早的示例：</p><figure class="highlight coffee"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.<span class="built_in">exports</span> = <span class="function"><span class="params">(robot)</span> -&gt;</span></span><br><span class="line">  robot.respond <span class="regexp">/annoy me/</span>, id:<span class="string">&#x27;annoyance.start&#x27;</span>, (msg)</span><br><span class="line">    <span class="comment"># code to annoy someone</span></span><br><span class="line"></span><br><span class="line">  robot.respond <span class="regexp">/unannoy me/</span>, id:<span class="string">&#x27;annoyance.stop&#x27;</span>, (msg)</span><br><span class="line">    <span class="comment"># code to stop annoying someone</span></span><br></pre></td></tr></table></figure><p>这些范围标识符允许您外部指定新行为，如：</p><ul><li>授权政策： “允许<code>annoyers</code>组中的每个人执行<code>annoyance.*</code>命令”</li><li>限速：“只允许30分钟执行一次<code>annoyance.start</code>”</li></ul><h3 id="中间件"><a href="#中间件" class="headerlink" title="中间件"></a>中间件</h3><p>有三种中间件： Receive, Listener and Response。</p><p>在监听器被查看之前，Receive 中间件执行一次。Listener 中间件在监听器匹配到信息后执行。Response 中间件在每次响应一个消息时运行。</p><h4 id="执行过程和-API"><a href="#执行过程和-API" class="headerlink" title="执行过程和 API"></a>执行过程和 API</h4><p>类似于<a target="_blank" rel="noopener" href="http://expressjs.com/api.html#middleware">Express middleware</a>，hubot 按定义顺序执行中间件。每个中间件可以继续链（通过调用<code>next</code>）或中断链（通过调用<code>done</code>）。如果所有中间件继续，监听器回调被执行，并且<code>done</code>会被调用。中间件可以包装<code>done</code>的回调，以便在过程的后半部分执行代码（在执行了监听器回调或更深的中间件中断之后）。</p><p>中间件被调用：</p><ul><li><code>context</code><ul><li>查看每个中间件类型的 API，查看上下文暴露的内容。</li></ul></li><li><code>next</code><ul><li>一个没有额外的属性的函数，它应该被调用从而继续到下一块中间件/执行监听器的回调</li><li><code>next</code>应该用一个单独的、可选的参数调用：要么提供<code>done</code>函数，要么一个最终调用的时候叫<code>done</code>的新函数。如果参数没有指定，那么将假定为<code>done</code>。</li></ul></li><li><code>done</code><ul><li>一个没有附加属性的函数，用于在中断中间件执行时调用，并开始执行完成功能的链。</li><li><code>done</code>在调用时无需任何参数。</li></ul></li></ul><p>每个中间件接收相同的<code>context</code>、<code>next</code>和<code>done</code>的API签名。不同种类的中间件在<code>context</code>对象中可能接收到不同的信息。详细信息，请参阅每种类型的中间件的 API。</p><h4 id="错误处理-1"><a href="#错误处理-1" class="headerlink" title="错误处理"></a>错误处理</h4><p>对于同步中间件（从不产生事件循环），hubot 会自动捕获错误并发出<code>error</code>事件，就像标准的监听器一样。Hubot 还将自动调用最近<code>done</code>的回调以解除中间件堆栈。异步中间件应补捕获自己的异常，发出<code>error</code>事件，并调用<code>done</code>。任何未捕获的异常都会中断所有中间件完成回调的执行。</p><h3 id="Listener-中间件"><a href="#Listener-中间件" class="headerlink" title="Listener 中间件"></a>Listener 中间件</h3><p>Listener 中间件在匹配消息的监听器和监听器执行之间插入逻辑。这允许您创建为每个匹配脚本运行的扩展。示例包括集中授权策略、限速、记录和指标。中间件像其他 hubot 脚本一样实现：中间件不是使用<code>hear</code>和<code>respond</code>方法，而是通过<code>listenerMiddleware</code>注册。</p><h4 id="Listener-中间件示例"><a href="#Listener-中间件示例" class="headerlink" title="Listener 中间件示例"></a>Listener 中间件示例</h4><p>在<a target="_blank" rel="noopener" href="https://github.com/michaelansel/hubot-rate-limit/blob/master/src/rate-limit.coffee">hubot-rate-limit</a>中可以找到一个功能齐全的例子。</p><p>一个中间件logging命令执行的简单示例：</p><figure class="highlight coffee"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.<span class="built_in">exports</span> = <span class="function"><span class="params">(robot)</span> -&gt;</span></span><br><span class="line">  robot.listenerMiddleware (context, next, done) -&gt;</span><br><span class="line">    <span class="comment"># Log commands</span></span><br><span class="line">    robot.logger.info <span class="string">&quot;<span class="subst">#&#123;context.response.message.user.name&#125;</span> asked me to <span class="subst">#&#123;context.response.message.text&#125;</span>&quot;</span></span><br><span class="line">    <span class="comment"># Continue executing middleware</span></span><br><span class="line">    next()</span><br></pre></td></tr></table></figure><p>在此示例，将为与监听器匹配的每个聊天消息写入日志消息。</p><p>做出限速决策的更复杂示例：</p><figure class="highlight coffee"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.<span class="built_in">exports</span> = <span class="function"><span class="params">(robot)</span> -&gt;</span></span><br><span class="line">  <span class="comment"># Map of listener ID to last time it was executed</span></span><br><span class="line">  lastExecutedTime = &#123;&#125;</span><br><span class="line"></span><br><span class="line">  robot.listenerMiddleware (context, next, done) -&gt;</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">      <span class="comment"># Default to 1s unless listener provides a different minimum period</span></span><br><span class="line">      minPeriodMs = context.listener.options?.rateLimits?.minPeriodMs? <span class="keyword">or</span> <span class="number">1000</span></span><br><span class="line"></span><br><span class="line">      <span class="comment"># See if command has been executed recently</span></span><br><span class="line">      <span class="keyword">if</span> lastExecutedTime.hasOwnProperty(context.listener.options.id) <span class="keyword">and</span></span><br><span class="line">         lastExecutedTime[context.listener.options.id] &gt; <span class="built_in">Date</span>.now() - minPeriodMs</span><br><span class="line">        <span class="comment"># Command is being executed too quickly!</span></span><br><span class="line">        done()</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        next -&gt;</span><br><span class="line">          lastExecutedTime[context.listener.options.id] = <span class="built_in">Date</span>.now()</span><br><span class="line">          done()</span><br><span class="line">    <span class="keyword">catch</span> err</span><br><span class="line">      robot.emit(<span class="string">&#x27;error&#x27;</span>, err, context.response)</span><br></pre></td></tr></table></figure><p>在这个例子中，中间件检查监听器是否在过去1000ms中执行过。如果有，中间件立马调用<code>done</code>，防止监听器回调被调用。如果监听器允许被执行，中间件附加一个<code>done</code>处理器，以便它可以记录监听器完成执行的时间。</p><p>此示例还显示了如何利用特定于监听器的元数据创建非常强大的扩展：脚本开发人员只需添加中间件并设置监听器选项，即可使用速率限制中间件去以不同速率轻松率限制命令。</p><figure class="highlight coffee"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.<span class="built_in">exports</span> = <span class="function"><span class="params">(robot)</span> -&gt;</span></span><br><span class="line">  robot.hear <span class="regexp">/hello/</span>, id: <span class="string">&#x27;my-hello&#x27;</span>, rateLimits: &#123;minPeriodMs: <span class="number">10000</span>&#125;, <span class="function"><span class="params">(msg)</span> -&gt;</span></span><br><span class="line">    <span class="comment"># This will execute no faster than once every ten seconds</span></span><br><span class="line">    msg.reply <span class="string">&#x27;Why, hello there!&#x27;</span></span><br></pre></td></tr></table></figure><h4 id="Listener-中间件-API"><a href="#Listener-中间件-API" class="headerlink" title="Listener 中间件 API"></a>Listener 中间件 API</h4><p>Listener 中间件回调接收三个参数，<code>context</code>、<code>next</code>、<code>done</code>。有关<code>next</code>和<code>done</code>的描述，查看<a target="_blank" rel="noopener" href="https://hubot.github.com/docs/scripting/#execution-process-and-api">中间件API</a>。Listener 中间件上下文包含这些字段：</p><ul><li><code>listener</code><ul><li><code>options</code>：定义监听器时设置的一个简单的包含选项的对象。查看<a target="_blank" rel="noopener" href="https://hubot.github.com/docs/scripting/#listener-metadata">监听器元数据</a>。</li><li>所有其他属性应视为内部属性。</li></ul></li><li><code>response</code><ul><li>标准response API 的所有部分都包含在中间件 API 中。查看<a target="_blank" rel="noopener" href="https://hubot.github.com/docs/scripting/#send--reply">发送和回复</a>。</li><li>中间件可以用其他信息装饰（但不修改）响应对象（e.g. 例如将携带用户的 LDAP 组的属性添加到<code>response.message.user</code>）</li><li>注意：文本消息（<code>response.message.text</code>）在监听器中间件中应该被认为是不可变的。</li></ul></li></ul><h3 id="Receive-中间件"><a href="#Receive-中间件" class="headerlink" title="Receive 中间件"></a>Receive 中间件</h3><p>在任何监听器之行之前 Receive 中间件运行。它适用于尚未更新的黑名单命令以添加 ID、指标等。</p><h4 id="Receive-中间件示例"><a href="#Receive-中间件示例" class="headerlink" title="Receive 中间件示例"></a>Receive 中间件示例</h4><p>这个简单的中间件禁止特定用户使用 hubot，包括<code>hear</code>监听器。如果用户尝试明确地运行命令，它将返回错误消息。</p><figure class="highlight coffee"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">BLACKLISTED_USERS = [</span><br><span class="line">  <span class="string">&#x27;12345&#x27;</span> <span class="comment"># Restrict access for a user ID for a contractor</span></span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">robot.receiveMiddleware (context, next, done) -&gt;</span><br><span class="line">  <span class="keyword">if</span> context.response.message.user.id <span class="keyword">in</span> BLACKLISTED_USERS</span><br><span class="line">    <span class="comment"># Don&#x27;t process this message further.</span></span><br><span class="line">    context.response.message.finish()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># If the message starts with &#x27;hubot&#x27; or the alias pattern, this user was</span></span><br><span class="line">    <span class="comment"># explicitly trying to run a command, so respond with an error message.</span></span><br><span class="line">    <span class="keyword">if</span> context.response.message.text?.match(robot.respondPattern(<span class="string">&#x27;&#x27;</span>))</span><br><span class="line">      context.response.reply <span class="string">&quot;I&#x27;m sorry @<span class="subst">#&#123;context.response.message.user.name&#125;</span>, but I&#x27;m configured to ignore your commands.&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Don&#x27;t process further middleware.</span></span><br><span class="line">    done()</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    next(done)</span><br></pre></td></tr></table></figure><h4 id="Receive-中间件-API"><a href="#Receive-中间件-API" class="headerlink" title="Receive 中间件 API"></a>Receive 中间件 API</h4><p>Receive 中间件回调接收三个参数，<code>context</code>、<code>next</code>、<code>done</code>。有关<code>next</code>和<code>done</code>的描述，请参阅<a target="_blank" rel="noopener" href="https://hubot.github.com/docs/scripting/#execution-process-and-api">中间件 API</a>。Receive 中间件上下文包括这些字段：</p><ul><li><code>response</code><ul><li>response 对象没有<code>match</code>对象，因为还没有监听器运行。</li><li>中间件可能通过附加信息（e.g. 添加一个携带用户的LDAP组的属性到<code>response.message.user</code> ）来修饰response 对象。</li><li>中间件可能修改<code>response.message</code>对象。</li></ul></li></ul><h3 id="Response-中间件"><a href="#Response-中间件" class="headerlink" title="Response 中间件"></a>Response 中间件</h3><p>Response 中间件与 hubot 发送到聊天室的每个消息背道而驰。它有助于消息格式化、防止密码泄露、度量等。</p><h4 id="Response-中间件示例"><a href="#Response-中间件示例" class="headerlink" title="Response 中间件示例"></a>Response 中间件示例</h4><p>此简单示例将发送到聊天室的链接格式从markdown链接（如<a target="_blank" rel="noopener" href="https://example.com/">示例</a>）更改为 <a target="_blank" rel="noopener" href="https://slack.com/">Slack</a> 支持的格式，<a target="_blank" rel="noopener" href="https://example.com|示例./">https://example.com|示例。</a></p><figure class="highlight coffee"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.<span class="built_in">exports</span> = <span class="function"><span class="params">(robot)</span> -&gt;</span></span><br><span class="line">  robot.responseMiddleware (context, next, done) -&gt;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">unless</span> context.plaintext?</span><br><span class="line">    context.strings = (string.replace(<span class="regexp">/\[([^\[\]]*?)\]\((https?:\/\/.*?)\)/</span>, <span class="string">&quot;&lt;$2|$1&gt;&quot;</span>) <span class="keyword">for</span> string <span class="keyword">in</span> context.strings)</span><br><span class="line">    next()</span><br></pre></td></tr></table></figure><h4 id="Response-中间件-API"><a href="#Response-中间件-API" class="headerlink" title="Response 中间件 API"></a>Response 中间件 API</h4><p>Response 中间件回调接收三个参数，<code>context</code>、<code>next</code>、<code>done</code>。请参阅中间件 API 以了解<code>next</code>和<code>done</code>。Receive 中间件的上下文包括这些字段：</p><ul><li><code>response</code><ul><li>此响应对象可用于从中间件发送新消息。在这些新响应中，将调用中间件。小心不要创建无限循环。</li></ul></li><li><code>strings</code><ul><li>一个字符串数组被发送到聊天室适配器。你可以编辑这些，或者使用<code>context.strings = [&quot;new strings&quot;]</code>去替代它们。</li></ul></li><li><code>method</code><ul><li>表示监听器发送的响应消息类型的字符串，例如<code>send</code>、<code>reply</code>、<code>emot</code>或者<code>topic</code>。</li></ul></li><li><code>plaintext</code><ul><li><code>true</code>或者<code>undefined</code>。这将被设置为<code>true</code>，如果消息是正常的纯文本类型，例如<code>send</code>和<code>reply</code>。此属性应被视为仅读。</li></ul></li></ul><h3 id="测试-hubot-脚本"><a href="#测试-hubot-脚本" class="headerlink" title="测试 hubot 脚本"></a>测试 hubot 脚本</h3><p><a target="_blank" rel="noopener" href="https://github.com/mtsmfm/hubot-test-helper">hubot-test-helper</a>是一个用来单元测试hubot脚本的好框架。（请注意，为了使用 <code>hubot-test-helper,</code>，您需要一个支持Promises的最近Node版本。）</p><p>在 Hubot 实例中安装包：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install hubot-test-helper --save-dev</span><br></pre></td></tr></table></figure><p>您还需要安装：</p><ul><li>一个JavaScript测试框架，例如<em>Mocha</em></li><li>一个断言库，例如<em>chai</em>或者<em>expect.js</em></li></ul><p>您或许还想安装：</p><ul><li><em>coffee-script</em>（如果你用CoffeeScript写你的测试而不是JavaScript）</li><li>一个mocking库例如<em>Sinon.js</em>（如果您的脚本执行网络请求或其他异步操作）</li></ul><p>下面是一个示例脚本，测试 <a target="_blank" rel="noopener" href="https://github.com/github/generator-hubot/blob/master/generators/app/templates/scripts/example.coffee">Hubot 示例脚本</a>中的前几个命令。这个脚本使用<em>Mocha</em>、<em>chai</em>、<em>coffeescript</em>，当然还有<em>hubot-test-helper</em>。</p><p><strong>test/example-test.coffee</strong></p><figure class="highlight coffee"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">Helper = <span class="built_in">require</span>(<span class="string">&#x27;hubot-test-helper&#x27;</span>)</span><br><span class="line">chai = <span class="built_in">require</span> <span class="string">&#x27;chai&#x27;</span></span><br><span class="line"></span><br><span class="line">expect = chai.expect</span><br><span class="line"></span><br><span class="line">helper = <span class="keyword">new</span> Helper(<span class="string">&#x27;../scripts/example.coffee&#x27;</span>)</span><br><span class="line"></span><br><span class="line">describe <span class="string">&#x27;example script&#x27;</span>, <span class="function">-&gt;</span></span><br><span class="line">  beforeEach -&gt;</span><br><span class="line">    @room = helper.createRoom()</span><br><span class="line"></span><br><span class="line">  afterEach -&gt;</span><br><span class="line">    @room.destroy()</span><br><span class="line"></span><br><span class="line">  it <span class="string">&#x27;doesn\&#x27;t need badgers&#x27;</span>, <span class="function">-&gt;</span></span><br><span class="line">    @room.user.say(<span class="string">&#x27;alice&#x27;</span>, <span class="string">&#x27;did someone call for a badger?&#x27;</span>).<span class="keyword">then</span> =&gt;</span><br><span class="line">      expect(@room.messages).to.eql [</span><br><span class="line">        [<span class="string">&#x27;alice&#x27;</span>, <span class="string">&#x27;did someone call for a badger?&#x27;</span>]</span><br><span class="line">        [<span class="string">&#x27;hubot&#x27;</span>, <span class="string">&#x27;Badgers? BADGERS? WE DON\&#x27;T NEED NO STINKIN BADGERS&#x27;</span>]</span><br><span class="line">      ]</span><br><span class="line"></span><br><span class="line">  it <span class="string">&#x27;won\&#x27;t open the pod bay doors&#x27;</span>, <span class="function">-&gt;</span></span><br><span class="line">    @room.user.say(<span class="string">&#x27;bob&#x27;</span>, <span class="string">&#x27;@hubot open the pod bay doors&#x27;</span>).<span class="keyword">then</span> =&gt;</span><br><span class="line">      expect(@room.messages).to.eql [</span><br><span class="line">        [<span class="string">&#x27;bob&#x27;</span>, <span class="string">&#x27;@hubot open the pod bay doors&#x27;</span>]</span><br><span class="line">        [<span class="string">&#x27;hubot&#x27;</span>, <span class="string">&#x27;@bob I\&#x27;m afraid I can\&#x27;t let you do that.&#x27;</span>]</span><br><span class="line">      ]</span><br><span class="line"></span><br><span class="line">  it <span class="string">&#x27;will open the dutch doors&#x27;</span>, <span class="function">-&gt;</span></span><br><span class="line">    @room.user.say(<span class="string">&#x27;bob&#x27;</span>, <span class="string">&#x27;@hubot open the dutch doors&#x27;</span>).<span class="keyword">then</span> =&gt;</span><br><span class="line">      expect(@room.messages).to.eql [</span><br><span class="line">        [<span class="string">&#x27;bob&#x27;</span>, <span class="string">&#x27;@hubot open the dutch doors&#x27;</span>]</span><br><span class="line">        [<span class="string">&#x27;hubot&#x27;</span>, <span class="string">&#x27;@bob Opening dutch doors&#x27;</span>]</span><br><span class="line">      ]</span><br></pre></td></tr></table></figure><p><strong>输出示例</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">% mocha --compilers &quot;coffee:coffee-script&#x2F;register&quot; test&#x2F;*.coffee</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  example script</span><br><span class="line">    ✓ doesn&#39;t need badgers</span><br><span class="line">    ✓ won&#39;t open the pod bay doors</span><br><span class="line">    ✓ will open the dutch doors</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  3 passing (212ms)</span><br></pre></td></tr></table></figure></div><footer class="post-footer"><div class="followme"><span>欢迎关注我的其它发布渠道</span><div class="social-list"><div class="social-item"><a target="_blank" class="social-link" href="/atom.xml"><span class="icon"><i class="fa fa-rss"></i></span> <span class="label">RSS</span></a></div></div></div><div class="post-tags"><a href="/tags/hubot/" rel="tag"># hubot</a> <a href="/tags/chatops/" rel="tag"># chatops</a></div><div class="post-nav"><div class="post-nav-item"><a href="/leetcode-142/" rel="prev" title="环形链表"><i class="fa fa-chevron-left"></i> 环形链表</a></div><div class="post-nav-item"></div></div></footer></article></div><div class="comments gitalk-container"></div></div></main><footer class="footer"><div class="footer-inner"><div class="beian"><a href="https://beian.miit.gov.cn/" rel="noopener" target="_blank">渝ICP备17015144号</a></div><div class="copyright">&copy; 2018 – <span itemprop="copyrightYear">2021</span><span class="with-love"><i class="fa fa-heart"></i></span> <span class="author" itemprop="copyrightHolder">杨欣雨</span></div></div></footer><script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script><script src="https://cdn.jsdelivr.net/npm/@next-theme/pjax@0.5.0/pjax.min.js" integrity="sha256-3NkoLDrmHLTYj7csHIZSr0MHAFTXth7Ua/DDt4MRUAg=" crossorigin="anonymous"></script><script src="https://cdn.jsdelivr.net/npm/lozad@1.16.0/dist/lozad.min.js" integrity="sha256-mOFREFhqmHeQbXpK2lp4nA3qooVgACfh88fpJftLBbc=" crossorigin="anonymous"></script><script src="https://cdn.jsdelivr.net/npm/pangu@4.0.7/dist/browser/pangu.min.js" integrity="sha256-j+yj56cdEY2CwkVtGyz18fNybFGpMGJ8JxG3GSyO2+I=" crossorigin="anonymous"></script><script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script><script src="/js/pjax.js"></script><script src="/js/third-party/search/local-search.js"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1.7.2/dist/gitalk.css" integrity="sha256-AJnUHL7dBv6PGaeyPQJcgQPDjt/Hn/PvYZde1iqfp8U=" crossorigin="anonymous"><script class="next-config" data-name="gitalk" type="application/json">{"enable":true,"github_id":"yangxyo","repo":"gitalk","client_id":"d132f60a332d75ac74e8","client_secret":"e1b396f1311291af51db16ed51308c275bc383e7","admin_user":"yangxyo","distraction_free_mode":true,"proxy":"https://cors-anywhere.azm.workers.dev/https://github.com/login/oauth/access_token","language":null,"js":{"url":"https://cdn.jsdelivr.net/npm/gitalk@1.7.2/dist/gitalk.min.js","integrity":"sha256-Pmj85ojLaPOWwRtlMJwmezB/Qg8BzvJp5eTzvXaYAfA="},"path_md5":"7e6e13a0b02d5bc3d23b7bcaa559faa3"}</script><script src="/js/third-party/comments/gitalk.js"></script></body></html>