<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>阿里云 ECS 使用</title>
    <url>/ECS/</url>
    <content><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p><a href="https://www.alibabacloud.com/help/zh/doc-detail/25367.htm?spm=a2c63.p38356.b99.2.615e1bbcsZH9Ry">阿里云官方文档</a></p>
<span id="more"></span>

<h2 id="远程连接服务器常用的几种方式"><a href="#远程连接服务器常用的几种方式" class="headerlink" title="远程连接服务器常用的几种方式"></a>远程连接服务器常用的几种方式</h2><p>SSH —— 远程<br>SFTF —— 文件传输，22端口</p>
<h2 id="安全组"><a href="#安全组" class="headerlink" title="安全组"></a>安全组</h2><h2 id="设置公网入方向-——-即允许具有指定-IP-的主机访问服务器的哪个端口"><a href="#设置公网入方向-——-即允许具有指定-IP-的主机访问服务器的哪个端口" class="headerlink" title="设置公网入方向 —— 即允许具有指定 IP 的主机访问服务器的哪个端口"></a>设置公网入方向 —— 即允许具有指定 IP 的主机访问服务器的哪个端口</h2><ol>
<li>设置端口范围 22/22 协议类型自定义TCP 授权对象公网ip，22端口常用于ssh连接。</li>
<li>设置端口范围 80/80 协议类型自定义TCP 授权对象0.0.0.0/0。<br>允许所有人通过 http 访问你的服务器。<br>80 端口常用于 http 协议访问 web 网站。相对应的 443 端口用于 https 协议访问 web 网站。3306 端口常用于数据库远程连接。出于安全考虑：如果向所有人打开 22 端口和 3306 端口，应当确保密码的复杂程度，以防强行爆破。对于新手建议将 22 端口和 3306 端口设置为仅允许指定IP访问。</li>
</ol>
<h2 id="设置公网出方向-——-服务器出口的限制"><a href="#设置公网出方向-——-服务器出口的限制" class="headerlink" title="设置公网出方向 —— 服务器出口的限制"></a>设置公网出方向 —— 服务器出口的限制</h2><p>没有特殊需求不需要设置。</p>
]]></content>
      <categories>
        <category>信息技术</category>
      </categories>
      <tags>
        <tag>云服务</tag>
      </tags>
  </entry>
  <entry>
    <title>用 acme.sh 从 Let&#39;s Encrypt 免费获取持续的 SSL 证书支持</title>
    <url>/acme-sh/</url>
    <content><![CDATA[<h2 id="acme-sh-简介"><a href="#acme-sh-简介" class="headerlink" title="acme.sh 简介"></a>acme.sh 简介</h2><p>acme.sh 简化了 Let’s Encrypt 官方的证书签发过程。<br>目前主要有如下两类 Let’s Encrypt 证书的签发方式：</p>
<ul>
<li>http 认证方式</li>
<li>dns 方式<span id="more"></span>

</li>
</ul>
<p>http 需要 80 端口的贯通。<br>dns 方式不适用于所有的解析商，对域名的管理需要较高的权限。</p>
<p><a href="https://github.com/Neilpang/acme.sh/wiki/%E8%AF%B4%E6%98%8E">github 安装说明</a></p>
<h2 id="acme-sh-实际问题解决"><a href="#acme-sh-实际问题解决" class="headerlink" title="acme.sh 实际问题解决"></a>acme.sh 实际问题解决</h2><p>案例介绍：<br>一台 gentoo 服务器中仅对外网开放 80 和 443 端口，而当前的 80 端口使用 haproxy 代理。<br>最终解决方案：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">acme.sh --issue -d XXXX --standalone --pre-hook &quot;killall haproxy&quot; --post-hook &quot;&#x2F;usr&#x2F;local&#x2F;haproxy&#x2F;start.sh&quot; --force</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>信息技术</category>
      </categories>
      <tags>
        <tag>ssl</tag>
        <tag>acme.sh</tag>
        <tag>letsencrypt</tag>
      </tags>
  </entry>
  <entry>
    <title>目标和关键成果法 (Objectives and Key Results)</title>
    <url>/OKRs/</url>
    <content><![CDATA[<blockquote>
<p>The Objective is the direction.<br>The key results have to be measured.<br>Yes.No.Simple</p>
</blockquote>
<h1 id="Why"><a href="#Why" class="headerlink" title="Why"></a>Why</h1><p>Being took to the wrong objectives is unacceptable.<br>被带向错误的目标是让人无法接受的。</p>
<span id="more"></span>

<p>Truly transformational teams combine their ambitions to their passion and to their purpose，and they develop a clear and compelling sense of why.<br>真正变革型的团队都会将自己的雄心、热情和目标结合到一起，他们很清楚为何要做，且理由令人信服。</p>
<h1 id="Objective"><a href="#Objective" class="headerlink" title="Objective"></a>Objective</h1><p>Significant (重要)<br>Concrete （具体）<br>Action-oriented （以行动为导向）<br>Inspirational （激励人心）</p>
<p>If the heart doesn’t find a perfect rhyme with the head, then your passion means nothing.<br>如果内心找不到与大脑和谐的韵律，你的热情就毫无用处。</p>
<h1 id="Good-key-results"><a href="#Good-key-results" class="headerlink" title="Good key results"></a>Good key results</h1><p>Specific &amp; Time-bound（明确、有时间限制）<br>Aggressive Yet Realistic（激进、现实）<br>Measurable &amp; Verifiable (可衡量、可评估)</p>
<h1 id="Why-1"><a href="#Why-1" class="headerlink" title="Why"></a>Why</h1><p>OKRs as transparent vessels, that are made from the whats and hows of our ambitions. What really matters is the why that we pour into those vessels. Thats’s why we do our work.<br> OKRS 可以看做是一个透明的容器，它由野心勃勃的“做什么”和“怎么做”构成。 真正的关键在于放进容器中的“为什么” 那是我们工作的原因。</p>
<h1 id="Write-down-your"><a href="#Write-down-your" class="headerlink" title="Write down your"></a>Write down your</h1><p>Values (the right metrics)<br>Objectives<br>Key results</p>
]]></content>
      <categories>
        <category>方法</category>
      </categories>
      <tags>
        <tag>方法</tag>
      </tags>
  </entry>
  <entry>
    <title>《厉害了我的国》(2018)讲述纲要</title>
    <url>/amazing-china/</url>
    <content><![CDATA[<h1 id="《厉害了我的国》-2018-讲述纲要"><a href="#《厉害了我的国》-2018-讲述纲要" class="headerlink" title="《厉害了我的国》(2018)讲述纲要"></a>《厉害了我的国》(2018)讲述纲要</h1><blockquote>
<p>导演: 卫铁<br>类型: 纪录片<br>制片国家/地区: 中国大陆<br>语言: 汉语普通话<br>上映日期: 2018-03-02(中国大陆)<br>片长: 90分钟<br>又名: Amazing China</p>
</blockquote>
<span id="more"></span>

<blockquote>
<p>《厉害了，我的国》，以《辉煌中国》为基础素材制作的纪录电影。《辉煌中国》8个摄制组历时3个月，走遍全国31个省区市，拍摄了近3200个小时的高清纪实素材、300多个小时的航拍素材，采访了108位人物，记录下众多珍贵的历史瞬间。内容采用“内容众筹”的创新方式，搭建创作平台，面向全国征集五年来百姓眼中的成就故事、百姓身边的巨大变化，由百姓自己讲述精彩“中国故事”，众筹案例线索、照片、短视频等逾万条</p>
</blockquote>
<h2 id="基础设施建设，中国制造，创新引擎"><a href="#基础设施建设，中国制造，创新引擎" class="headerlink" title="基础设施建设，中国制造，创新引擎"></a>基础设施建设，中国制造，创新引擎</h2><h3 id="大国工程，交通运输业"><a href="#大国工程，交通运输业" class="headerlink" title="大国工程，交通运输业"></a>大国工程，交通运输业</h3><p>中国桥–港珠澳大桥<br>中国车–高铁<br>中国港口–智能码头<br>中国船</p>
<h3 id="中国资源调配"><a href="#中国资源调配" class="headerlink" title="中国资源调配"></a>中国资源调配</h3><p>南水北调<br>西气东输二线<br>世界级特高压工程<br>信息资源–网络强国</p>
<h2 id="自主创新"><a href="#自主创新" class="headerlink" title="自主创新"></a>自主创新</h2><h3 id="2017-05-05-大飞机梦"><a href="#2017-05-05-大飞机梦" class="headerlink" title="2017.05.05 大飞机梦"></a>2017.05.05 大飞机梦</h3><p>自主研发大飞机航电系统集成</p>
<h3 id="自主制造海上钻井平台"><a href="#自主制造海上钻井平台" class="headerlink" title="自主制造海上钻井平台"></a>自主制造海上钻井平台</h3><h3 id="深海探测"><a href="#深海探测" class="headerlink" title="深海探测"></a>深海探测</h3><p>蛟龙号<br>中国深潜器</p>
<h3 id="太空探测"><a href="#太空探测" class="headerlink" title="太空探测"></a>太空探测</h3><p>FAST射电望远镜（中国天眼）<br>嫦娥三号<br>量子卫星“墨子号”–量子通信<br>天宫二号–空间实验室</p>
<h3 id="创新型青年人才"><a href="#创新型青年人才" class="headerlink" title="创新型青年人才"></a>创新型青年人才</h3><p>国家创新活力<br>科技发展希望</p>
<h2 id="我国社会主要矛盾已经转化为人民日益增长的美好生活需要和不平衡不充分的发展之间的矛盾"><a href="#我国社会主要矛盾已经转化为人民日益增长的美好生活需要和不平衡不充分的发展之间的矛盾" class="headerlink" title="我国社会主要矛盾已经转化为人民日益增长的美好生活需要和不平衡不充分的发展之间的矛盾"></a>我国社会主要矛盾已经转化为人民日益增长的美好生活需要和不平衡不充分的发展之间的矛盾</h2><h3 id="缩减贫富差异"><a href="#缩减贫富差异" class="headerlink" title="缩减贫富差异"></a>缩减贫富差异</h3><p>精准扶贫<br>号召企业家向贫困地域发展<br>城乡一体化</p>
<h3 id="生态平衡"><a href="#生态平衡" class="headerlink" title="生态平衡"></a>生态平衡</h3><p>新能源 光伏发电 风电 核电站<br>污染治理，退耕还林还草工程</p>
<h3 id="教育平衡"><a href="#教育平衡" class="headerlink" title="教育平衡"></a>教育平衡</h3><p>乡村教师队伍支持计划<br>免费午餐</p>
<h3 id="文化建设"><a href="#文化建设" class="headerlink" title="文化建设"></a>文化建设</h3><p>传统文化与时代精神<br>中华民族价值追求</p>
<h3 id="医疗"><a href="#医疗" class="headerlink" title="医疗"></a>医疗</h3><p>家庭医生签约服务制度全覆盖</p>
<h3 id="养老"><a href="#养老" class="headerlink" title="养老"></a>养老</h3><h3 id="公共安全–保障小康的隐形卫视"><a href="#公共安全–保障小康的隐形卫视" class="headerlink" title="公共安全–保障小康的隐形卫视"></a>公共安全–保障小康的隐形卫视</h3><h3 id="国家安全-军事"><a href="#国家安全-军事" class="headerlink" title="国家安全-军事"></a>国家安全-军事</h3><h3 id="对外开放"><a href="#对外开放" class="headerlink" title="对外开放"></a>对外开放</h3><p>40年改革开放成就今日中国位于世界前列的国际地位<br>开着门，世界能够进入中国，中国也才能走向世界<br>一带一路<br>中欧经济联系紧密<br>桃李不言，下自成蹊  经济大融合 发展大联动 成功大共享<br>带动非洲繁荣<br>中国对外开放的追求–既要让自己过得好也要让别人过的好<br>建立人类命运共同体</p>
]]></content>
      <categories>
        <category>人文修养</category>
      </categories>
      <tags>
        <tag>中国</tag>
      </tags>
  </entry>
  <entry>
    <title>《一本小小的红色写作书》读书笔记</title>
    <url>/book-hsxzs/</url>
    <content><![CDATA[<p><img data-src="http://images.xyang.xin/2019-05%2F1558180143.png?x-oss-process=style/title_140" alt="1558180143.png-w140"></p>
<span id="more"></span>
<p><img data-src="http://images.xyang.xin/2019-07%2F%E4%B8%80%E6%9C%AC%E5%B0%8F%E5%B0%8F%E7%9A%84%E7%BA%A2%E8%89%B2%E5%86%99%E4%BD%9C%E4%B9%A6.png" alt="一本小小的红色写作书.png"></p>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>图中对《一本小小的红色写作书》的脉络要点进行总结，用于写作中的参考。（图谱内容较多，建议保存后浏览）</p>
<h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><ol>
<li><p>引导句<br> 在一篇个人随笔中，这句话可以作为引导语，放在文章的最开头：<br>我将通过详述个人和职业生涯的三个特殊的转折点，来呈现我是个什么样的人：凭借曲棍球奖学金上大学时期、与维和部队共同度过的一年、入职伦敦一家商贸企业期间。</p>
<p> 在商务报告中，以下句子可以作为引导语，放在报告的最开头：<br>基于最近调查所得信息，本报告概述了我们公司面临的三大问题：员工流失、店铺盗窃和低水平客户服务。</p>
</li>
<li><p>类比<br> 生产部门与销售部门、营销部门之间的关系，使用“枪和子弹”类比：“生产部门生产子弹，营销部门瞄枪，销售部门扣动扳机。”</p>
</li>
<li><p>暗喻<br> 他有钢铁般的勇气。</p>
</li>
<li><p>正式<br> 无缩略形式和人称代词。</p>
</li>
</ol>
<h2 id="摘录"><a href="#摘录" class="headerlink" title="摘录"></a>摘录</h2><h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><p>当你说一件事情的时候，确保你说清楚了。如此，你言说的机会才合理。</p>
<h3 id="风格"><a href="#风格" class="headerlink" title="风格"></a>风格</h3><p>简短地展现以便他们阅读，清楚地展现以便他们欣赏，如画般地展现以便他们记忆，最重要的是，准确地展现以便他们被它的光明所指引。</p>
<h3 id="可读性"><a href="#可读性" class="headerlink" title="可读性"></a>可读性</h3><p>第一稿的愉悦源于欺骗自己它离真正的作品已经相当接近了；其后稿的愉悦部分源于意识到自己没有被第一稿蒙骗。</p>
]]></content>
      <categories>
        <category>人文修养</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
        <tag>写作</tag>
      </tags>
  </entry>
  <entry>
    <title>《如何阅读一本书》读书笔记</title>
    <url>/book-rhydybs/</url>
    <content><![CDATA[<p><img data-src="http://images.xyang.xin/2019-09%2Frhydybs.jpeg?x-oss-process=style/title_140" alt="rhydybs.jpeg-w140"></p>
<span id="more"></span>
<p><img data-src="http://images.xyang.xin/2019-09%2F%E3%80%8A%E5%A6%82%E4%BD%95%E9%98%85%E8%AF%BB%E4%B8%80%E6%9C%AC%E4%B9%A6%E3%80%8B.png" alt="《如何阅读一本书》.png"></p>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>图中对《如何阅读一本书》的脉络要点进行总结，用于阅读时的参考。（图谱内容较多，建议保存后浏览）。</p>
<p>书中提出了四种阅读层次，层次逐级递增，较高层次的阅读包含较低层次的阅读。基础阅读是对字词句意思的理解，是阅读的基础。使用检视阅读来理清书的脉络，来甄别一本书是否值得读，是否适合现在读。使用分析阅读来细细品味一本好书。主题阅读适用于学术研究或对自己感兴趣的问题的探究性学习。</p>
<!-- more -->
<h2 id="摘录"><a href="#摘录" class="headerlink" title="摘录"></a>摘录</h2><p>读者是要“发现”书中隐藏着的骨架。而作者则是以制造骨架为开始，但却想办法把骨架“隐藏”起来。他的目的是，用艺术的手法将骨架隐藏起来，或是说，在骨架上添加血肉。</p>
<p>所谓文章的清楚明白，就是跟纲要的区隔是否清楚有关，所谓文章的前后一贯，就是能把不同的重点条理有序地排列出来。</p>
<p>这个捷径是要靠你的检视阅读技巧来建立的。你收集好书目之后，要做的第一件事是检视书单上所有的书。在做检视阅读之前，绝不要用分析阅读来阅读。检视阅读不会让你明白有关主题的所有错综复杂的内容，或是作者所有的洞察力，但却具有两种基本的功能。第一，它会让你对自己想要研究的主题有个清晰的概念，这样接下来你针对某几本书做分析阅读时，会大有助益。第二，它会简化你的书目到一个合理的程度。</p>
<p>能够熟练检视阅读的读者，不但能在心中将书籍分类，而且能对内容有一个粗浅的了解。他也会用非常短的时间就发现，这本书谈的内容对他研究的主题到底重不重要————这可能要等到读下本书的时候才能发现。但是有两件事至少他已经知道其中之一。那就是他不是发现这本书必须回头再读一次，以获得启发，便是知道不论这本书多有趣又多丰富，却毫无启发性，因此不值得重新再读。</p>
]]></content>
      <categories>
        <category>人文修养</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
        <tag>阅读</tag>
      </tags>
  </entry>
  <entry>
    <title>position ——【每天一点 CSS】</title>
    <url>/css-everday-1/</url>
    <content><![CDATA[<p>今天来聊聊关于CSS的属性<code>position</code>，它的取值如下：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">position: static;   // 初始值</span><br><span class="line">position: relative; // 相对定位</span><br><span class="line">position: absolute; // 绝对定位</span><br><span class="line">position: fixed;    // 固定定位</span><br></pre></td></tr></table></figure>
<p>定位不是继承的。</p>
<span id="more"></span>

<h2 id="static"><a href="#static" class="headerlink" title="static"></a>static</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p><code>static</code>是元素定位的默认值，让元素出现在常规文档流中。</p>
<h2 id="relative"><a href="#relative" class="headerlink" title="relative"></a>relative</h2><h3 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h3><p>每个元素在页面的文档流中都有一个自然位置，相对于这个原始位置进行移动就称为<em>相对定位</em>。而其周围的元素完全不受此影响。相对定位会在原先的位置留下空白。</p>
<h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><ol>
<li>作为绝对定位的参照。</li>
<li>使用<code>top</code>、<code>right</code>、<code>bottom</code>和<code>left</code>调整元素的位置，元素在视觉上看起来就像被推到一个不同的位置。</li>
</ol>
<h2 id="absolute"><a href="#absolute" class="headerlink" title="absolute"></a>absolute</h2><h3 id="概念-2"><a href="#概念-2" class="headerlink" title="概念"></a>概念</h3><p>元素会被移出文档流。就不像<code>static</code>或者<code>relative</code>这样占用空间。</p>
<p>没有额外设置的情况下，<em>绝对定位</em>是相对于 body 进行定位的。可以对希望称为<em>绝对定位</em>参照体的祖先元素添加 <code>position: relative;</code>。</p>
<p><em>绝对定位</em>不会在原先的位置留下空白。</p>
<h2 id="fixed"><a href="#fixed" class="headerlink" title="fixed"></a>fixed</h2><h3 id="概念-3"><a href="#概念-3" class="headerlink" title="概念"></a>概念</h3><p><code>fixed</code> 有点类似于<code>absolute</code>，会被移出文档流。不一样的是<code>fixed</code>始终相对浏览器窗口定位。</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul>
<li>《HTML与CSS3基础教程（第8版）》</li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/position">position - CSS（层叠样式表） | MDN</a></li>
<li><a href="https://zellwk.com/blog/css-positions/">Understanding and Using CSS Positions | Zell Liew</a></li>
</ul>
]]></content>
      <categories>
        <category>信息技术</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>类型的动态绑定和静态绑定</title>
    <url>/dynamic&amp;static-type-binding/</url>
    <content><![CDATA[<p>JavaScript 是动态绑定的语言，而 TypeScript 包装其成为静态绑定的语言。而什么是动态绑定，什么是静态绑定，它们的优劣又是什么呢？TypeScript 又为什么要“多此一举”？</p>
<span id="more"></span>

<h2 id="绑定"><a href="#绑定" class="headerlink" title="绑定"></a>绑定</h2><p>绑定是一种关联（associate），也可以是一种分配（assign）。类型绑定是将声明的变量关联到特定类型的过程。</p>
<p>动态绑定就是，在程序运行的时候，将变量绑定到类型。<br>静态绑定，在编译时，编译器将变量绑定到类型。</p>
<h2 id="编译与解释"><a href="#编译与解释" class="headerlink" title="编译与解释"></a>编译与解释</h2><p>像 JavaScript、PHP、Python、Ruby 这类解释型语言他们没有编译器。在运行之前发现变量类型是不可能的。可以参考下图解释器的工作方式。<br><img data-src="http://images.xyang.xin/2020%2F08%2F14%2Fcompiler%26interpreter.png?x-oss-process=style/title_800" alt="compiler&amp;interpreter.png"></p>
<p>而 C、C++、Go、Rust 这类编译型语言，是在编译的时候就将变量绑定到类型。静态绑定又有两种方式：下面两句 go 语言代码，都是创建了一个初始值为 10 的<code>int</code>类型的变量。前者是显式声明，程序直接写出了变量的类型为<code>int</code>；后者是隐式声明，根据值 10 推导变量的类型为<code>int</code>。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x <span class="keyword">int</span> = <span class="number">10</span></span><br><span class="line"><span class="comment">// 或</span></span><br><span class="line">x := <span class="number">10</span></span><br></pre></td></tr></table></figure>

<h2 id="Java-与-TypeScript"><a href="#Java-与-TypeScript" class="headerlink" title="Java 与 TypeScript"></a>Java 与 TypeScript</h2><p>Java 首先编译为<code>.class</code>字节码文件，而后字节码文件通过虚拟机解释执行。Java 是有编译器的，所以能够实现动态绑定，事实也是如此。</p>
<p>而 TypeScript 呢，看上去它的设计还真像 Java 呢，先通过 TSC 将 ts 代码编译为 js 代码，js 代码再通过 node、浏览器等运行环境解释执行。与前面的 go 语言代码类似。</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> today:<span class="built_in">string</span> = <span class="string">&quot;Sun&quot;</span></span><br><span class="line"><span class="keyword">let</span> tomorrow = <span class="string">&quot;Mon&quot;</span></span><br></pre></td></tr></table></figure>

<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul>
<li><a href="https://stackoverflow.com/questions/9837972/static-type-binding-vs-dynamic-type-binding">Static Type Binding Vs Dynamic Type Binding - Stack Overflow</a></li>
</ul>
]]></content>
      <categories>
        <category>信息技术</category>
      </categories>
      <tags>
        <tag>TypeScript</tag>
      </tags>
  </entry>
  <entry>
    <title>Symbol ———【一天一个 es6 语法】</title>
    <url>/es6-everday-1/</url>
    <content><![CDATA[<h2 id="什么是-Symbol"><a href="#什么是-Symbol" class="headerlink" title="什么是 Symbol?"></a>什么是 Symbol?</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> 😻 = 😺 × 😍;  <span class="comment">// SyntaxError</span></span><br></pre></td></tr></table></figure>
<p>（爆笑）这当然不是 Symbol。</p>
<ul>
<li>Undefined</li>
<li>Null</li>
<li>Boolean</li>
<li>Number</li>
<li>String</li>
<li>Object</li>
<li>Symbol (ES2015 新增)</li>
</ul>
<p>Symbol 不是字符串，不是对象，是第七种原始数据类型。每个从<code>Symbol()</code>返回的 symbol 类型的值都是唯一的。<strong>一个 symbol 类型的值能作为对象属性的标识符；这是该数据类型仅有的目的</strong>。</p>
<span id="more"></span>
<h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><p>通过以下代码就创建一个 Symbol 类型的值。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Symbol([description])</span></span><br><span class="line"><span class="keyword">let</span> s = <span class="built_in">Symbol</span>(<span class="string">&quot;我就是我&quot;</span>);</span><br><span class="line"><span class="keyword">typeof</span> s;</span><br><span class="line"><span class="comment">// &quot;symbol&quot;</span></span><br></pre></td></tr></table></figure>
<p>Symbol 中的参数对程序无实际意义，仅供调试助记。不支持语法： <code>new Symbol()</code></p>
<p>不能自动转换为字符串：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="built_in">Symbol</span>();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot; your symbol is&quot;</span> + s);</span><br><span class="line"><span class="comment">// TypeError: can&#x27;t convert symbol to string</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`your symbol is <span class="subst">$&#123;s&#125;</span>`</span>)</span><br><span class="line"><span class="comment">// TypeError: can&#x27;t conver symbol to string</span></span><br></pre></td></tr></table></figure>
<h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><h3 id="对象中的私有属性"><a href="#对象中的私有属性" class="headerlink" title="对象中的私有属性"></a>对象中的私有属性</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> cat = <span class="built_in">Symbol</span>(<span class="string">&quot;cat&quot;</span>)</span><br><span class="line"><span class="keyword">let</span> dog = <span class="built_in">Symbol</span>(<span class="string">&quot;dog&quot;</span>)</span><br><span class="line"><span class="keyword">let</span> pig = <span class="built_in">Symbol</span>(<span class="string">&quot;pig&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj = &#123; <span class="attr">property</span>: <span class="string">&quot;这是一个动物乐园&quot;</span>, [cat]: <span class="string">&quot;金点渐层猫&quot;</span>, [dog]: <span class="string">&quot;二哈&quot;</span>, [pig]: <span class="string">&quot;藏香猪&quot;</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> prop <span class="keyword">in</span> obj) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(prop + <span class="string">&quot;: &quot;</span> + obj[prop]</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印出 property: &quot;这是一个动物乐园&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertySymbols(obj))</span><br><span class="line"><span class="comment">// 打印出 [ Symbol(cat), Symbol(dog), Symbol(pig) ]</span></span><br></pre></td></tr></table></figure>
<p>基于 <code>symbol</code> 的私有属性对 <code>Object.entries</code>、 <code>Object.keys</code>、 <code>for...in</code> 等其它迭代器是不可见的。</p>
<p><code>symbol</code> 属性对 <code>JSON.stringify</code> 方法也是不可见的额。</p>
<h3 id="类中的私有属性"><a href="#类中的私有属性" class="headerlink" title="类中的私有属性"></a>类中的私有属性</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> _items = <span class="built_in">Symbol</span>(<span class="string">&#x27;stackItems&#x27;</span>);</span><br><span class="line"></span><br><span class="line">interface Stack &#123;</span><br><span class="line">  [_items]: any[];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stack</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="built_in">this</span>[_items] = [];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 添加一个新元素到栈顶</span></span><br><span class="line">  push(element:any)&#123;</span><br><span class="line">    <span class="built_in">this</span>[_items].push(element);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 移除栈顶的元素，同时返回</span></span><br><span class="line">  pop() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>[_items].pop();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 返回栈顶的元素</span></span><br><span class="line">  peek() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>[_items][<span class="built_in">this</span>[_items].length - <span class="number">1</span>];</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">// 没有任何元素true，否则false</span></span><br><span class="line">  isEmpty() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>[_items].length === <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 移除栈里的所有元素</span></span><br><span class="line">  clear() &#123;</span><br><span class="line">    <span class="built_in">this</span>[_items] = [];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 返回栈里的元素个数</span></span><br><span class="line">  size() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>[_items].length;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  print() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.toString());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  toString() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>[_items].toString();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getSymbol</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">const</span> stack = <span class="keyword">new</span> Stack();</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Object</span>.getOwnPropertySymbols(stack);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">testSymbol</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> stack = <span class="keyword">new</span> Stack();</span><br><span class="line">  <span class="keyword">return</span> stack[_items];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(testSymbol());</span><br><span class="line"><span class="comment">// []</span></span><br><span class="line"><span class="built_in">console</span>.log(getSymbol()[<span class="number">0</span>]);</span><br><span class="line"><span class="comment">// Symbol(stackItems)</span></span><br></pre></td></tr></table></figure>

<p>注意区别 <code>stack[_items]</code> 和<code>stack[&#39;_items&#39;]</code></p>
<p>前者是访问属性名为 Symbol 的特殊方式。<br>后者是访问一般属性的方法与 <code>stack._items </code>相同。</p>
<p>我猜测正因为这种特殊的访问方式使其无法通过<code>for...in</code>，<code>for...of</code>或 <code>Object.keys()</code> 等方法枚举。</p>
<p>通过 <code>testSymbol()</code> 方法在我看来，其并不能达到实现私有变量的目的，仅仅使属性名或方法名不与别人提供的对象产生冲突。是一种保证每个属性名独一无二的方式。</p>
<hr>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul>
<li><a href="https://hacks.mozilla.org/2015/06/es6-in-depth-symbols/">ES6 In Depth: Symbols - Mozilla Hacks - the Web developer blog</a></li>
<li><a href="https://es6.ruanyifeng.com/#docs/symbol">Symbol - ECMAScript 6入门</a></li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Symbol">Symbol - JavaScript | MDN</a></li>
</ul>
]]></content>
      <categories>
        <category>信息技术</category>
      </categories>
      <tags>
        <tag>【一天一个 es6 语法】</tag>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>箭头函数( =&gt; ） ———【一天一个 es6 语法】</title>
    <url>/es6-everday-2/</url>
    <content><![CDATA[<h2 id="Function"><a href="#Function" class="headerlink" title="Function"></a>Function</h2><p>每个函数都是 <code>Function</code> 类型的实例，由于函数是对象，因此函数名实际上也是一个指向函数对象的指针，函数通常是使用<strong>函数声明语法</strong>定义的：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span> (<span class="params">num1, num2</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<p>这与下面使用<strong>函数表达式</strong>定义函数的方式几乎相差无几：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> sum = <span class="function"><span class="keyword">function</span>(<span class="params">num1, num2</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>最后一种定义函数的方式是使用<code>Function</code>构造函数，最后一个参数始终都被看成是函数体，而前面的参数则枚举出了新函数的参数：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Function</span>(<span class="string">&quot;num1&quot;</span>, <span class="string">&quot;num2&quot;</span>, <span class="string">&quot;return num1 + num2&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>其中<strong>函数声明语法</strong>具有函数声明提升（function declaration hoisting）,解析器会率先读取函数声明，并使其在执行任何代码之前可用。其余的时候<strong>函数声明</strong>与<strong>函数表达式</strong>的语法其实是等价的。</p>
<p>箭头函数针对的是<strong>函数表达式</strong>定义的函数。</p>
<h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> funcName = <span class="function"><span class="keyword">function</span>(<span class="params">para</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;xxx&quot;</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">var</span> funcName = <span class="function"><span class="params">para</span> =&gt;</span> para + <span class="string">&quot;xxx&quot;</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> funcName = <span class="function"><span class="keyword">function</span>(<span class="params">para1, para2</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(para1 + <span class="string">&quot; and &quot;</span> + para2);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//等同于</span></span><br><span class="line"><span class="keyword">var</span> funcName = <span class="function">(<span class="params">para1, para2</span>) =&gt;</span> <span class="built_in">console</span>.log(para1 + <span class="string">&quot; and &quot;</span> + para2);</span><br></pre></td></tr></table></figure>

<p>从形式上来看也就是把<strong>函数表达式</strong>定义的函数，function 去掉，在参数括号外面加 =&gt; 。没有参数用()占位，只有一个参数时可以省略括号，后面的代码块部分多于一条语句就要用大括号括起来，而只有一条语句可以省略大括号，如果是 return 语句，还可以省略 return。</p>
<p>当然仅仅为了好看，箭头函数存在的意义并不大。</p>
<h2 id="使用注意点"><a href="#使用注意点" class="headerlink" title="使用注意点"></a>使用注意点</h2><p>（1）函数体内的 this 对象，就是定义时所在的对象，而不是使用时所在的对象。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> objName = &#123;</span><br><span class="line">    food: [<span class="string">&quot;chicken&quot;</span>, <span class="string">&quot;hamburger&quot;</span>, <span class="string">&quot;French Fries&quot;</span>],</span><br><span class="line">    print: <span class="function"><span class="keyword">function</span>(<span class="params">delay=<span class="number">1000</span></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="built_in">this</span>.resorts.join(<span class="string">&quot;,&quot;</span>))</span><br><span class="line">        &#125;, delay)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">objName.print() <span class="comment">// Cannot read property &#x27;join&#x27; of undefined</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> objName = &#123;</span><br><span class="line">    food: [<span class="string">&quot;chicken&quot;</span>, <span class="string">&quot;hamburger&quot;</span>, <span class="string">&quot;French Fries&quot;</span>],</span><br><span class="line">    print: <span class="function"><span class="keyword">function</span>(<span class="params">delay=<span class="number">1000</span></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="built_in">this</span>.resorts.join(<span class="string">&quot;,&quot;</span>))</span><br><span class="line">        &#125;, delay)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">objName.print() <span class="comment">//chicken, hamburger, French Fries</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> objName = &#123;</span><br><span class="line">    food: [<span class="string">&quot;chicken&quot;</span>, <span class="string">&quot;hamburger&quot;</span>, <span class="string">&quot;French Fries&quot;</span>],</span><br><span class="line">    print: <span class="function">(<span class="params">delay=<span class="number">1000</span></span>)=&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="built_in">this</span>.resorts.join(<span class="string">&quot;,&quot;</span>))</span><br><span class="line">        &#125;, delay)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">objName.print() <span class="comment">//Cannot read property &#x27;join&#x27; of undefined</span></span><br></pre></td></tr></table></figure>
<p>第三段代码将 <code>print</code> 函数声明改为一个箭头函数的形式意味着其中关键字 <code>this</code> 指代的对象就是 <code>object</code>（浏览器中是 <code>window</code>）。<br><code>setTimeout()</code>方法设置一个定时器，该定时器在定时器到期后执行一个函数或指定的一段代码，上面的代码都是 1s 后执行 <code>console.log</code> 所在的函数。</p>
<p>（2）不可使用<code>arguments</code>对象，如果要用，可以用扩展运算符(<code>...</code>)将函数参数搜集到一个数组中。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>(<span class="params">...theArgs</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> theArgs;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>（3）箭头函数没有自己的 <code>this</code>。<br>不能用 <code>call()</code>、<code>apply()</code>、<code>bind()</code> 这些方法去改变 <code>this</code> 的指向。</p>
<hr>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul>
<li>《Javascript 高级程序设计（第3版）》</li>
<li><a href="https://es6.ruanyifeng.com/#docs/function">函数的扩展 - ECMAScript 6入门</a></li>
</ul>
]]></content>
      <categories>
        <category>信息技术</category>
      </categories>
      <tags>
        <tag>【一天一个 es6 语法】</tag>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>人生</title>
    <url>/flesh/</url>
    <content><![CDATA[<h2 id="他的话可信吗"><a href="#他的话可信吗" class="headerlink" title="他的话可信吗"></a>他的话可信吗</h2><blockquote>
<p>听人谈话的时候，我们需要了解这人是谁，他是处在何种角度，代表何种阶级谈话的。</p>
</blockquote>
<p>他的话是他的经验之谈，是他从权威的书籍中得知，论坛上看到，还是他仅仅只是为了让你相信而虚构或者是一个看似正确而往往值得商榷的。</p>
<span id="more"></span>

<h2 id="好话"><a href="#好话" class="headerlink" title="好话"></a>好话</h2><blockquote>
<p>听见好话一定要多长心眼，好话会让你做出的决策违背初心，待后知后觉，晚矣。</p>
</blockquote>
<p>投票软件多少是有漏洞的，从开发人员的角度利用漏洞刷票是很容易被发现，且破坏比赛的公平度的。很多亲人朋友呢很支持我，感觉一个投票闹得挺辛苦的。就不得不在群里向主办方反馈，不一会儿开发投票软件公司的老总进来了，也不说是解决问题。</p>
<p>主办方第一轮给出的结果，随便找个理由，说没有刷票行为。<br>网络投票看是否刷票，一般都是看着某一天投票数是否波动过大，尤其是最后一天，或者票数数量过多，咱们开始怀疑刷票。然而这都只是怀疑，技术部门要是不想解决也是没办法的。<br>然而当投票网站上有访问量和投票数那就不一样了，当投票数大于访问量？这是什么怪物？页面都没被访问，你又是怎么点击投票按钮的，这就是异常刷票了。</p>
<p>这种情况主办方如果不证明是系统漏洞，抑或是抓出一个有刷票行为的队伍来，那这个主办方麻烦就大了，网络舆情还是很管用的。</p>
<p>后面主办方不得不抓出了一个，五天投票，前面四天总共几十票，最后一天下午飙几万的队伍。据肉眼观察肯定是不止一个的。</p>
<p>但是同时那个老总私聊到我，简单的说“本科进决赛很优秀了，有时间聊一下”。再加上我本身对这软件公司是没有敌意的，因为系统安全性技术比较难，本身抱着的态度就是能找出刷票的队伍，解决问题就行了。</p>
<p>他这一句话导致的最终结果就是，简单的将刷票最厉害的队伍解决了，而放下了第一轮结果所公布的无赖行为和更多的不公平性的愤懑。</p>
<p>一句好话让我对公平性诉求，从解决，到最简单的解决。</p>
<h2 id="解决生活中的难题"><a href="#解决生活中的难题" class="headerlink" title="解决生活中的难题"></a>解决生活中的难题</h2><p>倘若有条件自己给自己安排一件难题，例如考研究生、公务员，不是生活强加给我们的，那便是为了多一种生活体验。抱着解决问题的心态去攻坚克难，坚持下去完整的度过有计划的每一天便是一种胜利。</p>
<h2 id="为什么不同"><a href="#为什么不同" class="headerlink" title="为什么不同"></a>为什么不同</h2><p>假若我们抱怨，抱怨自己没有出生在名门旺族，抱怨自己没有一个好看的脸蛋。然而人之所以是自己，正是源于这些后天难以更改的不同之处。</p>
]]></content>
      <categories>
        <category>人文修养</category>
      </categories>
      <tags>
        <tag>人生</tag>
      </tags>
  </entry>
  <entry>
    <title>解构赋值 ———【一天一个 es6 语法】</title>
    <url>/es6-everyday-3/</url>
    <content><![CDATA[<h2 id="何为解构赋值"><a href="#何为解构赋值" class="headerlink" title="何为解构赋值"></a>何为解构赋值</h2><p>解构赋值语法是一种 javascript 表达式。通过解构赋值，可以将属性/值从对象/数组中取出，复制给其他变量。</p>
<span id="more"></span>

<h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><h3 id="对象解构赋值"><a href="#对象解构赋值" class="headerlink" title="对象解构赋值"></a>对象解构赋值</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> regularPerson = &#123;</span><br><span class="line">    firstName: <span class="string">&quot;Bill&quot;</span>,</span><br><span class="line">    lastnNme: <span class="string">&quot;Wilson&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> lordify = <span class="function">(<span class="params">&#123;firstName&#125;</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;firstName&#125;</span> of Canterbury`</span>;</span><br><span class="line">&#125;</span><br><span class="line">lordify(regularPerson);     <span class="comment">// Bill of Canterbury</span></span><br></pre></td></tr></table></figure>
<h3 id="数组解构赋值"><a href="#数组解构赋值" class="headerlink" title="数组解构赋值"></a>数组解构赋值</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> [firstResort] = [<span class="string">&quot;Kirkwood&quot;</span>, <span class="string">&quot;Squaw&quot;</span>, <span class="string">&quot;Alpine&quot;</span>];</span><br><span class="line"><span class="built_in">console</span>.log(firstResort); <span class="comment">// kirkwood</span></span><br><span class="line"><span class="keyword">var</span> [,,thirdResort] = [<span class="string">&quot;Kirkwood&quot;</span>, <span class="string">&quot;Squaw&quot;</span>, <span class="string">&quot;Alpine&quot;</span>];</span><br><span class="line"><span class="built_in">console</span>.log(thirdResort]; <span class="comment">// Alpine</span></span><br></pre></td></tr></table></figure>
<h3 id="字符串解构赋值"><a href="#字符串解构赋值" class="headerlink" title="字符串解构赋值"></a>字符串解构赋值</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> [a, b, c, d, e = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">a <span class="comment">// &quot;h&quot;</span></span><br><span class="line">b <span class="comment">// &quot;e&quot;</span></span><br><span class="line">c <span class="comment">// &quot;l&quot;</span></span><br><span class="line">d <span class="comment">// &quot;l&quot;</span></span><br><span class="line">e <span class="comment">// &quot;o&quot;</span></span><br></pre></td></tr></table></figure>
<p>类似数组的对象都有一个<code>length</code>属性，因此还可以对这个属性解构赋值。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> &#123;<span class="attr">length</span>: len&#125; = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">len <span class="comment">// 5</span></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment">解构赋值 - JavaScript | MDN</a></li>
<li><a href="https://es6.ruanyifeng.com/#docs/destructuring">变量的解构赋值 - ECMAScript 6入门</a></li>
<li>《React 学习手册》</li>
</ul>
]]></content>
      <categories>
        <category>信息技术</category>
      </categories>
      <tags>
        <tag>【一天一个 es6 语法】</tag>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>从 Github 下载目标仓库指定文件夹</title>
    <url>/github-download-folder/</url>
    <content><![CDATA[<p>从 Github 下载目标仓库指定文件夹。</p>
<span id="more"></span>

<p><a href="https://github.com/HR/github-clone">HR/github-clone: ⬇️ git clone repo subdirectories</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pip install git+git:&#x2F;&#x2F;github.com&#x2F;HR&#x2F;github-clone#egg&#x3D;ghclone</span><br><span class="line">ghclone https:&#x2F;&#x2F;github.com&#x2F;HR&#x2F;Crypter&#x2F;tree&#x2F;master&#x2F;app</span><br><span class="line">ghclone https:&#x2F;&#x2F;github.com&#x2F;HR&#x2F;Picturesque&#x2F;tree&#x2F;master&#x2F;app&#x2F;src -t li50d67757gm20556d53f08126215725a698560b</span><br></pre></td></tr></table></figure>
<p>下载私有库文件的时候需要 -t 参数，需要提供账户的 OAuth token：<br><a href="https://docs.github.com/en/github/authenticating-to-github/creating-a-personal-access-token">Creating a personal access token - GitHub Docs</a></p>
<hr>
<h2 id="git-svn-踩坑日记"><a href="#git-svn-踩坑日记" class="headerlink" title="git-svn 踩坑日记"></a>git-svn 踩坑日记</h2><p>太晚了，踩了半天坑，没踩出来，不过记录一下吧，没准以后还会用到 git-svn，再继续解决。<br>目标是通过 git svn 下载资源的目录，想法是从 stackoverflow 来的，我对 svn 一点都不了解：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git svn clone https:&#x2F;&#x2F;github.com&#x2F;user&#x2F;repo&#x2F;folder&#x2F;folder</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">xcode-select --install</span><br></pre></td></tr></table></figure>
<p>执行前面的命令检查 CommandLineTools 是否安装，如有弹窗选择：是。一般重装系统或者系统大版本升级都要重新安装一次。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ brew reinstall git</span><br><span class="line">$ brew install apr-util</span><br><span class="line">$ brew install perl</span><br><span class="line">$ PERL_MM_OPT&#x3D;&quot;INSTALL_BASE&#x3D;$HOME&#x2F;perl5&quot; cpan local::lib</span><br><span class="line">$ echo &#39;eval &quot;$(perl -I$HOME&#x2F;perl5&#x2F;lib&#x2F;perl5 -Mlocal::lib&#x3D;$HOME&#x2F;perl5)&quot;&#39; &gt;&gt; ~&#x2F;.zshrc</span><br><span class="line">$ echo &#39;export PATH&#x3D;&quot;&#x2F;usr&#x2F;local&#x2F;opt&#x2F;apr&#x2F;bin:$PATH&quot;&#39; &gt;&gt; ~&#x2F;.zshrc</span><br><span class="line">$ echo &#39;export PATH&#x3D;&quot;&#x2F;usr&#x2F;local&#x2F;opt&#x2F;apr-util&#x2F;bin:$PATH&quot;&#39; &gt;&gt; ~&#x2F;.zshrc</span><br><span class="line">$ cpan SVN::Core  # 这命令耗时很久</span><br></pre></td></tr></table></figure>

<h3 id="报错信息："><a href="#报错信息：" class="headerlink" title="报错信息："></a>报错信息：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Can&#39;t locate SVN&#x2F;Core.pm in @INC (you may need to install the SVN::Core module) (@INC contains: &#x2F;usr&#x2F;local&#x2F;Cellar&#x2F;git&#x2F;2.27.0&#x2F;share&#x2F;perl5</span><br></pre></td></tr></table></figure>

<p>修改文件<code>/usr/local/opt/git/libexec/git-core/git-svn</code>的第一行， <code>#!/usr/bin/perl</code> 为 <code>#!/usr/local/bin/perl</code>。</p>
<h3 id="最终报错："><a href="#最终报错：" class="headerlink" title="最终报错："></a>最终报错：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Bad URL passed to RA layer: Unrecognized URL scheme for &#39;https:&#x2F;&#x2F;github.com&#x2F;PacktPub</span><br><span class="line">lishing&#x2F;Hands-On-Full-Stack-Development-with-Go&#39; at &#x2F;usr&#x2F;local&#x2F;Cellar&#x2F;git&#x2F;2.27.0&#x2F;sha</span><br><span class="line">re&#x2F;perl5&#x2F;Git&#x2F;SVN.pm line 148.</span><br></pre></td></tr></table></figure>
<p>git 关联的 svn 是它自带的 svn：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git svn --version</span><br><span class="line"># &#x2F;&#x2F; git-svn version 2.27.0 (svn 1.8.11)</span><br><span class="line">$ svn --version</span><br><span class="line"># &#x2F;&#x2F;svn, version 1.14.0 (r1876290)</span><br></pre></td></tr></table></figure>
<p>和上一个报错有共同之处。</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul>
<li><a href="https://github.com/HR/github-clone">HR/github-clone: ⬇️ git clone repo subdirectories</a></li>
<li><a href="https://teratail.com/questions/268932">Perl - git-svnを使用しようとした際に出るCan’t locate SVN/Core.pmというエラーの解決方法｜teratail</a></li>
<li><a href="https://stackoverflow.com/questions/61637163/git-svn-cant-locate-svn-core-pm-after-fresh-installation-of-macos-catalina-10-1">perl - git-svn Can’t locate SVN/Core.pm after fresh installation of macOS Catalina 10.15.4 - Stack Overflow</a></li>
</ul>
]]></content>
      <categories>
        <category>信息技术</category>
      </categories>
      <tags>
        <tag>Github</tag>
        <tag>git-svn</tag>
      </tags>
  </entry>
  <entry>
    <title>基于 GitHub Pages 的 Hexo+NexT 博客搭建</title>
    <url>/githubpages-hexo-next/</url>
    <content><![CDATA[<h1 id="基于-GitHub-Pages-的-Hexo-NexT-博客-——-引导篇"><a href="#基于-GitHub-Pages-的-Hexo-NexT-博客-——-引导篇" class="headerlink" title="基于 GitHub Pages 的 Hexo + NexT 博客 —— 引导篇"></a>基于 GitHub Pages 的 Hexo + NexT 博客 —— 引导篇</h1><h2 id="基于-GitHub-Pages-的-Hexo-NexT-博客概述"><a href="#基于-GitHub-Pages-的-Hexo-NexT-博客概述" class="headerlink" title="基于 GitHub Pages 的 Hexo + NexT 博客概述"></a>基于 GitHub Pages 的 Hexo + NexT 博客概述</h2><p>使用这一套博客系统架构您将获得稳定免费、美观、易定制的个人博客。通过 Markdown 语法编辑文章，git命令发布文章，优雅的博客发布体验。</p>
<span id="more"></span>

<h2 id="搭建本博客系统的技术条件"><a href="#搭建本博客系统的技术条件" class="headerlink" title="搭建本博客系统的技术条件"></a>搭建本博客系统的技术条件</h2><ol>
<li>基本的终端命令与理解，比如：如何 cd 进入一个需要进入的文件夹。</li>
<li>GitHub项目创建和项目下载。</li>
</ol>
<h1 id="GitHub-Pages"><a href="#GitHub-Pages" class="headerlink" title="GitHub Pages"></a>GitHub Pages</h1><h2 id="GitHub-Pages-简介"><a href="#GitHub-Pages-简介" class="headerlink" title="GitHub Pages 简介"></a>GitHub Pages 简介</h2><p>GitHub Pages 是GitHub免费为用户提供的，适用于 GitHub 用户发布自己的网页内容（静态网页）。<a href="https://pages.github.com/">官网🐱</a><br>GitHub Pages 的容量限制为1GB，流量限制为一个月100GB。GitHub用户名将作为github.com的二级域名，而每一个 github repository 都是可以部署在GitHub Pages上的，这样低成本的为前端开发人员免费的提供了一台稳定免费的测试服务器和域名。</p>
<p>GitHub Pages 同样是个人博客的优良载体, 以下教程将基于 GitHub Pages 打造个人博客。</p>
<h2 id="GitHub-Pages-博客项目建立"><a href="#GitHub-Pages-博客项目建立" class="headerlink" title="GitHub Pages 博客项目建立"></a>GitHub Pages 博客项目建立</h2><p>将项目创建于 GitHub Pages 的根目录下（”/“）。<br>保持创建普通GitHub项目的姿势，将项目名称命名为 GitHub用户名.github.io。<br>URL == “GitHub用户名.github.io/“</p>
<p>每个GitHub项目都可以部署到 GitHub Pages，作为二级路径(“项目名/“)。<br>Settings -&gt; GitHub Pages -&gt; Source -&gt; master branch<br>URL == “GitHub用户名.github.io/项目名/“</p>
<h1 id="Hexo"><a href="#Hexo" class="headerlink" title="Hexo"></a>Hexo</h1><h2 id="Hexo-简介"><a href="#Hexo-简介" class="headerlink" title="Hexo 简介"></a>Hexo 简介</h2><p>Hexo 基于Node.js开发是一 个纯静态的博客框架，使用Markdown渲染引擎文章。 </p>
<h2 id="Hexo-安装及配置"><a href="#Hexo-安装及配置" class="headerlink" title="Hexo 安装及配置"></a>Hexo 安装及配置</h2><p>Hexo 详细安装及配置请参考<br><a href="https://hexo.io/zh-cn/docs/">Hexo 官方文档</a><br>建议：完成官方文档“建站”继续查看后面的内容。<br>配置文件 : 后面都要加空格。<br>对_config.yml站点配置文件简要配置。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># URL</span><br><span class="line">url: https:&#x2F;&#x2F;GitHub用户名.github.io&#x2F;</span><br></pre></td></tr></table></figure>
<h2 id="Hexo-的使用"><a href="#Hexo-的使用" class="headerlink" title="Hexo 的使用"></a>Hexo 的使用</h2><p>相信您已经了解source文件夹是您以后存放文章的地方，并且已经看见官方文档中的这句话“Markdown 和 HTML 文件会被解析并放到 public 文件夹，而其他文件会被拷贝过去。”<br>而这个public文件夹的内容正是需要上传到GitHub Pages的内容，如何去生成呢？请继续往后看。</p>
<p>写完文章发布到服务器之前，先看看效果呗！现在source/_posts文件夹里面正好有一篇hello-world。<br>在站点文件夹根目录下执行如下命令（插件都在该目录安装）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ npm install hexo-server --save</span><br></pre></td></tr></table></figure>
<p>安装完成后，输入以下命令以启动服务器，您的网站会在 <a href="http://localhost:4000/">http://localhost:4000</a> 下启动。在服务器启动期间，Hexo 会监视文件变动并自动更新，您无须重启服务器。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ hexo s (即 hexo server)</span><br></pre></td></tr></table></figure>
<p>现在介绍两种发布文章的方式, 建议Windows用户用第一种，Mac用户使用第二种：</p>
<p>方案一：通过 hexo-deployer-git 插件<br>在站点文件夹根目录下执行如下命令（插件都在该目录安装）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>
<p>文件解析生成 public 文件夹</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ hexo g (即 hexo generate)</span><br></pre></td></tr></table></figure>
<p>配置_config.yml站点配置文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Deployment</span><br><span class="line">## Docs: https:&#x2F;&#x2F;hexo.io&#x2F;docs&#x2F;deployment.html</span><br><span class="line">deploy:</span><br><span class="line">   type: git</span><br><span class="line">   repository: 您下载自己项目的URL (项目在 GitHub Pages 根目录：https:&#x2F;&#x2F;github.com&#x2F;GitHub用户名.github.io.git&#x2F;)</span><br><span class="line">    branch: master</span><br></pre></td></tr></table></figure>
<p>项目部署</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ hexo d (即 hexo deploy)</span><br></pre></td></tr></table></figure>
<p>这里会提示输入您的github账号密码，通过前面提到的 URL 访问到您的博客， 项目部署成功。</p>
<p>方案二： 通过 git 命令部署<br>进入站点文件夹根目录，克隆您的项目到本地（目的是获取 .git 文件夹，这是 git 的全部）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git clone https:&#x2F;&#x2F;github.com&#x2F;GitHub用户名&#x2F;GitHub用户名.github.io.git .deploy&#x2F;GitHub用户名.github.io</span><br></pre></td></tr></table></figure>
<p>解析及部署命令如下（可将以下命令直接 deploy.sh 脚本文件里 ）: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ hexo generate                      # 文件解析生成 public 文件夹</span><br><span class="line">$ cp -R public&#x2F;* .deploy&#x2F;GitHub用户名.github.io  # 复制 public 文件夹的全部内容到 .deploy 隐藏文件夹下</span><br><span class="line">$ cd .deploy&#x2F;GitHub用户名.github.io</span><br><span class="line">$ git add .</span><br><span class="line">$ git commit -m “update”</span><br><span class="line">$ git push origin master</span><br></pre></td></tr></table></figure>
<p>将 deploy.sh 脚本文件放在站点文件夹根目录，cd 进入根目录，执行命令如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ sh deploy.sh</span><br></pre></td></tr></table></figure>
<p>这里会提示输入您的github账号密码，通过前面提到的 URL 访问到您的博客， 项目部署成功。</p>
<p>这一小节记住两个命令： hexo s 和 hexo d 或 sh deploy.sh<br>事实上 hexo s -s 更常使用（详情查看<a href="https://hexo.io/zh-cn/docs/server">官方文档 -&gt; 服务器</a>）</p>
<h2 id="使用个人域名"><a href="#使用个人域名" class="headerlink" title="使用个人域名"></a>使用个人域名</h2><p>如果想要使用自己的域名，在域名解析的时候使用CNAME记录类型。并实现个人博客向个人域名的映射，在source文件夹下创建CNAME文件（无后缀名），在文件中直接写入您的域名（http:// 后面的内容）</p>
<h1 id="NexT"><a href="#NexT" class="headerlink" title="NexT"></a>NexT</h1><h2 id="NexT-简介"><a href="#NexT-简介" class="headerlink" title="NexT 简介"></a>NexT 简介</h2><p>NexT 是一款完全基于 Hexo 的主题，使用者众多，成熟度高，我们可以基于它创造出属于我们不一样的个人博客。 </p>
<p>下面更多的是对该主题一些基本配置的讲述，请勿照搬，按自己的喜好描绘属于自己的博客吧。</p>
<h2 id="NexT-安装及配置"><a href="#NexT-安装及配置" class="headerlink" title="NexT 安装及配置"></a>NexT 安装及配置</h2><p>建议下载最新版本<br><a href="https://github.com/theme-next/hexo-theme-next/blob/master/docs/zh-CN/README.md">v6.0.x版本 GitHub 地址</a></p>
<p>NexT 详细安装及配置请参考<br><a href="https://theme-next.iissnan.com/getting-started.html">NexT 官方文档</a><br><a href="https://github.com/iissnan/hexo-theme-next/wiki">NexT 使用文档 GitHub Wiki</a>  </p>
<p>NexT 的配置围绕配置文件，对内置样式与第三方插件进行配置。（NexT 配置文件在 NexT 主题根目录，文件名和站点配置文件名相同）。</p>
<h2 id="外观设置"><a href="#外观设置" class="headerlink" title="外观设置"></a>外观设置</h2><p>目前官方有四款外观供选择，在 NexT 的配置文件下搜索 Schemes 删除注释符号 # 即可使用。 </p>
<h2 id="footer-页脚的配置"><a href="#footer-页脚的配置" class="headerlink" title="footer 页脚的配置"></a>footer 页脚的配置</h2><p>搜索 footer 将 powered theme 的 enable 调整为 false。</p>
<h2 id="添加标签-tags-页"><a href="#添加标签-tags-页" class="headerlink" title="添加标签 tags 页"></a>添加标签 tags 页</h2><p>执行以下命令将在 source 文件夹下将生成 tags 文件夹，打开修改里面的 index 文件添加 type : “tags”。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ hexo new page tags</span><br></pre></td></tr></table></figure>
<h2 id="添加分类-categories-页"><a href="#添加分类-categories-页" class="headerlink" title="添加分类 categories 页"></a>添加分类 categories 页</h2><p>执行以下命令将在 source 文件夹下将生成 categories 文件夹，打开修改里面的 index 文件添加 type : “categories”。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ hexo new page categories</span><br></pre></td></tr></table></figure>
<h2 id="分类和标签的应用"><a href="#分类和标签的应用" class="headerlink" title="分类和标签的应用"></a>分类和标签的应用</h2><p>事实上，分类和标签都是 hexo 实现的， 可查看官方文档 Front-matter 部分。</p>
<p>Front-matter 是通过 hexo new 生成的 md 文件 - - - 以上的区域。<br>categories 是有顺序性和层次性的而 tags 没有，例如:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">categories:</span><br><span class="line">- 人文</span><br><span class="line">- 散文</span><br><span class="line">tags:</span><br><span class="line">- 毕淑敏</span><br><span class="line">- 早年</span><br></pre></td></tr></table></figure>
<h2 id="menu-菜单栏配置"><a href="#menu-菜单栏配置" class="headerlink" title="menu 菜单栏配置"></a>menu 菜单栏配置</h2><p>搜索 menu 你可以选择打开一些菜单按钮 || 后面对应的是 Font Awesome 图标名。<br><a href="https://fontawesome.com/?from=io">Font Awesome</a><br><a href="http://www.fontawesome.com.cn/faicons/">图标库 – Font Awesome 中文网</a></p>
<h2 id="sidebar-侧边栏配置"><a href="#sidebar-侧边栏配置" class="headerlink" title="sidebar 侧边栏配置"></a>sidebar 侧边栏配置</h2><p>搜索 site_state， 文章、标签和分类默认在侧边栏中显示链接。</p>
<h2 id="social-社交链接配置"><a href="#social-社交链接配置" class="headerlink" title="social 社交链接配置"></a>social 社交链接配置</h2><p>搜索 social, 打开或自行添加。</p>
<h2 id="avatar-添加侧边栏头像"><a href="#avatar-添加侧边栏头像" class="headerlink" title="avatar 添加侧边栏头像"></a>avatar 添加侧边栏头像</h2><p>建议使用 对象存储OSS 存储图片或其他文件，易于管理。</p>
<h2 id="creative-commons-知识共享协议"><a href="#creative-commons-知识共享协议" class="headerlink" title="creative_commons 知识共享协议"></a>creative_commons 知识共享协议</h2><ul>
<li>署名（BY）</li>
<li>署名（BY）-禁止演绎（ND）</li>
<li>署名（BY）-非商业性使用（NC）</li>
<li>署名（BY）-非商业性使用（NC）-禁止演绎（ND）</li>
<li>署名（BY）-非商业性使用（NC）-相同方式共享（SA）</li>
<li>署名（BY）-相同方式共享（SA）</li>
</ul>
<h2 id="onmobile"><a href="#onmobile" class="headerlink" title="onmobile"></a>onmobile</h2><p>对于 Muse 和 Mist 两种外观生效，在手机端打开侧边栏。</p>
<h2 id="设置多说-DISQUS-评论"><a href="#设置多说-DISQUS-评论" class="headerlink" title="设置多说 DISQUS 评论"></a>设置多说 DISQUS 评论</h2><p>DISQUS 和 GitHub Pages 有一个相似之处,用户的站点 URL 会生成一个 Shortname, 二级域名与之对应, 所以注册完后点击头像左边的 Admin, 点击 Settings 选择注册的网站, Shortname 在 Website Name 的上面。其实不用查看也可猜出 Shortname, 将域名的 . 替换成 - 即可， 例如 <a href="https://blog.xyang.xin/">https://blog.xyang.xin</a> 对应的 Shortname 为 blog-xyang-xin。</p>
<p>关闭 tags 和 pages 页面的评论窗口，分别在它们的 index 文件添加 comments: false。</p>
<h1 id="基于-GitHub-Pages-的-Hexo-NexT-博客-——-样式优化篇"><a href="#基于-GitHub-Pages-的-Hexo-NexT-博客-——-样式优化篇" class="headerlink" title="基于 GitHub Pages 的 Hexo + NexT 博客 —— 样式优化篇"></a>基于 GitHub Pages 的 Hexo + NexT 博客 —— 样式优化篇</h1><h2 id="为文章边框添加立体阴影效果"><a href="#为文章边框添加立体阴影效果" class="headerlink" title="为文章边框添加立体阴影效果"></a>为文章边框添加立体阴影效果</h2><p>定位：themes/next/source/css/_common/components/post/post.styl文件<br>修改：在use-motion .post 下，添加box-shadow的代码 box-shadow <a href="https://www.cssmatic.com/box-shadow">生成网站</a></p>
<h2 id="修改菜单栏的文字颜色"><a href="#修改菜单栏的文字颜色" class="headerlink" title="修改菜单栏的文字颜色"></a>修改菜单栏的文字颜色</h2><p>定位：themes/next/source/css/_schemes/Mist/menu.styl文件<br>修改：在.menu-item a下添加color: 颜色</p>
<h2 id="修改文章底部的那个带-号的标签"><a href="#修改文章底部的那个带-号的标签" class="headerlink" title="修改文章底部的那个带#号的标签"></a>修改文章底部的那个带#号的标签</h2><p>定位：themes/next/layout/_macro/post.swig<br>修改：搜索 rel=”tag”&gt;#，将 # 换成 <i class="fa fa-tag"></i></p>
<h2 id="文章内链接"><a href="#文章内链接" class="headerlink" title="文章内链接"></a>文章内链接</h2><p>定位：themes/next/source/css/_custom/custom.styl 文件<br>添加：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.post-body p a &#123;</span><br><span class="line">  color: #0593d3;</span><br><span class="line">  border-bottom: none;</span><br><span class="line">  &amp;:hover &#123;</span><br><span class="line">    color: #0477ab;</span><br><span class="line">    text-decoration: underline;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="修改网站背景样式，自动切换背景图"><a href="#修改网站背景样式，自动切换背景图" class="headerlink" title="修改网站背景样式，自动切换背景图"></a>修改网站背景样式，自动切换背景图</h2><p>定位：themes/next/source/css/_custom/custom.styl 文件<br>添加：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 背景</span><br><span class="line">.main-inner &#123; </span><br><span class="line">    margin-top: 60px;</span><br><span class="line">    padding: 60px 60px 60px 60px;</span><br><span class="line">    background: #fff;</span><br><span class="line">	  opacity: 0.9;</span><br><span class="line">    min-height: 500px;</span><br><span class="line">&#125;</span><br><span class="line">body &#123;</span><br><span class="line">    background:url(https:&#x2F;&#x2F;source.unsplash.com&#x2F;random&#x2F;1600x900);</span><br><span class="line">    background-repeat: no-repeat;</span><br><span class="line">    background-attachment:fixed;</span><br><span class="line">    background-position:50% 50%;</span><br><span class="line">    background-size:cover;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意：.mian-inner 将覆盖前文提到的文章的阴影将 box-shadow 代码剪切到 .main-inner 里面即可。</p>
<h2 id="对-header-的修改"><a href="#对-header-的修改" class="headerlink" title="对 header 的修改"></a>对 header 的修改</h2><h3 id="更改头部-site-title-的字体颜色"><a href="#更改头部-site-title-的字体颜色" class="headerlink" title="更改头部 site-title 的字体颜色"></a>更改头部 site-title 的字体颜色</h3><p>定位：theme/next/source/css/_common/components/header/site-meta.styl 文件，找到.brand{}。<br>添加：color: 颜色</p>
<h3 id="头部背景颜色与透明度"><a href="#头部背景颜色与透明度" class="headerlink" title="头部背景颜色与透明度"></a>头部背景颜色与透明度</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.header &#123;</span><br><span class="line">          background:rgba(13,26,31,0.8) none repeat scroll !important;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<h2 id="对-footer-的修改"><a href="#对-footer-的修改" class="headerlink" title="对 footer 的修改"></a>对 footer 的修改</h2><h3 id="修改-footer-的文字居中"><a href="#修改-footer-的文字居中" class="headerlink" title="修改 footer 的文字居中"></a>修改 footer 的文字居中</h3><p>定位：themes/next/source/css/_schemes/Mist/index.styl 文件中的 footer。<br>修改：将 .footer-inner 的 text-align: left 修改为 center。</p>
<h3 id="底部文字颜色"><a href="#底部文字颜色" class="headerlink" title="底部文字颜色"></a>底部文字颜色</h3><p>定位：theme/next/source/css/_custom/custom.styl 文件<br>添加：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.footer-inner &#123;color: 颜色代码;&#125;</span><br></pre></td></tr></table></figure>
<h3 id="底部背景颜色与透明度"><a href="#底部背景颜色与透明度" class="headerlink" title="底部背景颜色与透明度"></a>底部背景颜色与透明度</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.footer &#123;</span><br><span class="line">          background:rgba(13,26,31,0.8) none repeat scroll !important;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<h2 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h2><p><a href="http://theme-next.iissnan.com/getting-started.html">开始使用 - NexT 使用文档</a></p>
]]></content>
      <categories>
        <category>信息技术</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo 博客进阶</title>
    <url>/hexo-advance/</url>
    <content><![CDATA[<h2 id="文章简介"><a href="#文章简介" class="headerlink" title="文章简介"></a>文章简介</h2><p>本文介绍 Hexo 博客的一些进阶操作。</p>
<ul>
<li>解决 Github Pages 不被百度抓取的问题；</li>
<li>使用 gulp 压缩资源，实现访问加速。</li>
<li>在博客中添加音频和视频；<span id="more"></span>
<h2 id="Github-Pages-不被百度抓取的方法"><a href="#Github-Pages-不被百度抓取的方法" class="headerlink" title="Github Pages 不被百度抓取的方法"></a>Github Pages 不被百度抓取的方法</h2>并通过域名 CNAME 实现国内外分流，<h3 id="Coding-Pages"><a href="#Coding-Pages" class="headerlink" title="Coding Pages"></a>Coding Pages</h3><a href="https://help.coding.net/docs/devops/cd/static-website.html#%E8%87%AA%E5%AE%9A%E4%B9%89%E5%9F%9F%E5%90%8D%E8%AE%BE%E7%BD%AE">CODING 静态网站服务 - CODING 帮助中心</a></li>
</ul>
<h3 id="私有的-OSS"><a href="#私有的-OSS" class="headerlink" title="私有的 OSS"></a>私有的 OSS</h3><p>以阿里云oss为例<br><img data-src="https://images.xyang.xin/2020-04/1586841854.png" alt="开通子目录首页"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install --save hexo-deployer-oss</span><br></pre></td></tr></table></figure>
<p><code>_config.yml</code> 配置</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">oss</span></span><br><span class="line">  <span class="attr">accessKeyId:</span> <span class="string">&lt;your</span> <span class="string">accessKeyId&gt;</span></span><br><span class="line">  <span class="attr">accessKeySecret:</span> <span class="string">&lt;your</span> <span class="string">accessKeySecret&gt;</span></span><br><span class="line">  <span class="attr">bucket:</span> <span class="string">&lt;your</span> <span class="string">bucket&gt;</span></span><br><span class="line">  <span class="attr">region:</span> <span class="string">&lt;your</span> <span class="string">region&gt;</span></span><br></pre></td></tr></table></figure>
<p>  其中 region 以北京地区的 oss 为例填 <code>oss-cn-beijing</code></p>
<h2 id="使用-gulp-压缩资源"><a href="#使用-gulp-压缩资源" class="headerlink" title="使用 gulp 压缩资源"></a>使用 gulp 压缩资源</h2><p>使用 gulp 压缩资源，提高访问速度。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install gulp-cli -g</span><br><span class="line">npm install gulp gulp-htmlclean gulp-htmlmin gulp-imagemin gulp-clean-css gulp-uglify --save-dev</span><br></pre></td></tr></table></figure>

<p>项目根目录新建<code>gulpfile.babel.js</code>，添加如下内容：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> gulp <span class="keyword">from</span> <span class="string">&#x27;gulp&#x27;</span></span><br><span class="line"><span class="keyword">import</span> cleancss <span class="keyword">from</span> <span class="string">&#x27;gulp-clean-css&#x27;</span></span><br><span class="line"><span class="keyword">import</span> uglify <span class="keyword">from</span> <span class="string">&#x27;gulp-uglify-es&#x27;</span></span><br><span class="line"><span class="keyword">import</span> htmlmin <span class="keyword">from</span> <span class="string">&#x27;gulp-htmlmin&#x27;</span></span><br><span class="line"><span class="keyword">import</span> htmlclean <span class="keyword">from</span> <span class="string">&#x27;gulp-htmlclean&#x27;</span></span><br><span class="line"><span class="keyword">import</span> imagemin <span class="keyword">from</span> <span class="string">&#x27;gulp-imagemin&#x27;</span></span><br><span class="line"><span class="keyword">import</span> babel <span class="keyword">from</span> <span class="string">&#x27;gulp-babel&#x27;</span></span><br><span class="line"></span><br><span class="line">gulp.task(<span class="string">&#x27;minify-html&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> gulp.src(<span class="string">&#x27;./public/**/*.html&#x27;</span>)</span><br><span class="line">    .pipe(htmlclean(&#123;</span><br><span class="line">      protect: <span class="regexp">/&lt;\!--%fooTemplate\b.*?%--&gt;/g</span>,</span><br><span class="line">      edit: <span class="function">(<span class="params">html</span>) =&gt;</span> &#123; <span class="keyword">return</span> html.replace(<span class="regexp">/\begg(s?)\b/ig</span>, <span class="string">&#x27;omelet$1&#x27;</span>); &#125;</span><br><span class="line">    &#125;))</span><br><span class="line">    .pipe(htmlmin(&#123;</span><br><span class="line">      removeComments: <span class="literal">true</span>,</span><br><span class="line">      collapseWhitespace: <span class="literal">true</span>,</span><br><span class="line">      collapseBooleanAttributes: <span class="literal">true</span>,</span><br><span class="line">      removeEmptyAttributes: <span class="literal">true</span>,</span><br><span class="line">      removeScriptTypeAttributes: <span class="literal">true</span>,</span><br><span class="line">      removeStyleLinkTypeAttributes: <span class="literal">true</span>,</span><br><span class="line">      minifyJS: <span class="literal">true</span>,</span><br><span class="line">      minifyCSS: <span class="literal">true</span>,</span><br><span class="line">    &#125;))</span><br><span class="line">    .on(<span class="string">&#x27;error&#x27;</span>, <span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&#x27;html Error!&#x27;</span>, err.message);</span><br><span class="line">      <span class="built_in">this</span>.end();</span><br><span class="line">    &#125;)</span><br><span class="line">    .pipe(gulp.dest(<span class="string">&#x27;./public&#x27;</span>))</span><br><span class="line">&#125;);</span><br><span class="line">gulp.task(<span class="string">&#x27;clean-css&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> gulp.src(<span class="string">&#x27;./public/**/*.css&#x27;</span>)</span><br><span class="line">    .pipe(cleancss())</span><br><span class="line">    .pipe(gulp.dest(<span class="string">&#x27;./public&#x27;</span>));</span><br><span class="line">&#125;);</span><br><span class="line">gulp.task(<span class="string">&#x27;minify-js&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> gulp.src(<span class="string">&#x27;./public/js/**/*.js&#x27;</span>)</span><br><span class="line">    .pipe(uglify())</span><br><span class="line">    .pipe(gulp.dest(<span class="string">&#x27;./public&#x27;</span>));</span><br><span class="line">&#125;);</span><br><span class="line">gulp.task(<span class="string">&#x27;minify-images&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> gulp.src(<span class="string">&#x27;./public/images/**/*.*&#x27;</span>)</span><br><span class="line">    .pipe(imagemin())</span><br><span class="line">    .pipe(gulp.dest(<span class="string">&#x27;./public/images&#x27;</span>))</span><br><span class="line">&#125;);</span><br><span class="line">gulp.task(<span class="string">&#x27;default&#x27;</span>, gulp.parallel(<span class="string">&#x27;minify-html&#x27;</span>, <span class="string">&#x27;clean-css&#x27;</span>, <span class="string">&#x27;minify-js&#x27;</span>, <span class="string">&#x27;minify-images&#x27;</span>, <span class="function">(<span class="params">done</span>) =&gt;</span> &#123;</span><br><span class="line">  done();</span><br><span class="line">&#125;));</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>由于是 es6 语法， 需要使用 babel 转译。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install --save-dev gulp-babel @babel/register @babel/preset-env @babel/core</span><br></pre></td></tr></table></figure>
<p>创建<code>.babel.json</code> 文件，添加内容如下：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;presets&quot;</span>: [</span><br><span class="line">    <span class="string">&quot;@babel/env&quot;</span></span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">&quot;plugins&quot;</span>: []</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>终端执行如下命令即可：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo g &amp;&amp; gulp</span><br></pre></td></tr></table></figure>

<p>如有报错，可以尝试删除<code>node_modules</code>文件，然后重新执行<code>npm install</code>。</p>
<h2 id="在博客中插入音频与视频"><a href="#在博客中插入音频与视频" class="headerlink" title="在博客中插入音频与视频"></a>在博客中插入音频与视频</h2><h3 id="音频"><a href="#音频" class="headerlink" title="音频"></a>音频</h3><h4 id="更快捷的方案一"><a href="#更快捷的方案一" class="headerlink" title="更快捷的方案一"></a>更快捷的方案一</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">frameborder</span>=<span class="string">&quot;no&quot;</span> <span class="attr">border</span>=<span class="string">&quot;0&quot;</span> <span class="attr">marginwidth</span>=<span class="string">&quot;0&quot;</span> <span class="attr">marginheight</span>=<span class="string">&quot;0&quot;</span> <span class="attr">width</span>=<span class="string">430</span> <span class="attr">height</span>=<span class="string">86</span> <span class="attr">src</span>=<span class="string">&quot;XXX&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br></pre></td></tr></table></figure>
<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=430 height=86 src="https://music.xyang.xin/%E5%9C%A8%E8%BF%99%E4%B8%AA%E4%B8%96%E7%95%8C%E7%9B%B8%E9%81%87.mp3"></iframe>

<h4 id="更强大的方案二（Github）"><a href="#更强大的方案二（Github）" class="headerlink" title="更强大的方案二（Github）"></a>更强大的方案二（<a href="https://github.com/MoePlayer/hexo-tag-aplayer#usage">Github</a>）</h4><h3 id="视频"><a href="#视频" class="headerlink" title="视频"></a>视频</h3><h4 id="更快捷的标签方式"><a href="#更快捷的标签方式" class="headerlink" title="更快捷的标签方式"></a>更快捷的标签方式</h4><p>iframe 将web页嵌入到另一个网页</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">width</span>=<span class="string">&quot;854&quot;</span> <span class="attr">height</span>=<span class="string">&quot;480&quot;</span> <span class="attr">src</span>=<span class="string">&quot;//player.bilibili.com/player.html?aid=51918958&amp;cid=90895494&amp;page=1&quot;</span> <span class="attr">scrolling</span>=<span class="string">&quot;no&quot;</span> <span class="attr">border</span>=<span class="string">&quot;0&quot;</span> <span class="attr">frameborder</span>=<span class="string">&quot;no&quot;</span> <span class="attr">framespacing</span>=<span class="string">&quot;0&quot;</span> <span class="attr">allowfullscreen</span>=<span class="string">&quot;true&quot;</span>&gt;</span> <span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br></pre></td></tr></table></figure>

<iframe width="854" height="480" src="//player.bilibili.com/player.html?aid=51918958&cid=90895494&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>

<h4 id="更强大的-hexo-tag-dplayer-插件"><a href="#更强大的-hexo-tag-dplayer-插件" class="headerlink" title="更强大的 hexo-tag-dplayer 插件"></a>更强大的 <a href="https://github.com/MoePlayer/hexo-tag-dplayer">hexo-tag-dplayer</a> 插件</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install hexo-tag-dplayer --save</span><br></pre></td></tr></table></figure>

<h3 id="PDF"><a href="#PDF" class="headerlink" title="PDF"></a>PDF</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">object</span> <span class="attr">data</span>=<span class="string">&quot;mypdf.pdf&quot;</span> <span class="attr">type</span>=<span class="string">&quot;application/pdf&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">width</span>=<span class="string">&quot;800&quot;</span> <span class="attr">height</span>=<span class="string">&quot;1200&quot;</span> <span class="attr">typemustmatch</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>You don&#x27;t have a PDF plugin, but you can <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;myfile.pdf&quot;</span>&gt;</span>download the PDF file.<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">object</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://developer.mozilla.org/zh-CN/docs/Learn/HTML/Multimedia_and_embedding/%E5%85%B6%E4%BB%96%E5%B5%8C%E5%85%A5%E6%8A%80%E6%9C%AF">从对象到iframe - 其他嵌入技术 - 学习 Web 开发 | MDN</a><br><a href="https://luanzhuxian.github.io/post/e5ac3b51.html">使用 Gulp 压缩 Hexo | 栾铸显的博客</a><br><a href="https://shuoit.net/tech-notes/use-gulp-to-speed-hexo-1547999542.html">引入gulp压缩整站资源进一步提高写作效率 - 说IT</a></p>
]]></content>
      <categories>
        <category>信息技术</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>由简入深配置 iTem2 终端</title>
    <url>/iterm2/</url>
    <content><![CDATA[<h1 id="iTerm2"><a href="#iTerm2" class="headerlink" title="iTerm2"></a>iTerm2</h1><p>brew 安装 zsh<br>    <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">brew install zsh</span><br><span class="line">sudo chsh -s &#x2F;usr&#x2F;local&#x2F;bin&#x2F;zsh</span><br></pre></td></tr></table></figure><br>从 zsh 切换回 bash<br>    <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">chsh -s &#x2F;bin&#x2F;bash</span><br></pre></td></tr></table></figure></p>
<span id="more"></span>
<p>PS：如果从 bash 切换到 zsh，但想保留 bash 所设置的环境变量，可在 .zshrc文件末尾添加 </p>
<pre><code><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">source ~&#x2F;.bash_profile</span><br></pre></td></tr></table></figure></code></pre>
<p>安装 oh my zsh  </p>
<pre><code><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">curl -L https:&#x2F;&#x2F;github.com&#x2F;robbyrussell&#x2F;oh-my-zsh&#x2F;raw&#x2F;master&#x2F;tools&#x2F;install.sh | sh</span><br></pre></td></tr></table></figure></code></pre>
<h2 id="自动提示命令"><a href="#自动提示命令" class="headerlink" title="自动提示命令"></a>自动提示命令</h2><p>我们输入命令时，终端会自动提示你接下来可能要输入的命令，这时按 → 便可输出这些命令，非常方便。<br>设置如下：</p>
<ul>
<li><p>克隆仓库到本地 ~/.oh-my-zsh/custom/plugins 路径下</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone git:&#x2F;&#x2F;github.com&#x2F;zsh-users&#x2F;zsh-autosuggestions $ZSH_CUSTOM&#x2F;plugins&#x2F;zsh-autosuggestions</span><br></pre></td></tr></table></figure></li>
<li><p>用 vim  ~/.zshrc 打开文件，下滑找到插件设置命令，默认是 <code>plugins=(git)</code> ，我们把它修改为</p>
<p>  <code>plugins=(zsh-autosuggestions git)</code></p>
</li>
<li><p>要修改提示命令的颜色才看得到效果<br><img data-src="https://images.xyang.xin/2018-11/1541985092.png" alt="-c666"><br>然后这样 vim 的颜色也会随之改变</p>
</li>
<li><p>修改提示颜色在 .zshrc 文件中添加如下命令</p>
<p>  <code>ZSH_AUTOSUGGEST_HIGHLIGHT_STYLE=&#39;fg=value&#39;</code></p>
</li>
</ul>
<h2 id="主题"><a href="#主题" class="headerlink" title="主题"></a>主题</h2><p>安装成功后，用vim ~/.zshrc打开隐藏文件，修改主题为agnoster</p>
<p>PS：<a href="https://github.com/powerline/fonts/blob/master/Meslo%20Slashed/Meslo%20LG%20M%20Regular%20for%20Powerline.ttf">zsh主题</a>，参考主题连接选择自己喜欢的主题。</p>
<pre><code>`ZSH_THEME=&quot;agnoster&quot;`</code></pre>
<p>应用这个主题需要特殊的字体支持，否则会出现乱码情况，这时我们来配置字体：</p>
<ul>
<li><p>使用<a href="https://github.com/powerline/fonts/blob/master/Meslo%20Slashed/Meslo%20LG%20M%20Regular%20for%20Powerline.ttf"> Meslo</a> 字体，点开连接点击 view raw 下载字体。</p>
</li>
<li><p>安装字体到系统字体册。</p>
<h2 id="语法高亮"><a href="#语法高亮" class="headerlink" title="语法高亮"></a>语法高亮</h2><p>  <code>brew install zsh-syntax-highlighting</code><br>在.zshrc中追加以下内容:  </p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">source &#x2F;usr&#x2F;local&#x2F;share&#x2F;zsh-syntax-highlighting&#x2F;zsh-syntax-highlighting.zsh</span><br><span class="line">plugins&#x3D;(</span><br><span class="line">    git</span><br><span class="line">    zsh-autosuggestions</span><br><span class="line">    zsh-syntax-highlighting # 务必在最后</span><br><span class="line">    ）</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="给-iTerm-中Vim配色"><a href="#给-iTerm-中Vim配色" class="headerlink" title="给 iTerm 中Vim配色"></a>给 iTerm 中Vim配色</h2><p>首先<a href="https://github.com/altercation/solarized">下载solarized</a>  </p>
<pre><code><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ cd solarized  </span><br><span class="line">$ cd vim-colors-solarized&#x2F;colors  </span><br><span class="line">$ mkdir -p ~&#x2F;.vim&#x2F;colors   </span><br><span class="line">$ cp solarized.vim ~&#x2F;.vim&#x2F;colors&#x2F;</span><br><span class="line">$ vi ~&#x2F;.vimrc  </span><br></pre></td></tr></table></figure></code></pre>
<p>加入下面三行设置即可：  </p>
<pre><code><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">syntax enable  </span><br><span class="line">set background&#x3D;dark  </span><br><span class="line">colorscheme solarized</span><br></pre></td></tr></table></figure></code></pre>
<h2 id="给ls配色"><a href="#给ls配色" class="headerlink" title="给ls配色"></a>给ls配色</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vim .zshrc</span><br><span class="line">export LSCOLORS&#x3D;&quot;exfxcxdxbxexexabagacad&quot;</span><br></pre></td></tr></table></figure>

<h2 id="安装-thefuck-纠错插件"><a href="#安装-thefuck-纠错插件" class="headerlink" title="安装 thefuck 纠错插件"></a>安装 thefuck 纠错插件</h2><p><code>brew install thefuck</code><br>修正上一条错误的输入</p>
<h2 id="安装-autojump"><a href="#安装-autojump" class="headerlink" title="安装 autojump"></a>安装 autojump</h2><p><code>brew install autojump</code><br> // zshrc新增<br> [[ -s $(brew –prefix)/etc/profile.d/autojump.sh ]] &amp;&amp; . $(brew –prefix)/etc/profile.d/autojump.sh<br> // 生效配置<br><code> source ~/.zshrc</code></p>
<h2 id="让终端走代理"><a href="#让终端走代理" class="headerlink" title="让终端走代理"></a>让终端走代理</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export http_proxy&#x3D;http:&#x2F;&#x2F;127.0.0.1:1080;export https_proxy&#x3D;http:&#x2F;&#x2F;127.0.0.1:1080</span><br><span class="line">curl pub.dartlang.org  # 无输出则设置成功</span><br><span class="line"># 需要代理服务器支持 http</span><br></pre></td></tr></table></figure>
<h2 id="iterm2-vim-开启滚轮"><a href="#iterm2-vim-开启滚轮" class="headerlink" title="iterm2 vim 开启滚轮"></a>iterm2 vim 开启滚轮</h2><p>在 iterm2中配置如下<br><img data-src="https://images.xyang.xin/2018-11/1541989133.png" alt="-c666"></p>
<h2 id="配置-download-with-scp"><a href="#配置-download-with-scp" class="headerlink" title="配置 download with scp"></a>配置 download with scp</h2><p>本地和服务器都需要安装 iterm2 的 shell integration。</p>
<p>在服务器端配置文件 <code>.zshrc</code> 下面这段<strong>之后</strong>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">test -e &quot;$&#123;HOME&#125;&#x2F;.iterm2_shell_integration.zsh&quot; &amp;&amp; source &quot;$&#123;HOME&#125;&#x2F;.iterm2_shell_integration.zsh&quot; || true</span><br></pre></td></tr></table></figure>
<p>添加：<br><code>export iterm2_hostname=远程服务器公网Ip</code></p>
<p>在服务器端，ls 然后点击鼠标右键，可以下载文件。<br>在客户端，拖拽，然后按住 option 键，拖拽至服务器终端，可以进行上传。<br>使用的是 scp 协议。</p>
]]></content>
      <categories>
        <category>信息技术</category>
      </categories>
      <tags>
        <tag>开发工具</tag>
      </tags>
  </entry>
  <entry>
    <title>编程语言之 Java</title>
    <url>/java-language/</url>
    <content><![CDATA[<h1 id="Integer-parseInt-与-Integer-valueOf-的比较"><a href="#Integer-parseInt-与-Integer-valueOf-的比较" class="headerlink" title="Integer.parseInt() 与 Integer.valueOf() 的比较"></a>Integer.parseInt() 与 Integer.valueOf() 的比较</h1><p>Integer.parseInt() 和 Integer.valueOf() 都是用来 将String转换为Int的。</p>
<ul>
<li>Integer.parseInt()，返回一个原子类型int.<ul>
<li>parseInt() 只是调用parseInt, 并且返回原子类型int.</li>
</ul>
</li>
<li>Integer.valueOf(), 返回的是封装的Integer对象。<ul>
<li>valueOf 也会调用parseInt, 但是返回Integer对象。而且它会维护一个cache，如果int值在cache范围内，直接从cache中取对象，如果不在，则会新创建一个对象。</li>
</ul>
</li>
</ul>
<p>如果我们只是需要一个int值，parseInt是合适的，而且效率要高，但是如果用valueOf就多此一举了，性能会下降。<br><a href="https://www.imooc.com/article/37688">🐱文章</a></p>
]]></content>
      <categories>
        <category>信息技术</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>学习 HTTP 协议笔记</title>
    <url>/learn-http-basics/</url>
    <content><![CDATA[<h2 id="网络模型"><a href="#网络模型" class="headerlink" title="网络模型"></a>网络模型</h2><p>五层网络模型：<br><img data-src="http://images.xyang.xin/2020%2F09%2F03%2Fclassic-five-layer-model.jpg?x-oss-process=style/title_800" alt="classic-five-layer-model.jpg"></p>
<span id="more"></span>
<p><img data-src="http://images.xyang.xin/2020%2F09%2F03%2F16fb20a7abacc050.png?x-oss-process=style/title_800" alt="16fb20a7abacc050.png"><br>OSI 七层模型是国际标准化组织的标准，由于前者过于复杂且指定周期长，在整套标准推出之前，TCP/IP 模型就已经在全球范围内被广泛使用了，所以TCP/IP模型成了事实上的国际标准。我们在学习和开发中，将两者结合，这就是五层网络模型。</p>
<h3 id="协议举例及功能"><a href="#协议举例及功能" class="headerlink" title="协议举例及功能"></a>协议举例及功能</h3><h4 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h4><p>功能：为应用软件提供了很多服务。</p>
<p>协议： HTTP、DNS、FTP（文件传输）、SSH、Telnet、SMTP（电子邮件）</p>
<h4 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h4><p>功能：向用户提供可靠的端到端服务。</p>
<p>协议： TCP、UDP</p>
<h4 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h4><p>功能：寻址、路由。</p>
<p>协议：IPV4、IPV6、RARP、ICMP(V4、V6)</p>
<p>设备：路由器、三层交换机</p>
<h4 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h4><p>功能：在通信实体间建立数据链路连接。</p>
<p>协议：以太网、Wi-Fi</p>
<p>设备：网卡、交换机</p>
<h4 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h4><p>功能：定义物理设备如何传输数据。</p>
<p>设备：光纤、集线器、RJ-45接头</p>
<h2 id="HTTP-协议发展历史"><a href="#HTTP-协议发展历史" class="headerlink" title="HTTP 协议发展历史"></a>HTTP 协议发展历史</h2><h3 id="HTTP-0-9"><a href="#HTTP-0-9" class="headerlink" title="HTTP/0.9"></a>HTTP/0.9</h3><p>HTTP 最早版本是1991年发布的0.9版本。该版本有如下特点：</p>
<ol>
<li>只有一个命令<code>GET</code>。</li>
<li>没有<code>HEADER</code>等描述数据的信息。</li>
<li>协议规定，服务器只能回应HTML格式的字符串，不能回应别的格式。</li>
<li>服务器发送完毕，就关闭TCP连接。</li>
</ol>
<h3 id="HTTP-1-0"><a href="#HTTP-1-0" class="headerlink" title="HTTP/1.0"></a>HTTP/1.0</h3><p>1996年5月，HTTP/1.0发布，内容大大增加：</p>
<ol>
<li>任何格式的内容都可以发送。</li>
<li>新增<code>POST</code>和<code>HEAD</code>命令。</li>
<li>每次通信都必须包含头信息（HTTP header）。</li>
<li>新增状态码（status code）。</li>
<li>新增多字符集支持、多部分发送（multi-part type）、权限（authorization）、缓存（cache）、内容编码（content encoding）等。</li>
</ol>
<h3 id="HTTP-1-1"><a href="#HTTP-1-1" class="headerlink" title="HTTP/1.1"></a>HTTP/1.1</h3><p>1997年1月，HTTP/1.1 版本发布，至今（2020年）仍是最流行的版本。新增的功能有：</p>
<h4 id="1-持久连接（persistent-connection）"><a href="#1-持久连接（persistent-connection）" class="headerlink" title="1. 持久连接（persistent connection）"></a>1. 持久连接（persistent connection）</h4><p>即TCP连接默认不关闭，可以被多个请求复用。默认开启<code>Connection: keep-alive</code>。</p>
<p>客户端和服务器发现对方一段时间没有活动，就可以主动关闭连接。不过，规范的做法是，客户端在最后一个请求时，发送<code>Connection:close</code>，明确要求服务器关闭TCP连接。</p>
<p>目前，对于同一个域名，大多数浏览器允许同时建立6个持久连接。</p>
<h4 id="2-管道机制（pipelining）"><a href="#2-管道机制（pipelining）" class="headerlink" title="2. 管道机制（pipelining）"></a>2. 管道机制（pipelining）</h4><p>即在同一个TCP连接里面，客户端可以同时发送多个请求。</p>
<p>举例来说，客户端需要请求两个资源。以前的做法是，在同一个TCP连接里面，先发送A请求，然后等待服务器做出回应，收到后再发出B请求。管道机制则是允许浏览器同时发出A请求和B请求，但是服务器还是按照顺序，先回应A请求，完成后再回应B请求。</p>
<h4 id="3-其他"><a href="#3-其他" class="headerlink" title="3. 其他"></a>3. 其他</h4><p>新增动词方法：<code>PUT</code>、<code>PATCH</code>、<code>OPTIONS</code>、<code>DELETE</code></p>
<p>客户端请求头新增<code>Host</code>字段，用来指定服务器的域名。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Host: www.example.com</span><br></pre></td></tr></table></figure>

<p>有了<code>Host</code>字段，就可以将请求发往同一台服务器上的不同网站。虚拟主机技术就是利用的这一点。在apache，ngnix环境下，直接通过配置文件cfg文件来配置不同的域名和网站根目录之间的映射关系。</p>
<h3 id="HTTP-2"><a href="#HTTP-2" class="headerlink" title="HTTP/2"></a>HTTP/2</h3><ol>
<li>所有数据以二进制传输</li>
<li>多工。双向的、实时的通信，就叫做多工。举例来说，在一个TCP连接里面，服务器同时收到了A请求和B请求，于是先回应A请求，结果发现处理过程非常耗时，于是就发送A请求已经处理好的部分， 接着回应B请求，完成后，再发送A请求剩下的部分。</li>
<li>头信息压缩以及服务器推送等提高效率的功能。</li>
</ol>
<h2 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h2><p>进行三次握手的目的是连接服务器指定端口，建立TCP连接，并同步连接双方的序列号和确认号，交换TCP窗口大小信息。三次握手由客户端发起，第一次握手， 客户端创建一个请求数据包，指明客户端打算连接服务器的端口，发送完毕进入<code>SYN_SEND</code>状态；二次握手，服务器端发送确认包，进入<code>SYN_RCVD</code>状态；三次握手，客户端再次发送确认包。发送完毕后，客户端进入<code>ESTABILISHED</code>状态，服务器收到后也进入<code>ESTABLISHED</code>状态。</p>
<p>二次握手后客户端和服务器端本来已经相互通信，交换信息了，本来可以直接建立连接了。但是为什么要进行三次握手呢？</p>
<p>这是服务器端为防止服务器端误会客户端的意思，服务器端开启无用连接，而浪费资源。</p>
<p>这就好比，一个你一直有好感的女孩向你发了个信息，“我喜欢你”。收到消息，你激动不已，你发了封信息“我也爱你，咱们交往吧”，然后就辗转反侧等消息，整夜没睡。但是第二天女孩说，不好意思，人家是玩的真心话大冒险。二次握手，不可靠。就是这个道理。如果有良知的美丽女孩当天就应该给人家回信进行第三次握手，拒绝或者接受。</p>
<h2 id="URI、URL和URN的区别"><a href="#URI、URL和URN的区别" class="headerlink" title="URI、URL和URN的区别"></a>URI、URL和URN的区别</h2><p>URI(Uniform resource identifier) 统一资源标识符</p>
<p>URL(uniform resource locator) 统一资源定位器（网址）<br>URN(uniform resource name) 统一资源命名（ISBN 编码）</p>
<p>URL 是 URI，URN 也是 URI。URL 和 URN 两种兼备也是 URI。<br><img data-src="http://images.xyang.xin/2020%2F09%2F03%2Furi-url-urn.png" alt="uri-url-urn.png"><br>URN定义某事物的身份，而URL提供查找该事物的方法。</p>
<p>用于标识唯一书目的ISBN系统是一个典型的URN使用范例。例如，ISBN 0-486-27557-4无二义性地标识出莎士比亚的戏剧《罗密欧与朱丽叶》的某一特定版本。为获得该资源并阅读该书，人们需要它的位置，也就是一个URL地址。在类Unix操作系统中，一个典型的URL地址可能是一个文件目录，例如file:///home/username/RomeoAndJuliet.pdf。该URL标识出存储于本地硬盘中的电子书文件。因此，URL和URN有着互补的作用。</p>
<h2 id="HTTP-报文格式"><a href="#HTTP-报文格式" class="headerlink" title="HTTP 报文格式"></a>HTTP 报文格式</h2><p>请求报文：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GET &#x2F;index.txt HTTP&#x2F;1.0</span><br><span class="line">User-Agent: Mozilla&#x2F;5.0 (Macintosh; Intel Mac OS X 10_10_5)</span><br><span class="line">Accept: *&#x2F;*</span><br><span class="line">Accept-Language: en</span><br></pre></td></tr></table></figure>
<p>相应报文：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">HTTP&#x2F;1.0 200 OK </span><br><span class="line">Content-Type: text&#x2F;plain</span><br><span class="line">Content-Length: 137582</span><br><span class="line">Expires: Thu, 05 Dec 1997 16:00:00 GMT</span><br><span class="line">Last-Modified: Wed, 5 August 1996 15:55:28 GMT</span><br><span class="line">Server: Apache 0.84</span><br><span class="line"></span><br><span class="line">&lt;html&gt;</span><br><span class="line">  &lt;body&gt;Hello World&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>TIP：其中 <code>GET</code>、<code>POST</code>等命令是语义化的定义，<code>GET</code>请求一个数据，<code>POST</code>创建一个数据，但是他们都只是协议上规定的，不是强约束的，可以手动修改其行为，有点像HTML5标签。</p>
</blockquote>
<h2 id="HTTP-状态码"><a href="#HTTP-状态码" class="headerlink" title="HTTP 状态码"></a>HTTP 状态码</h2><p>响应分为五类：<br>100-199 服务器收到请求<br>200-299 成功响应<br>300-399 重定向<br>400-499 客户端错误<br>500-599 服务器错误</p>
<p>常见的状态码：<br>200 请求成功<br>301 永久重定向（浏览器会记住返回301的网址，下次直接访问另一个网址）<br>302 临时重定向（下次再访问旧网址，还是要先访问旧网址，再根据 location 访问新网址）<br>304 资源未被修改<br>403 没有权限<br>404 资源未找到<br>500 服务器遇到了不知道如何处理的问题<br>504 网关超时</p>
<h2 id="跨域"><a href="#跨域" class="headerlink" title="跨域"></a>跨域</h2><p>同源政策：协议、域名、端口号都相同则同源。如果不同源有如下限制：</p>
<ol>
<li>当前域下的 JS 脚本不能访问其他作用域的 cookie、localStorage 和 indexDB。</li>
<li>当前域下的 JS 脚本不能操作访问其他域下的 DOM。</li>
<li>当前域下的 ajax 无法发送跨域请求。</li>
</ol>
<p>通过 <code>http://127.0.0.1:8888</code> 获取到文件<code>index.html</code>，如果文件中有一段js脚本，请求<code>http://127.0.0.1:8887</code>的数据，也就是不同源的数据，浏览器会向8887服务器发送请求，并且接收返回内容，但是会检查是否有<code>Access-Control-Allow-Origin</code>头，并且设置为允许，就会将响应内容忽略掉，并返回错误。</p>
<p>解决办法：</p>
<ol>
<li>CORS。8887的服务端响应时可以添加<code>&quot;Access-Control-Allow-Origin&quot;:&quot;http://127.0.0.1:8888&quot;</code>消息头，允许跨域请求。通过<code>Access-Control-Allow-Headers:&quot;*&quot;</code>允许跨域请求时添加的某些请求头。</li>
<li>JSONP。浏览器允许<code>&lt;link&gt;</code>、<code>&lt;img&gt;</code>、<code>&lt;script&gt;</code> 在标签上写 URL 加载内容允许跨域。JSONP 就是在<code>&lt;script&gt;</code>上加载一个链接，向服务器请求JSON数据，服务器收到请求后，将数据放在一个指定名字的回调函数里传回来，客户端修改返回的内容。</li>
<li>WebSocket。该协议不实行同源政策，只要服务器支持，就可以实现跨域。</li>
<li>window.postMessage。HTML5的跨文档通信API，允许跨窗口通信，不论这两个窗口是否同源。</li>
<li>一级域名相同的域名，可以通过设置<code>document.domain=&quot;example.com&quot;</code>来共享Cookie。</li>
</ol>
<p>以上办法解决的跨域限制是不同的，例如：CORS、JSONP和WebSocket解决了AJAX跨域的问题。而<code>document.domain</code>解决了Cookie跨域的问题，<code>window.postMessage</code>解决了DOM跨域的问题。DOM跨域，典型的例子是<code>iframe</code>窗口和<code>window.open</code>方法打开的窗口，它们与父窗口无法通信。</p>
<h2 id="HTTP-缓存"><a href="#HTTP-缓存" class="headerlink" title="HTTP 缓存"></a>HTTP 缓存</h2><h3 id="Cache-Control-头"><a href="#Cache-Control-头" class="headerlink" title="Cache-Control 头"></a>Cache-Control 头</h3><p>HTTP/1.1 定义的<code>Cache-Control</code>头用来区分对缓存机制的支持情况，请求头和响应头都支持这个属性。通过它提供的不同值来定义缓存策略。<code>*</code>表示浏览器端常用的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; *缓存中不得存储任何关于客户端和服务端响应的内容。</span><br><span class="line">Cache-Control: no-store</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; *每次有请求发出时，缓存会将此请求发到服务器，服务器验证是否过期，</span><br><span class="line">&#x2F;&#x2F; 若未过期返回304，缓存才使用本地缓存副本。</span><br><span class="line">Cache-Control: no-cache</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; *可以被任何中间人（中间代理、CDN等）缓存。</span><br><span class="line">Cache-Control: public</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; *中间人不能缓存此响应，该响应只能应用于浏览器私有缓存中。</span><br><span class="line">Cache-Control: private</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; *表示资源能够被缓存的最大时间。</span><br><span class="line">Cache-Control: max-age&#x3D;31536000</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 中间人的资源缓存时间将不使用max-age，而使用s-maxage。</span><br><span class="line">Cache-Control: s-maxage&#x3D;31536000</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; *保证已过期的缓存不被使用，必须从服务端重新获取请求。</span><br><span class="line">Cache-Control: must-revalidate</span><br><span class="line"></span><br><span class="line">Cache-Control: proxy-revalidate</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 浏览器特定时间内仍可使用过期的缓存。</span><br><span class="line">Cache-Control: max-stale &#x3D; 31536000</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 禁止中间人进行压缩、格式转换等。</span><br><span class="line">Cache-Control: no-transform</span><br></pre></td></tr></table></figure>

<h3 id="缓存验证"><a href="#缓存验证" class="headerlink" title="缓存验证"></a>缓存验证</h3><h4 id="Expire"><a href="#Expire" class="headerlink" title="Expire"></a>Expire</h4><p>Expire 是 HttpHeader 中代表资源的过期时间，由服务器端设置。如果带有 Expire ，则在 Expire 过期前不会发生 Http 请求，直接从缓存中读取。用户强制刷新例外（Windows:<code>ctrl+F5</code>，Mac:<code>command+option+R</code>），强制刷新是指无论如何都从服务器重新获取数据。</p>
<h4 id="Last-Modified"><a href="#Last-Modified" class="headerlink" title="Last-Modified"></a>Last-Modified</h4><p>Last-Modified 是 HttpHeader 中的资源的上次修改时间，如果带有 Last-Modified ，下一次发送 Http 请求时，将会发生带 If-modified-since 的 HttpHeader。与服务器端进行对比，如果没有过期，将会收到 304 的响应，从缓存中读取。</p>
<h4 id="Etag"><a href="#Etag" class="headerlink" title="Etag"></a>Etag</h4><p>Etag 是 HttpHeader 中代表资源的标签，在服务器端生成。如果带有 Etag ，下一次发送带 Etag 的请求，如果 Etag 没有变化将收到 304 的响应，从缓存中读取。<br>Etag 在使用时要注意相同资源多台 Web 服务器的 Etag 的一致性。所以分布式环境（比如CDN）很少使用ETag。</p>
<p>区别：<br>Expire 兼容 HTTP/1.0 浏览器。<br>Etag 更加严格的验证，可以可靠的比较指纹。<br>Last-Modified 不验证实际页面内容是否更改，对页面频繁更改的网页更加有利。</p>
<h2 id="Cookie-和-Session"><a href="#Cookie-和-Session" class="headerlink" title="Cookie 和 Session"></a>Cookie 和 Session</h2><p>Cookie 在服务端返回数据的时候通过<code>Set-Cookie</code>设置，浏览器获取Cookie后保存在本地，下次请求会自动带上，Cookie 是键值对，可以设置多个。<code>max-age</code>和<code>expires</code>设置过期时间，HttpOnly无法通过<code>document.cookie</code>访问。Session与之类似。<br>不过Session与Cookie不同之处在于，Cookie把数据放在客户端，而Session把数据放在服务器端。<br>将登陆信息等重要信息存放为Session，其他信息放在Cookie中。</p>
<p> Cookie, LocalStorage 与 SessionStorage 的区别：<br><img data-src="http://images.xyang.xin/2020%2F09%2F04%2Fcookie-localstorage-sessionstorage.png" alt="cookie-localstorage-sessionstorage.png"></p>
<h2 id="长连接和短连接"><a href="#长连接和短连接" class="headerlink" title="长连接和短连接"></a>长连接和短连接</h2><p>TCP 本身并没有长短连接的区别，长短与否，完全取决于我们怎么用它。</p>
<ul>
<li>短连接：每次通信时，创建 Socket；一次通信结束，调用 socket.close()。这就是一般意义上的短连接，短连接的好处是管理起来比较简单，存在的连接都是可用的连接，不需要额外的控制手段。</li>
<li>长连接：每次通信完毕后，不会关闭连接，这样可以做到连接的复用。长连接的好处是省去了创建连接的耗时。</li>
</ul>
<p>短连接和长连接的优势，分别是对方的劣势。想要图简单，不追求高性能，使用短连接合适，这样我们就不需要操心连接状态的管理；想要追求性能，使用长连接，我们就需要担心各种问题：比如 端对端连接的维护，连接的保活。</p>
<p>HTTP1.1规定了默认保持长连接（HTTP persistent connection ，也有翻译为持久连接），数据传输完成了保持TCP连接不断开（不发RST包、不四次握手），等待在同域名下继续用这个通道传输数据；相反的就是短连接。</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul>
<li><a href="https://coding.imooc.com/class/225.html">HTTP协议原理+实践 Web开发工程师必学-慕课网实战</a></li>
<li><a href="https://juejin.im/post/6844904049800642568">详解 四层、五层、七层 计算机网络模型 - 掘金</a></li>
<li><a href="https://zh.wikipedia.org/wiki/%E5%BA%94%E7%94%A8%E5%B1%82">应用层 - 维基百科，自由的百科全书</a></li>
<li><a href="https://zh.wikipedia.org/wiki/%E7%BD%91%E7%BB%9C%E5%B1%82">网络层 - 维基百科，自由的百科全书</a></li>
<li><a href="https://zh.wikipedia.org/wiki/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82">数据链路层 - 维基百科，自由的百科全书</a></li>
<li><a href="https://zh.wikipedia.org/wiki/%E7%89%A9%E7%90%86%E5%B1%82">物理层 - 维基百科，自由的百科全书</a></li>
<li><a href="http://www.ruanyifeng.com/blog/2016/08/http.html">HTTP 协议入门 - 阮一峰的网络日志</a></li>
<li><a href="https://blog.csdn.net/walkingmanc/article/details/49363869">同一个ip通一个80端口部署多个网站的原理-虚拟主机技术本质解析_walkingmanc的专栏-CSDN博客</a></li>
<li><a href="https://blog.csdn.net/zhanghongzheng3213/article/details/79855775">TCP为什么需要3次握手与4次挥手_zhanghongzheng3213的专栏-CSDN博客</a></li>
<li><a href="https://zh.wikipedia.org/wiki/%E7%BB%9F%E4%B8%80%E8%B5%84%E6%BA%90%E6%A0%87%E5%BF%97%E7%AC%A6">统一资源标志符 - 维基百科，自由的百科全书</a></li>
<li><a href="https://github.com/CavsZhouyou/Front-End-Interview-Notebook/blob/master/JavaScript/JavaScript.md">Front-End-Interview-Notebook/JavaScript.md at master · CavsZhouyou/Front-End-Interview-Notebook</a></li>
<li><a href="https://www.ruanyifeng.com/blog/2016/04/same-origin-policy.html">浏览器同源政策及其规避方法 - 阮一峰的网络日志</a></li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Caching_FAQ">HTTP 缓存 - HTTP | MDN</a></li>
<li><a href="https://www.iteye.com/blog/coolfiry-1189525">【技术心得】Last-Modified,Etag,Expire区别 - coolfiry - ITeye博客</a></li>
<li><a href="https://jerryzou.com/posts/cookie-and-web-storage/">详说 Cookie, LocalStorage 与 SessionStorage | 咀嚼之味</a></li>
<li><a href="https://www.jianshu.com/p/0c4de17dd6bc">Tcp长连接和keepalive - 简书</a></li>
<li><a href="https://www.cnblogs.com/duanxz/p/3623486.html">HTTP协议中的长连接和短连接（keep-alive状态） - duanxz - 博客园</a></li>
</ul>
]]></content>
      <categories>
        <category>信息技术</category>
      </categories>
      <tags>
        <tag>http</tag>
      </tags>
  </entry>
  <entry>
    <title>环形链表</title>
    <url>/leetcode-142/</url>
    <content><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><a href="https://leetcode-cn.com/problems/linked-list-cycle-ii/">142. 环形链表 II - 力扣（LeetCode）</a><br>给定一个链表，返回链表入环的第一个节点。无环返回null。<br><img data-src="http://images.xyang.xin/2020%2F09%2F13%2FlinkList.jpg?x-oss-process=style/title_800" alt="linkList.jpg"></p>
<span id="more"></span>

<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>环形链表问题，通用的解法，是通过设置双指针，</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> runSlow = head</span><br><span class="line"><span class="keyword">let</span> runFast = head</span><br></pre></td></tr></table></figure>
<p>将 runFast 的速度，设置为2，runSlow 的速度设置为 1，当 runFast 所在节点等于 runSlow 所在节点代表追上了。</p>
<p>因为 runFast 和 runSlow 同时出发，且 runFast 的速度为 runSlow 速度的两倍。<br><strong>无论如何 runSlow 跑的第一圈就会被追上</strong>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(runFast &amp;&amp; runFast.next)&#123;</span><br><span class="line">    runFast = runFast.next.next</span><br><span class="line">    runSlow = runSlow.next</span><br><span class="line">    <span class="keyword">if</span> (runFast === runSlow)&#123;</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果有环，到这里我们已经能够得到，runFast 和 runSlow 的相遇点了。<br><img data-src="http://images.xyang.xin/2020%2F09%2F13%2FlinkListRYS.jpg?x-oss-process=style/title_800" alt="linkListRYS.jpg"></p>
<p>题解：<br>相遇时：</p>
<ul>
<li>runSlow 走距离为：R + Y；</li>
<li>runFast 走的距离为：R + n(Y+S) + Y</li>
<li>R + n(Y+S) + Y = 2(R + Y)</li>
<li>(n-1)Y + nS = R</li>
</ul>
<p>只要以上等式成立即可，可以任意取n，这里取n为1：R = S，<br><strong>也就是入口点的距离等于相遇点到这一圈终点的距离</strong>。</p>
<p>这是我知道了 R=S 这个结论后，再推倒的，如果不知道结论，本弱还在设圈的周长的未知数呢。并且最后一步的思想很关键。<em>任意取</em>。</p>
<p>所以根据这个结论，我们从起始点再放一个速度为 1 的节点，并且让runSlow继续跑，和这个新节点相遇的点就是入口点，这里为了节省那一点点内存，可以让runFast受累一下，让他从新从head开始以1的速度跑。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">runFast = head</span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(runFast == runSlow)&#123;</span><br><span class="line">        <span class="keyword">return</span> runFast</span><br><span class="line">    &#125;</span><br><span class="line">    runFast = runFast.next</span><br><span class="line">    runSlow = runSlow.next</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="知识积累"><a href="#知识积累" class="headerlink" title="知识积累"></a>知识积累</h2><ul>
<li>入口点的距离等于相遇点到这一圈终点的距离</li>
<li>不相关的参数可以任意设</li>
</ul>
]]></content>
      <categories>
        <category>信息技术</category>
      </categories>
      <tags>
        <tag>leecode</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>journal-2019-02-15</title>
    <url>/journal-2019-02-15/</url>
    <content><![CDATA[<h2 id="小孩成长与人才发展"><a href="#小孩成长与人才发展" class="headerlink" title="小孩成长与人才发展"></a>小孩成长与人才发展</h2><p>小孩是懵懂的，从家长的角度要注重其过程，从过程推导孩子的优良，若不观其过程，孩子成绩差的原因只会被家长归纳为，天资不聪、贪玩等。</p>
<p>孩子成年，便有了一定的目标与发展方向，此时我们需要更偏向于观其结果。因为老一辈人平庸，不一定孩子平庸；老一辈人罪恶，不一定孩子罪恶。尽可能将我们的善传递给孩子，对孩子的奉献，是人类奉献精神最简单的体现。</p>
<p>国家之于人才也是如此，人才之初便是懵懂的，对其评判更应注重其过程，关注其现实的影响力。在“痕迹管理”等考核方法仍有缺陷的情况下，运用互联网的技术手段实现更优良的行业考核制度，将技术与社会紧密连结。</p>
<p>参考：<a href="http://www.qstheory.cn/dukan/qs/2019-02/01/c_1124054691.htm">《基层减负 不是简单做减法》《求是》2019/03 </a></p>
]]></content>
      <categories>
        <category>日志</category>
      </categories>
  </entry>
  <entry>
    <title>切换 Shell 需谨慎</title>
    <url>/linux-user/</url>
    <content><![CDATA[<h2 id="系统环境介绍"><a href="#系统环境介绍" class="headerlink" title="系统环境介绍"></a>系统环境介绍</h2><p>gentoo 半吊子机。<br><img data-src="https://images.xyang.xin/2018-10/1539332010.png" alt="valid login shells"></p>
<span id="more"></span>

<h2 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h2><p>执行<code>chsh -s /bin/zsh</code>命令切换成功。<br>自此导致 root 用户无法验证登陆。</p>
<p>庆幸这台服务器不止一个用户。<br>通过普通用户登陆服务器，执行 su 命令显示如下：<br><img data-src="https://images.xyang.xin/2018-10/1539333225.png" alt="执行 su 命令"></p>
<h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>解决办法如下：<br>sudo vim /etc/passwd 将 root 用户所对应的 Shell 改回 Bash。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>一台服务器应该有至少两个以上的用户。<br>下次再遇到一次这样的服务器😢再去具体研究一下。</p>
]]></content>
      <categories>
        <category>信息技术</category>
      </categories>
      <tags>
        <tag>Shell</tag>
      </tags>
  </entry>
  <entry>
    <title>鲁迅</title>
    <url>/luxun/</url>
    <content><![CDATA[<h2 id="资本"><a href="#资本" class="headerlink" title="资本"></a>资本</h2><p>凡走狗，虽或为一个资本家所豢养，其实是属于所有的资本家的，所以它遇见所有的阔人都驯良,遇见所有的穷人都狂吠。不知道谁是它的主子，真是它遇见所有阔人都驯良的原因，也就是属于资本家的证据。即使无人豢养，饿的精瘦，变成野狗了，但还是遇见所有的阔人都驯良，遇见所有的穷人都狂吠，不过这时它就愈不明白谁是主子了。</p>
<h2 id="土壤"><a href="#土壤" class="headerlink" title="土壤"></a>土壤</h2><p>天才并不是自生自长在深林荒野里的怪物，是由可以使天才生长的民众产生，长育出来的，所以没有这种民众，就没有天才。有一回拿破仑过 Alps 山，说，“我比 Alps 山还要高！”这何等英伟，然而不要忘记他后面跟着许多兵；倘没有兵，那只有被山那面的敌人捉住或者赶回，他的举动，言语，都离了英雄的界线，要归入疯子一类了。所以我想，在要求天才的产生之前，应该先要求可以使天才生长的民众。————譬如想有乔木，想看好花，一定要有好土；没有土，便没有花木了；所以土实在较花木还重要。花木非有土不可，正同拿破仑非有好兵不可一样。</p>
]]></content>
      <categories>
        <category>人文修养</category>
      </categories>
      <tags>
        <tag>鲁迅</tag>
      </tags>
  </entry>
  <entry>
    <title>解决远程服务器重装系统导致的 mac 终端无法连接的问题</title>
    <url>/mac-ssh-error/</url>
    <content><![CDATA[<p><img data-src="http://images.xyang.xin/2019-05%2F2019-05-14%20at%2017.17.png" alt="2019-05-14 at 17.17.png"><br>WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED!</p>
<p>known_hosts是记录远程主机的公钥的文件，重装服务器系统后，保存的公钥还是服务器重装之前的公钥，在ssh链接的时候首先会验证公钥，如果公钥不对，那么就会报错。</p>
<h2 id="通过如下两种方案解决该问题"><a href="#通过如下两种方案解决该问题" class="headerlink" title="通过如下两种方案解决该问题"></a>通过如下两种方案解决该问题</h2><ol>
<li><p>输入命令(推荐)：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh-keygen -R45.40.106.111</span><br></pre></td></tr></table></figure>
<span id="more"></span>
</li>
<li><p>删除下面文件中相关 ip 的信息（公匙）<br>~/.ssh/known_hosts</p>
</li>
</ol>
<p>.ssh文件为隐藏文件夹可通过 command + shift + . 查看。或者直接：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rm -rf ~/.ssh/known_hosts</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>信息技术</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Mac 大扫除🧹</title>
    <url>/macos-clean/</url>
    <content><![CDATA[<p>基于 macOS Catalina 版本 10.15.4, 128G固态，8GB内存。</p>
<p>通过以下命令可以查看当前路径下的所有文件及文件夹大小并从大到小排列，以 KB 为单位显示。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">du -sk *| sort -rn</span><br></pre></td></tr></table></figure>
<p>以下命令就是以K，M，G为单位，提高信息的可读性，但是不能正确按文件大小排序。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">du -sh *</span><br></pre></td></tr></table></figure>
<span id="more"></span>

<h2 id="用户文件清理"><a href="#用户文件清理" class="headerlink" title="用户文件清理"></a>用户文件清理</h2><p>我们称<code>～/</code>目录下的文件为用户文件。</p>
<ol>
<li>卸载不必要的应用，使用 柠檬清理 或者 AppCleaner 都是免费的。</li>
<li>通过 柠檬清理，CleanMyMac 等软件清理垃圾，删除无用的大文件，这类软件都只有管理用户文件的能力。</li>
<li>软件的配置、下载的插件等不能直接删除，应选择性删除：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">~&#x2F;Library&#x2F;Application Support&#x2F;</span><br></pre></td></tr></table></figure>
<ol>
<li>应用的缓存文件可以直接删除，不放心的话使用 trash 将其放入垃圾篓，如有异常还原便可，不用担心开不了机，用户文件也就是 ~/ 目录下的文件，是不会影响系统运行的：</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rm -rf ~/Library/Caches/*</span><br><span class="line">// or</span><br><span class="line">brew install trash</span><br><span class="line">trash ~/Library/Caches/*</span><br></pre></td></tr></table></figure>
<h2 id="“系统文件”清理"><a href="#“系统文件”清理" class="headerlink" title="“系统文件”清理"></a>“系统文件”清理</h2><h3 id="清理文件定位"><a href="#清理文件定位" class="headerlink" title="清理文件定位"></a>清理文件定位</h3><p>Catalina中，系统文件从原本的文件系统中分离了，组成独立的文件系统，并且把这个文件系统从设计上设定为只能读取，不能写入。<br><img data-src="http://images.xyang.xin/2020-04%2F1586700714.png" alt="1586700714.png"> </p>
<p>而其他文件和数据存储在Macintosh HD - Data卷中，挂载在<code>/System/Volumes/Data</code>目录下，在Finder中和系统卷一样显示为Macintosh HD。<br><img data-src="http://images.xyang.xin/2020-04%2F1586754964.png" alt="1586754964.png"></p>
<p>如何区分数据卷和系统卷呢？<br>可以说除<code>/System/Volumes/Data</code>目录下的文件，其他都是数据卷文件。</p>
<p>我们还可以发现一个怪异的现象，最明显的是<code>/Users</code>和<code>/Applications</code>同样出现在<code>/System/Volumes/Data/Applications</code>和<code>/System/Volumes/Data/Users</code>，而且内容相同、检测出来大小都相同，并且没有占用额外的空间。</p>
<p>这里用到的是 “Bi-directional wormhole in path traversal” （路径遍历中的双向虫洞）—— Firmlinks，一种新的文件类型对象，类似于符号链接。通过以下命令可以查看哪些文件创建了Firmlinks：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vim /usr/share/firmlinks</span><br></pre></td></tr></table></figure>
<p><img data-src="http://images.xyang.xin/2020-04%2F1586753548.png" alt="1586753548.png"></p>
<h3 id="开始清理"><a href="#开始清理" class="headerlink" title="开始清理"></a>开始清理</h3><p>系统卷不能修改和写入，所以不会产生额外的垃圾，删除一些不用的系统应用是可以的，比如国际象棋，但是它们都不怎么占空间，所以没大必要。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo rm -rf /System/Applications/Chess.app/</span><br></pre></td></tr></table></figure>

<p>我们实际上就是对 数据卷 进行清理。暂且把除去<code>/Users</code>用户文件外的文件都称为系统文件吧，因为它们很多都是与系统功能相关的，</p>
<p>通过<code>du -sk *| sort -rn</code>命令，以下六个文件夹占的空间比较大：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">30210188	Users</span><br><span class="line">18391484	Applications</span><br><span class="line">6144100	private</span><br><span class="line">4822752	usr</span><br><span class="line">4179388	System</span><br><span class="line">3856812	Library</span><br></pre></td></tr></table></figure>
<p><code>Users</code>是用户文件我们已经清理过了<code>Applications</code>是用户下载的应用，也清理过了，重点研究后面四个文件夹。</p>
<p><code>/System/Volumes/Data/private/var/vm</code> 这里面删了又有，我删过，并没有产生什么意外。其中 sleepimage 是用于休眠期间存储主存的内容；swapfile 用于虚拟内存存储，当物理内存满了，系统会自动“调出”未被积极使用的数据，并将其存储于 swapfile。这两个都可以关闭，但是都不建议。</p>
<p><code>/System/Volumes/Data/System/Library/Speech</code> 占了两个多G空间是语音相关的文件<code>say 你好</code>系统就会说<code>你好</code>。</p>
<p><code>/System/Volumes/Data/usr</code>，usr是Unix System Resource的缩写，也就是Unix操作系统软件资源，很多通过命令行安装的软件都存放在这里，比如mac包管理器brew安装的软件都存放在里面，<code>brew uninstall</code>只会卸载软件本身而不会卸载相关依赖，通过以下命令可以安全的卸载brew安装的软件及其依赖：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">brew tap beeftornado&#x2F;rmtree</span><br><span class="line">brew rmtree XX</span><br></pre></td></tr></table></figure>

<p>其实基于不同的使用习惯和用途，会产生不同的垃圾，用 <code>du</code> 命令一层层的分析查看，了解其内容含义，再清除是比较好的方法。</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul>
<li><a href="https://support.apple.com/en-us/HT210650">About the read-only system volume in macOS Catalina - Apple Support</a></li>
<li><a href="https://sspai.com/post/57052">当 Mac 升级到 Catalina 时，苹果在硬盘里施了点魔法 - 少数派</a></li>
<li><a href="https://devstreaming-cdn.apple.com/videos/wwdc/2019/710aunvynji5emrl/710/710_whats_new_in_apple_file_systems.pdf">https://devstreaming-cdn.apple.com/videos/wwdc/2019/710aunvynji5emrl/710/710_whats_new_in_apple_file_systems.pdf</a></li>
</ul>
]]></content>
      <categories>
        <category>信息技术</category>
      </categories>
      <tags>
        <tag>MacOS</tag>
      </tags>
  </entry>
  <entry>
    <title>Mac 配置上云神器 Mackup</title>
    <url>/mackup/</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><a href="https://github.com/lra/mackup">mackup</a> 是一款受关注度很高的开源软件，可运行于 osx 和 linux 系统。用于保持应用程序设置同步，可快捷的备份许多流行的应用程序。</p>
<span id="more"></span>

<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>有 brew 和 pip 两种推荐安装方式。</p>
<ul>
<li>Install Mackup<br><code>brew install mackup</code></li>
<li>Install Mackup with PIP<br><code>pip install --upgrade mackup</code></li>
</ul>
<p>还需要简单的<a href="https://github.com/lra/mackup/tree/master/doc">配置</a>才可使用。</p>
<p>创建 ～/.mackup.cfg 文件，根据需要添加配置。</p>
<p>可添加的配置如下：</p>
<ol>
<li><p>支持存储引擎：Dropbox、Google Drive、iCloud、Copy。<br> 例如选择存储到 icloud 添加如下配置即可：</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[storage]</span><br><span class="line">engine &#x3D; icloud</span><br></pre></td></tr></table></figure></li>
<li><p>备份到指定文件夹。</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[storage]</span><br><span class="line">engine &#x3D; file_system</span><br><span class="line">path &#x3D; some&#x2F;folder&#x2F;in&#x2F;your&#x2F;home（空格不需要转义）</span><br></pre></td></tr></table></figure>
<p> 指向存储引擎的路径怎么样？是不是就支持所有的存储引擎了呢。</p>
</li>
<li><p>支持修改备份文件夹的名字，改为隐藏文件夹。（备份隐藏起来了）</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[storage]</span><br><span class="line">engine &#x3D; icloud</span><br><span class="line">directory &#x3D; .config&#x2F;mackup</span><br></pre></td></tr></table></figure></li>
<li><p>选择你所要备份的应用。</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[applications_to_sync]</span><br><span class="line">ssh</span><br><span class="line">adium</span><br></pre></td></tr></table></figure></li>
<li><p>选择你不想备份的应用。</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[applications_to_ignore]</span><br><span class="line">ssh</span><br><span class="line">adium</span><br></pre></td></tr></table></figure></li>
<li><p>向官方提交支持应用的申请。</p>
</li>
<li><p>自定义很方便！</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mkdir ~&#x2F;.mackup</span><br><span class="line">touch ~&#x2F;.mackup&#x2F;my-files.cfg</span><br></pre></td></tr></table></figure>
<p> 在 my-files.cfg 中配置如下</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[application]</span><br><span class="line">name &#x3D; XXX </span><br><span class="line"></span><br><span class="line">[configuration_files]</span><br><span class="line">Library&#x2F;XXX         (从 Library 开始末尾无 &#x2F;)</span><br></pre></td></tr></table></figure>


</li>
</ol>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>备份应用的设置：</p>
<pre><code>`mackup backup`</code></pre>
<p>强制同意备份请求：</p>
<pre><code>`mackup backup -f`</code></pre>
<p>使用备份的设置：</p>
<pre><code>`mackup restore`</code></pre>
<p>应用不进行备份处理：</p>
<pre><code>`mackup uninstall`</code></pre>
<p>使用帮助：</p>
<pre><code>`mackup -h`</code></pre>
<h2 id="注意⚠️"><a href="#注意⚠️" class="headerlink" title="注意⚠️"></a>注意⚠️</h2><p>我最初使用 Mackup 只是为了备份配置，日后更换电脑方便，而没有去理解它的精髓，所以造成了不必要的时间损失，重新手动配置了诸多环境。认识到是自己操作不当所造成后，也只能为它写下这篇博客。</p>
<p>mackup 的备份命令说执行的并不是 copy。“保持应用程序设置同步”才是它的核心要义。<br>mackup backup 相当于如下三个命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cp ~/.gitconfig ~/Dropbox/Mackup/.gitconfig</span><br><span class="line">rm ~/.gitconfig</span><br><span class="line">ln -s ~/Dropbox/Mackup/.gitconfig ~/.gitconfig</span><br></pre></td></tr></table></figure>
<ol>
<li>将配置拷贝到你所配置的 mackup 备份路径之下。</li>
<li>删除原本的配置。</li>
<li>将备份后的路径软链接到原来的路径下。</li>
</ol>
<p>每台电脑都使用云上的配置，从而达到了应用程序设置同步的目的。<br>同时使用软链接的方式节省了一定的存储空间。</p>
<p>那如果把云上的配置删了怎么办呢？那么备份过的应用都只有一个软链接。。。<br>清空了垃圾篓，这个时候该咋办呢😢，做数据恢复？还是通过云近期删除找回，icloud 我是没找回过。</p>
<p>所以理解了之后，记得执行 <code>mackup uninstall</code> 再删。😣<br>修改 mac 账户名名称前也记得 <code>mackup uninstall</code>.</p>
]]></content>
      <categories>
        <category>信息技术</category>
      </categories>
      <tags>
        <tag>开发工具</tag>
      </tags>
  </entry>
  <entry>
    <title>Mac 小问题 —— iCloud 未响应</title>
    <url>/macos-problems/</url>
    <content><![CDATA[<p>使用 iCloud Drive 将文件上传到云端，防止数据丢失，同时可以实现多台设备的协同工作。但是在使用 iCloud Drive 的过程中我遇到了程序未响应，iCoud 文件上传阻塞的问题。</p>
<span id="more"></span>

<h2 id="Finder-无法打开或持续未响应"><a href="#Finder-无法打开或持续未响应" class="headerlink" title="Finder 无法打开或持续未响应"></a>Finder 无法打开或持续未响应</h2><p>解决办法：<br>磁盘工具 -&gt; Macintosh HD（系统盘）-&gt; 急救<br>磁盘工具在以下路径：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">/System/Applications/Utilities/Disk Utility.app</span><br></pre></td></tr></table></figure>

<p>急救操作不会对你的电脑造成任何损害，甚至还有所优化。</p>
<h2 id="打开-iCloud-云盘文件夹极其缓慢"><a href="#打开-iCloud-云盘文件夹极其缓慢" class="headerlink" title="打开 iCloud 云盘文件夹极其缓慢"></a>打开 iCloud 云盘文件夹极其缓慢</h2><p>遇到的问题是：在访达中点击iCloud云盘系统就会出现转圈圈的标志，使用快捷键<code>command+alt+esc</code>（强制退出应用程序）就会看到访达处于未响应状态，这个时间会持续很久。</p>
<p>解决办法：<br>系统偏好 -&gt; Apple ID -&gt; 取消勾选iCloud云盘 -&gt; 保留副本 -&gt; 重新勾选iCloud云盘</p>
<p>此操作造成的后果是mac需要很长的一段时间和云端同步，这取决于你icloud存储的文件大小，并不会影响其他。</p>
<h2 id="文件无法上传排查"><a href="#文件无法上传排查" class="headerlink" title="文件无法上传排查"></a>文件无法上传排查</h2><p>iCloud 连续几天几夜也没同步完，经过诸多排查，例如，修改 DNS：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">114.114.114.114</span><br><span class="line">8.8.8.8</span><br></pre></td></tr></table></figure>
<p>不仅没起作用，还影响了访问其他网页。最后删除 DNS 配置，刷新 DNS 缓存：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ 2$ sudo killall -HUP mDNSResponder</span><br></pre></td></tr></table></figure>

<p>最后排查出是因为，我开发代码的工作目录都设置在了 iCloud 云盘里，文件体积虽然不大，却有上万个细小的文件，不知道是不是 iCloud 设置了某种限制，导致上传阻塞，最后将代码都移出 iCloud 问题就解决了。</p>
<p>后面又卡住了，收获到一个命令通过这个命令可以查看 iCloud 同步进度：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ brctl log -w</span><br></pre></td></tr></table></figure>
<p>虽然没看懂运行的是什么，但是能够看到一直有东西在执行。<br>通过以下三个命令对 icloud 进行重置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 杀死icloud同步进程</span><br><span class="line">$ sudo killall bird</span><br><span class="line"># 删除 icloud 的配置文件</span><br><span class="line">$ sudo rm -rf ~&#x2F;Library&#x2F;Application\ Support&#x2F;CloudDocs</span><br><span class="line"># 立刻关机</span><br><span class="line">$ sudo shutdown -r now</span><br></pre></td></tr></table></figure>
<p>不必担心文件丢失，效果与关闭重新关闭icloud同步类似。重新开启电脑后可以通过前面说到的命令查看 iCloud 同步的进度。</p>
<p>也可以直接使用下面的脚本：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line"></span><br><span class="line">if [[ $EUID -eq 0 ]]; then</span><br><span class="line">    echo &quot;Killing bird.&quot;</span><br><span class="line">    killall bird</span><br><span class="line">    echo &quot;Removing CloudDocs&quot;</span><br><span class="line">    cd ~&#x2F;Library&#x2F;Application\ Support</span><br><span class="line">    rm -rf CloudDocs</span><br><span class="line">    echo &quot;Immediately rebooting!&quot;</span><br><span class="line">    shutdown -r now</span><br><span class="line">else</span><br><span class="line">    echo &quot;</span><br><span class="line">    This script needs run as sudo. </span><br><span class="line">    Use CAUTION when doing so.</span><br><span class="line">    You accept full responsibility using this script.</span><br><span class="line">    You should know what it&#39;s doing BEFORE you run it.</span><br><span class="line">    &quot;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>

<p>不必南辕北辙，越过中国的防火墙，iCloud 中国用户的文件存储在贵州云，而网上所谓的要获取验证文件，获取验证文件有香港的服务器。最后的任务就是等，我是让电脑喝着咖啡持续跑了接近一整天才同步完成的。</p>
<h2 id="Mac-无法同步-iPhone-剪贴板数据"><a href="#Mac-无法同步-iPhone-剪贴板数据" class="headerlink" title="Mac 无法同步 iPhone 剪贴板数据"></a>Mac 无法同步 iPhone 剪贴板数据</h2><p>iPhone 可以将 Mac 复制的内容，同步下来，而 Mac 不行。<br>解决办法：退出 iPhone 账号，并重新登陆。</p>
<h2 id="AirDrop-隔空投送文件传送"><a href="#AirDrop-隔空投送文件传送" class="headerlink" title="AirDrop 隔空投送文件传送"></a>AirDrop 隔空投送文件传送</h2><p>从 Mac 通过 AirDrop 传送文件至 iPhone，iPhone 必须有 App 可以打开传输文件格式的文件，否则文件将被遗弃。而我们需要传输一些特殊格式的文件的时候，我们可以将其压缩为 zip，这个时候 iPhone 就会接受了。</p>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul>
<li><a href="https://apple.stackexchange.com/questions/313716/icloud-drive-wont-sync-on-mac">macos - iCloud Drive Won’t Sync on Mac - Ask Different</a></li>
</ul>
]]></content>
      <categories>
        <category>信息技术</category>
      </categories>
      <tags>
        <tag>MacOS</tag>
        <tag>Finder</tag>
        <tag>iCloud</tag>
      </tags>
  </entry>
  <entry>
    <title>学习 CSS 时忽视的几个知识点</title>
    <url>/note-hings-i-wish-id-known-about-css/</url>
    <content><![CDATA[<p><a href="https://cssfordesigners.com/articles/things-i-wish-id-known-about-css">Things I Wish I’d Known About CSS</a></p>
<p>文章的作者以老式的方式构建网站：查看网站源代码、复制然后修改，而没有经过阅读书籍等系统性的学习。作者在 1999 年就使用这种方式了，当时写的还是这种代码： <code>&lt;font size=&quot;4&quot; color=&quot;#000000&quot;&gt;</code>。而当 CSS 面世的时候，作者没有改变自己的学习方法，而错过了太多基本知识。文章主要介绍的是作者希望早点学到的东西。</p>
<span id="more"></span>

<h2 id="Block-inline-and-inline-block"><a href="#Block-inline-and-inline-block" class="headerlink" title="Block, inline and inline-block"></a>Block, inline and inline-block</h2><ul>
<li><code>block</code> 元素水平扩展以占据一整行（就像标题）。我们可以对它们运用垂直 margin；</li>
<li><code>inline</code> 元素仅水平扩展到足以容纳其内容（就像 <code>strong</code> 或者 <code>em</code> 元素）；</li>
<li><code>inline-block</code> 元素像 <code>inline</code> 元素，但是你可以对它们运用垂直的 margin（对 <code>button</code> 之类的元素有用）；</li>
</ul>
<h2 id="图片是内联的"><a href="#图片是内联的" class="headerlink" title="图片是内联的"></a>图片是内联的</h2><p><code>img</code> 元素默认是内联的，一般来说没什么问题，但是在尝试定位图像或添加垂直边距时会引起混乱。建议添加如下规则：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">img</span> &#123;<span class="attribute">display</span>: block;&#125;</span><br></pre></td></tr></table></figure>
<p>也可以添加 <code>max-width: 100%;</code> 以阻止块级元素突破容器。<br><a href="https://github.com/necolas/normalize.css/blob/master/normalize.css">normalize.css</a> 里面没有，我觉得是否添加智者见智。</p>
<h2 id="计算宽度"><a href="#计算宽度" class="headerlink" title="计算宽度"></a>计算宽度</h2><p>默认情况下，盒子的宽度 / 高度是通过将以下各项相加得出的：</p>
<ul>
<li>Content area（内容）</li>
<li>Padding area（内边距）</li>
<li>Border area（边框）</li>
</ul>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.box-class</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">2em</span>;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">0.1rem</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>包含 <code>.box-class</code> 类的属性的盒子的宽度就是 <code>50% + 4em + 0.2rem</code><br>默认情况下，我们用 css 设置的 <code>width</code> 属性指的仅仅只是 Content area（内容）部分的宽度。</p>
<p>下列代码将应用于所有元素，使得 <code>width</code> 属性设置的为上述三者相加的值。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">* &#123;<span class="attribute">box-sizing</span>: border-box;&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Padding-amp-margin-不一样"><a href="#Padding-amp-margin-不一样" class="headerlink" title="Padding &amp; margin 不一样"></a>Padding &amp; margin 不一样</h2><p>CSS 盒模型还有一个重要的组成部分 <code>margin</code>。</p>
<ul>
<li><code>margin</code> 是元素之间的间隔</li>
<li><code>padding</code> 是内容和边框之间的间隔</li>
</ul>
<h2 id="Margins-崩塌"><a href="#Margins-崩塌" class="headerlink" title="Margins 崩塌"></a>Margins 崩塌</h2><p>当边距崩塌时，它们将合并在一起，从而使两个元素之间的间隔变为两个边距中较大的一个。较小的边距基本上结束在较大的边距之内。</p>
<p>当两个边距相遇时，较大的边距会吸收较小的边距。如果边距值相同，则它们会相互吸收。</p>
<p>假设我们有两个相邻的 block 元素，上面一个设置 <code>margin-bottom: 1em</code> 下面一个设置 <code>margin-top: 1.5em</code>，这两个元素间的间距将合并为 <code>1.5em</code> 而不是 <code>1em + 1.5em</code>。</p>
<blockquote>
<p>Note: 当父元素设置为 <code>display: grid</code> 或 <code>display: flex</code> 时，边距不会崩塌。</p>
</blockquote>
<h2 id="浏览器具有默认样式表"><a href="#浏览器具有默认样式表" class="headerlink" title="浏览器具有默认样式表"></a>浏览器具有默认样式表</h2><p>CSS(Cascading Style Sheets) 是层叠样式表。我们必须记住，始终存在默认的浏览器样式表。它会在任何自定义样式表之前加载，而我们可以很轻易的覆盖它们。</p>
<p>声明的样式因浏览器而异。抹平差异的方法主要有两种，任选其一：</p>
<ol>
<li>CSS 重置，将所有默认样式都设置为“零”，例如 <a href="https://meyerweb.com/eric/tools/css/reset/">https://meyerweb.com/eric/tools/css/reset/</a></li>
<li>normalize.css, 对默认样式进行微调，使它们在不同的浏览器中具有相似的外观：<a href="http://necolas.github.io/normalize.css/">http://necolas.github.io/normalize.css/</a></li>
</ol>
<h2 id="任何地方都使用相对单位"><a href="#任何地方都使用相对单位" class="headerlink" title="任何地方都使用相对单位"></a>任何地方都使用相对单位</h2><p>我们可以将 <code>em</code> 用于 <code>@media</code> 查询和垂直边距，而将 <code>rem</code> 用于一致的边框宽度。</p>
<h2 id="before-和-after-需要-content"><a href="#before-和-after-需要-content" class="headerlink" title="::before 和 ::after 需要 content"></a>::before 和 ::after 需要 content</h2><p>当我们使用 <code>::before</code> 或者 <code>::after</code> 伪元素时，需要添加 <code>content</code> 属性，即使它的值为空白：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.some-class::before &#123;content: &#39;&#39;;&#125;</span><br></pre></td></tr></table></figure>
<p>如果不包含此属性，伪元素将不会显示。</p>
<h2 id="ch-单位"><a href="#ch-单位" class="headerlink" title="ch 单位"></a>ch 单位</h2><p>ch(character)，大致基于一行的字符数来设置宽度的时候 <code>ch</code> 很有用。</p>
<p>1ch 就是数字 0 的宽度。</p>
<p>1ch 通常比平均字符宽度宽 20％到 30％。</p>
<h2 id="Normal-flow（正常布局流）"><a href="#Normal-flow（正常布局流）" class="headerlink" title="Normal flow（正常布局流）"></a>Normal flow（正常布局流）</h2><p>“normal flow” 的意思是出现在页面上的元素和在源代码中实现的方式相同。<br>例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;h2&gt;Heading&lt;&#x2F;h2&gt;</span><br><span class="line">&lt;p&gt;Paragraph text.&lt;&#x2F;p&gt;</span><br></pre></td></tr></table></figure>
<p>我们期望的是 <code>&lt;h2&gt;Heading&lt;/h2&gt;</code> 出现在 <code>&lt;p&gt;Paragraph text.&lt;/p&gt;</code> 的之前 / 顶部。这就是 <em>normal flow</em>。</p>
<p>而绝对定位和浮动就脱离了 <em>normal flow</em>。</p>
<h2 id="风格化-focus-状态"><a href="#风格化-focus-状态" class="headerlink" title="风格化 :focus 状态"></a>风格化 :focus 状态</h2><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">a</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: black;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:hover</span>,</span><br><span class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:focus</span>,</span><br><span class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:active</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们最好为 <code>:focus</code> 状态添加不同的样式。因为例如鼠标悬停或者已经激活，用户再按[tab]键，<code>:focus</code>就不起作用了。</p>
<p>为防止晚出现的规则覆盖前面出现的规则，按照如下顺序定义规则：<br>link、visited、focus、hover、active（缩写为 LVPHA）<br>或者 LVHFA 的顺序也是可以的。</p>
<h2 id="nth-child"><a href="#nth-child" class="headerlink" title=":nth-child()"></a>:nth-child()</h2><p><code>p:nth-child()</code>计算所有同级元素<br><code>p:nth-of-type()</code>仅计算同级的p元素</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>:nth-child()<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Paragraph one.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Paragraph two.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Paragraph three.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Paragraph four.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Paragraph five.<span class="tag">&lt;/<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">p</span>&gt;</span>Paragraph six.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">p</span><span class="selector-pseudo">:nth-child(even)</span> &#123;</span><br><span class="line">	<span class="attribute">background</span>: orange;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img data-src="http://images.xyang.xin/2020%2F07%2F25%2F1595610186.png" alt="1595610186.png"></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">p</span><span class="selector-pseudo">:nth-of-type(even)</span> &#123;</span><br><span class="line">	<span class="attribute">background</span>: orange;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img data-src="http://images.xyang.xin/2020%2F07%2F25%2F1595610292.png" alt="1595610292.png"></p>
<h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><p>掌握CSS的基础知识很容易，但是了解事情的方式和原因对编写更好的CSS至关重要。</p>
<p>花时间学习这些东西不仅帮助我更快地编写CSS，而且还使我的代码更高效，更灵活。</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul>
<li><a href="https://cssfordesigners.com/articles/things-i-wish-id-known-about-css">Things I Wish I’d Known About CSS</a></li>
<li>《HTML5 与 CSS3 基础教程 (第 8 版)》</li>
</ul>
]]></content>
      <categories>
        <category>信息技术</category>
      </categories>
      <tags>
        <tag>css</tag>
        <tag>note</tag>
      </tags>
  </entry>
  <entry>
    <title>包管理</title>
    <url>/package-management/</url>
    <content><![CDATA[<p>大部分成熟的操作系统有着各种不同的包管理器，某些软件也有自己的包管理器。</p>
<h2 id="系统包管理器"><a href="#系统包管理器" class="headerlink" title="系统包管理器"></a>系统包管理器</h2><ul>
<li>CentOS<ul>
<li>yum</li>
</ul>
</li>
<li>Gentoo    <ul>
<li>emerge</li>
</ul>
</li>
<li>MacOS     <ul>
<li><a href="https://brew.sh/index_zh-cn">Homebrew</a><ul>
<li>Homebrew 已经成为一款跨平台的包管理器 <a href="https://github.com/Linuxbrew/brew/blob/master/README.md">Linuxbrew</a><span id="more"></span>
<h2 id="软件包管理器"><a href="#软件包管理器" class="headerlink" title="软件包管理器"></a>软件包管理器</h2></li>
</ul>
</li>
</ul>
</li>
<li>Vim<ul>
<li><a href="https://github.com/junegunn/vim-plug">vim-plug</a><ul>
<li>支持多线程下载速度快，推荐使用。</li>
</ul>
</li>
<li><a href="https://github.com/VundleVim/Vundle.vim">vundle</a><ul>
<li>老牌</li>
</ul>
</li>
</ul>
</li>
<li>Node.js<ul>
<li>npm<ul>
<li>国内源<ul>
<li><code>npm config set registry https://registry.npm.taobao.org</code></li>
<li><code>npm config set disturl https://npm.taobao.org/dist</code></li>
</ul>
</li>
</ul>
</li>
<li>yarn<ul>
<li>facebook 研发</li>
<li>国内源<ul>
<li><code>yarn config set registry https://registry.npm.taobao.org --global</code></li>
<li><code>yarn config set disturl https://npm.taobao.org/dist --global</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>Java <ul>
<li>maven</li>
</ul>
</li>
<li>Go<ul>
<li>dep</li>
<li>go modules</li>
</ul>
</li>
</ul>
<h2 id="Homebrew"><a href="#Homebrew" class="headerlink" title="Homebrew"></a>Homebrew</h2><h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">% brew search # 搜索包</span><br><span class="line">% brew install # 安装包</span><br><span class="line">% brew uninstall # 删除包</span><br><span class="line">% brew update # 更新包</span><br><span class="line">% brew upgrade # 升级包</span><br><span class="line">% brew cleanup # 清理旧包</span><br></pre></td></tr></table></figure>

<h3 id="MacOS-下的-brew-cask"><a href="#MacOS-下的-brew-cask" class="headerlink" title="MacOS 下的 brew cask"></a>MacOS 下的 brew cask</h3><p>用于安装有图像界面的 app 以及驱动<br><code>brew install brew-cask</code></p>
<p>如果遇到问题可以先执行如下命令：<br><code>git -C &quot;$(brew --repo homebrew/core)&quot; fetch --unshallow</code></p>
<h3 id="Homebrew-换源"><a href="#Homebrew-换源" class="headerlink" title="Homebrew 换源"></a>Homebrew 换源</h3><p><a href="https://mirrors.tuna.tsinghua.edu.cn/help/homebrew/">Homebrew | 镜像站使用帮助 | 清华大学开源软件镜像站 | Tsinghua Open Source Mirror</a></p>
<h3 id="Homebrew-换回官方源"><a href="#Homebrew-换回官方源" class="headerlink" title="Homebrew 换回官方源"></a>Homebrew 换回官方源</h3><ul>
<li>重置 brew.git    <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd &quot;$(brew --repo)&quot;</span><br><span class="line">git remote set-url origin https:&#x2F;&#x2F;github.com&#x2F;Homebrew&#x2F;brew.git</span><br></pre></td></tr></table></figure></li>
<li>重置 Homebrew-core：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd &quot;$(brew --repo)&#x2F;Library&#x2F;Taps&#x2F;homebrew&#x2F;homebrew-core&quot;</span><br><span class="line">git remote set-url origin https:&#x2F;&#x2F;github.com&#x2F;Homebrew&#x2F;homebrew-core.git</span><br></pre></td></tr></table></figure></li>
<li>源更新<br><code>brew update</code></li>
</ul>
]]></content>
      <categories>
        <category>信息技术</category>
      </categories>
      <tags>
        <tag>包管理</tag>
      </tags>
  </entry>
  <entry>
    <title>HTTP 代理与 Socks5 代理</title>
    <url>/proxy-http-socks5/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>本文通过实践经历基本的认识 HTTP 代理与 Socks5 代理的用法与理解其精髓。同时也解决 go get 库无法下载的问题。</p>
<span id="more"></span>
<h2 id="渐渐"><a href="#渐渐" class="headerlink" title="渐渐"></a>渐渐</h2><p>终端走代理我最初接触到的是 HTTP 代理，这篇文章可以见证(<a href="https://blog.xyang.xin/proxy-teach/index.html">代理服务器 | 韶 光</a>)。当然我的这些实践都是基于 shadowsocks 这款产品。随后我又接触了 Socks5 代理，因为简单其更快，又隐隐觉得其更底层，通过以下代码配置：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> .zshrc</span></span><br><span class="line">export ALL_PROXY=socks5://127.0.0.1:20808</span><br></pre></td></tr></table></figure>
<p>仍然要开 <em>全局模式</em> 终端才能走代理。</p>
<p>虽然没有使用 HTTP 代理，但是很长一段时间我都没有关闭 <em>启用 HTTP 代理</em> 这个按钮，直到一天我连接手机热点 shadowsocks 闪退，我才关闭将其关闭了。这更显 Socks5 代理的优秀。</p>
<h2 id="今天"><a href="#今天" class="headerlink" title="今天"></a>今天</h2><p>当我重新安装 <a href="https://github.com/fatih/vim-go">vim-go</a>,并执行 <code>:GoUpdateBinaries</code> 故事又开始了。<br>显示类似于如下的一系列报错：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vim-go: Updating guru. Reinstalling golang.org&#x2F;x&#x2F;tools&#x2F;cmd&#x2F;guru@master to folder &#x2F;Users&#x2F;sweeney&#x2F;Documents&#x2F;code&#x2F;go&#x2F;bin</span><br><span class="line">vim-go: Error installing golang.org&#x2F;x&#x2F;tools&#x2F;cmd&#x2F;guru@master: go get golang.org&#x2F;x&#x2F;tools&#x2F;cmd&#x2F;guru@master: golang.org&#x2F;x&#x2F;tools&#x2F;cmd&#x2F;guru@master: invalid version: Get &quot;https:&#x2F;&#x2F;proxy.golang.org&#x2F;golang.org&#x2F;x&#x2F;tools&#x2F;cmd&#x2F;guru&#x2F;@v&#x2F;master.info&quot;: dial tcp 172.217.24.17:443: i&#x2F;o</span><br><span class="line">timeout</span><br></pre></td></tr></table></figure>
<p>首先我对 socks5 是很相信的，天生的认为其是较为底层的代理，应该不存在 HTTP 能代理而 Socks5 不能代理的情况。</p>
<p>“应该” 呵呵，所以我就耗了近一个半小时在这里。</p>
<p>以上问题其实和直接执行 <code>go get golang.org/x/tools/cmd/guru</code>，然后输出如下错误是一个道理。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">unrecognized import path &quot;golang.org&#x2F;x&#x2F;tools&#x2F;cmd&#x2F;guru&quot;: https fetch: Get &quot;https:&#x2F;&#x2F;golang.org&#x2F;x&#x2F;tools&#x2F;cmd&#x2F;guru?go-get&#x3D;1&quot;: dial tcp 216.239.37.1:443: i&#x2F;o timeout</span><br></pre></td></tr></table></figure>
<p>都是 go get 无法从 golang.org 下载包。</p>
<p>虽然 <code>curl golang.org</code> 能够访问这个网站，但是还是无法下载包。</p>
<h2 id="Socks5-vs-HTTP"><a href="#Socks5-vs-HTTP" class="headerlink" title="Socks5 vs HTTP"></a>Socks5 vs HTTP</h2><table>
<thead>
<tr>
<th></th>
<th align="center">HTTP Proxy</th>
<th align="center">Socks5 Proxy</th>
</tr>
</thead>
<tbody><tr>
<td>功能</td>
<td align="center">http 代理对于使用浏览器上网的用户很重要。</td>
<td align="center">并不使用 http 协议，是更通用，更低级别的代理。</td>
</tr>
<tr>
<td>安全</td>
<td align="center">被传输的数据极可能被查看。</td>
<td align="center">由于SOCKS无法读取数据，因此查看数据的几率很小。</td>
</tr>
<tr>
<td>速度</td>
<td align="center">速度较慢。</td>
<td align="center">通用服务器速度快。</td>
</tr>
<tr>
<td>连接工具</td>
<td align="center">任何工具。</td>
<td align="center">有限制工具。</td>
</tr>
<tr>
<td>建议</td>
<td align="center">传输少量数据。</td>
<td align="center">传输大体积的速度。</td>
</tr>
</tbody></table>
<p>SOCKS 作用在 OSI 模型的第四层 —— 会话层上。SOCKS4 只能代理TCP协议，而 SOCKS5 什么协议都可以代理。HTTP工作在应用层上，Socks代理只是简单地传递数据包，而不必关心是何种应用协议(比如 FTP、HTTP 和 NNTP 请求)，所以Socks代理服务器比应用层代理服务器要快得多。<br><img data-src="http://images.xyang.xin/2020-03%2Fnetwork.png" alt="network.png"></p>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">export ALL_PROXY=socks5://127.0.0.1:20808</span><br><span class="line">export http_proxy=socks5://127.0.0.1:20808</span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">alias</span> go=<span class="string">&#x27;http_proxy=socks5://127.0.0.1:20808 go&#x27;</span></span></span><br></pre></td></tr></table></figure>

<h2 id="遗留问题"><a href="#遗留问题" class="headerlink" title="遗留问题"></a>遗留问题</h2><p>我还是不知道为什么 ALL_PROXY 没对 go get 生效，而 http_proxy 生效了。并且经过测试，不是大小写的问题。</p>
<hr>
<p>参考文献：</p>
<ul>
<li><a href="https://dzone.com/articles/breaking-down-complex-differences-of-socks-vs-http">Breaking Down Differences Between SOCKS vs HTTP Proxy - DZone Security</a></li>
<li><a href="https://colobu.com/2017/01/26/how-to-go-get-behind-GFW/">如何在长城后面go get一些库 | 鸟窝</a></li>
<li><a href="http://www.yunlianip.com/News-getinfo-id-61.html">SOCKS5代理和HTTP代理有什么区别？-云连代理</a></li>
<li><a href="https://stackoverflow.com/questions/10383299/how-do-i-configure-go-command-to-use-a-proxy">How do I configure go command to use a proxy? - Stack Overflow</a></li>
</ul>
]]></content>
      <categories>
        <category>信息技术</category>
      </categories>
      <tags>
        <tag>代理</tag>
      </tags>
  </entry>
  <entry>
    <title>代理服务器</title>
    <url>/proxy-teach/</url>
    <content><![CDATA[<p>主要包含：shadowsocks-libev、kuptun 的配置和优化。基于亚马逊云学生机。</p>
<span id="more"></span>
<p>Docker 部署以及 安装v2ray-plugin 插件，请跳到最后。</p>
<h2 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h2><p><a href="https://www.emptyus.com/download.php">Shadowsocks X - A secure socks5 proxy</a><br><a href="https://github.com/shadowsocks">shadowsocks</a></p>
<p><a href="https://github.com/shadowsocks/ShadowsocksX-NG">shadowsocks/ShadowsocksX-NG: Next Generation of ShadowsocksX</a></p>
<h2 id="终端走代理"><a href="#终端走代理" class="headerlink" title="终端走代理"></a>终端走代理</h2><p>命令开启和关闭终端走代理：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">export</span> ALL_PROXY=socks5://127.0.0.1:20808</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">export</span> HTTP_PROXY=socks5://127.0.0.1:20808</span></span><br></pre></td></tr></table></figure>
<p>检测代理结果（全局模式）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ curl myip.ipip.net</span><br></pre></td></tr></table></figure>

<h2 id="服务器端"><a href="#服务器端" class="headerlink" title="服务器端"></a>服务器端</h2><p><a href="https://github.com/teddysun/shadowsocks_install/tree/master">teddysun/shadowsocks_install at master</a></p>
<h3 id="安装命令"><a href="#安装命令" class="headerlink" title="安装命令"></a>安装命令</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget --no-check-certificate -O shadowsocks-libev.sh https://raw.githubusercontent.com/teddysun/shadowsocks_install/master/shadowsocks-libev.sh</span><br><span class="line">chmod +x shadowsocks-libev.sh</span><br><span class="line">./shadowsocks-libev.sh 2&gt;&amp;1 | tee shadowsocks-libev.log</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Tip：脚本目前不支持 Centos8，为什么选择 libev 版本，因为其它版本停止维护了。</p>
</blockquote>
<p>加密算法推荐使用 <code>aes-256-gcm</code>。安装好后就可以通过下面的命令使用了：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ./shadowsocks-libev.sh uninstall   <span class="comment"># 卸载 SS</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> /etc/init.d/shadowsocks start      <span class="comment"># 启动 SS</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> /etc/init.d/shadowsocks stop       <span class="comment"># 停止 SS</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> /etc/init.d/shadowsocks restart    <span class="comment"># 重启 SS</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> /etc/init.d/shadowsocks status     <span class="comment"># 状态 SS</span></span></span><br></pre></td></tr></table></figure>

<p>要开机自启还是得自己动手：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> vim /usr/lib/systemd/system/shadowsocks_libev.service</span></span><br></pre></td></tr></table></figure>
<p>加入如下配置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description&#x3D;shadowsocks_libev</span><br><span class="line">Wants&#x3D;network.target</span><br><span class="line">After&#x3D;syslog.target network-online.target</span><br><span class="line">[Service]</span><br><span class="line">Type&#x3D;simple</span><br><span class="line">ExecStart&#x3D;</span><br><span class="line">ExecStart&#x3D;&#x2F;usr&#x2F;local&#x2F;bin&#x2F;ss-server -c &#x2F;etc&#x2F;shadowsocks-libev&#x2F;config.json</span><br><span class="line">Restart&#x3D;on-failure</span><br><span class="line">RestartSec&#x3D;10</span><br><span class="line">KillMode&#x3D;process</span><br><span class="line">LimitNOFILE&#x3D;65536</span><br><span class="line">[Install]</span><br><span class="line">WantedBy&#x3D;multi-user.target</span><br></pre></td></tr></table></figure>
<p>运行命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo systemctl daemon-reload</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo systemctl <span class="built_in">enable</span> shadowsocks_libev</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo systemctl start shadowsocks_libev</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo systemctl restart shadowsocks_libev</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo systemctl status shadowsocks_libev -l</span></span><br></pre></td></tr></table></figure>

<p>配置文件在这里：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ vim &#x2F;etc&#x2F;shadowsocks-libev&#x2F;config.json</span><br></pre></td></tr></table></figure>
<p>大多数来说脚本默认的配置就很好了，如果有异常的话就显式的运行程序来查看日志：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo /usr/<span class="built_in">local</span>/bin/ss-server</span></span><br></pre></td></tr></table></figure>
<h2 id="优化加速"><a href="#优化加速" class="headerlink" title="优化加速"></a>优化加速</h2><h3 id="服务器端加速"><a href="#服务器端加速" class="headerlink" title="服务器端加速"></a>服务器端加速</h3><p>从 4.9 开始，Linux 内核已经用上了该算法。通过以下命令检测主机是否开启 BBR：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">lsmod | grep bbr</span><br></pre></td></tr></table></figure>
<p>如果有返回值请跳过，如果没有，可通过以下步骤安装。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ sudo su</span><br><span class="line">$ wget --no-check-certificate https:&#x2F;&#x2F;github.com&#x2F;teddysun&#x2F;across&#x2F;raw&#x2F;master&#x2F;bbr.sh &amp;&amp; chmod +x bbr.sh &amp;&amp; .&#x2F;bbr.sh</span><br></pre></td></tr></table></figure>
<p>输入 <code>lsmod | grep bbr</code> ，出现 <code>tcp_bbr</code> 即说明 BBR 已经启动。</p>
<h3 id="双端加速"><a href="#双端加速" class="headerlink" title="双端加速"></a>双端加速</h3><p>服务器端安装：<br><a href="https://github.com/xtaci/kcptun">xtaci/kcptun</a><br>Kcptun 是一个非常简单和快速的，基于 KCP 协议的 UDP 隧道，它可以将 TCP 流转换为 KCP+UDP 流。它以比 TCP 浪费 10%-20% 的带宽的代价，和极少的资源占用，以达到降低多倍延迟的效果。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ sudo yum install golang -y</span><br><span class="line">$ git clone https:&#x2F;&#x2F;github.com&#x2F;xtaci&#x2F;kcptun.git</span><br><span class="line">$ cd kcptun</span><br><span class="line">$ .&#x2F;build-release.sh</span><br><span class="line">$ cd build</span><br><span class="line">&#x2F;&#x2F; 选择合适的版本</span><br><span class="line">$ sudo mv server_linux_amd64 &#x2F;usr&#x2F;local&#x2F;bin&#x2F;kcptun_server</span><br><span class="line">$ </span><br></pre></td></tr></table></figure>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">Wants=network.target</span><br></pre></td></tr></table></figure>

<p>建议在 <code>sysctl.conf</code> 中添加以下配置，优化 UDP 包的搬运速度：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo vim /etc/sysctl.conf</span></span><br></pre></td></tr></table></figure>
<p>写入以下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># KCP: for better handling of UDP packets</span><br><span class="line">net.core.rmem_max&#x3D;26214400 &#x2F;&#x2F; BDP - bandwidth delay product</span><br><span class="line">net.core.rmem_default&#x3D;26214400</span><br><span class="line">net.core.wmem_max&#x3D;26214400</span><br><span class="line">net.core.wmem_default&#x3D;26214400</span><br><span class="line">net.core.netdev_max_backlog&#x3D;2048 &#x2F;&#x2F; proportional to -rcvwnd</span><br></pre></td></tr></table></figure>
<p>运行以下命令生成配置：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo sysctl --system</span></span><br></pre></td></tr></table></figure>

<p><a href="https://wiki.archlinux.org/index.php/Sysctl#Enable_BBR">更多性能优化配置</a><br>在用户目录 <code>~</code> 创建 <code>kcptun.json</code> 配置文件如下：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;listen&quot;</span>: <span class="string">&quot;:4000&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;target&quot;</span>: <span class="string">&quot;127.0.0.1:14376&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;mode&quot;</span>: <span class="string">&quot;fast3&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;dscp&quot;</span>: <span class="number">46</span>,</span><br><span class="line">  <span class="attr">&quot;crypt&quot;</span>: <span class="string">&quot;salsa20&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;key&quot;</span>: <span class="string">&quot;1q2w3e4r.&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;sockbuf&quot;</span>:<span class="number">16777217</span>,</span><br><span class="line">  <span class="attr">&quot;nocomp&quot;</span>:<span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> vim /usr/lib/systemd/system/kcptun_server.service</span></span><br></pre></td></tr></table></figure>
<p>添加配置如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description&#x3D;kcptun</span><br><span class="line">Wants&#x3D;network.target</span><br><span class="line">After&#x3D;syslog.target network-online.target</span><br><span class="line">[Service]</span><br><span class="line">Type&#x3D;simple</span><br><span class="line">Environment&#x3D;GOGC&#x3D;20</span><br><span class="line">ExecStart&#x3D;</span><br><span class="line">ExecStart&#x3D;&#x2F;usr&#x2F;local&#x2F;bin&#x2F;kcptun_server -c &#x2F;home&#x2F;ec2-user&#x2F;kcptun.json</span><br><span class="line">Restart&#x3D;on-failure</span><br><span class="line">RestartSec&#x3D;10</span><br><span class="line">KillMode&#x3D;process</span><br><span class="line">LimitNOFILE&#x3D;65536</span><br><span class="line">[Install]</span><br><span class="line">WantedBy&#x3D;multi-user.target</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 设置开机自启</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo systemctl <span class="built_in">enable</span> kcptun_server</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 启动服务</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo systemctl restart kcptun_server</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看服务运行状态，测试是否配置成功</span></span><br><span class="line">sudo systemctl status kcptun_server  -l</span><br></pre></td></tr></table></figure>
<p>修改配置文件后，需要重新加载配置文件，然后重新启动相关服务</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ sudo systemctl daemon-reload</span><br><span class="line">$ sudo systemctl restart kcptun_server</span><br></pre></td></tr></table></figure>

<p>客户端 Kcptun 配置如图：<br><img data-src="http://images.xyang.xin/2020%2F06%2F03%2F1591188770.png" alt="1591188770.png"><br>Arguments:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-autoexpire 900 -sockbuf 16777217</span><br></pre></td></tr></table></figure>

<h2 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h2><p>通过上面的配置，目前而言使用效果不差。但是会不间断的出现“断流”，ssh 可以正常连接服务器，这是必然的。同样的情况出现在，相关业务商家都会提供不同地区的 N 多节点，但是同一时间可以正常使用的也就一两个。</p>
<p>我觉得最简单靠谱的就是，使用常用的端口如 443 或 80。</p>
<p>要开启 ipv6 的话，首先要保证服务器有 ipv6 的公网 ip，然后改一下 kcptun 和 ss 的配置：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"># config.json</span><br><span class="line">&quot;server&quot;:&quot;::&quot;,</span><br><span class="line"></span><br><span class="line"># kcptun.json</span><br><span class="line">&quot;listen&quot;: &quot;[::]:4000&quot;,</span><br><span class="line">&quot;target&quot;: &quot;[::]:443&quot;</span><br></pre></td></tr></table></figure>
<h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ lsmod | grep bbr                   # 状态 BBR</span><br><span class="line">$ sudo systemctl daemon-reload       # 重新加载 systemctl 配置文件</span><br><span class="line"></span><br><span class="line">$ .&#x2F;shadowsocks-libev.sh uninstall   # 卸载 SS</span><br><span class="line">$ &#x2F;etc&#x2F;init.d&#x2F;shadowsocks start      # 启动 SS</span><br><span class="line">$ &#x2F;etc&#x2F;init.d&#x2F;shadowsocks stop       # 停止 SS</span><br><span class="line">$ &#x2F;etc&#x2F;init.d&#x2F;shadowsocks restart    # 重启 SS</span><br><span class="line">$ &#x2F;etc&#x2F;init.d&#x2F;shadowsocks status     # 状态 SS</span><br><span class="line"></span><br><span class="line">$ sudo systemctl restart shadowsocks_libev</span><br><span class="line">$ sudo systemctl status shadowsocks_libev -l</span><br><span class="line"></span><br><span class="line">$ sudo systemctl restart kcptun_server # 启动 kcptun</span><br><span class="line">$ sudo systemctl status kcptun_server  -l # 查看 systemctl 服务运行状态</span><br></pre></td></tr></table></figure>

<h2 id="更多"><a href="#更多" class="headerlink" title="更多"></a>更多</h2><p>编辑 limits.conf 配置文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vim /etc/security/limits.conf</span><br></pre></td></tr></table></figure>
<p>添加下列两行：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">* soft nofile 51200</span><br><span class="line">* hard nofile 51200</span><br></pre></td></tr></table></figure>

<p>如果服务在root权限下运行，添加下列两行:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">root soft nofile 51200</span><br><span class="line">root hard nofile 51200</span><br></pre></td></tr></table></figure>

<p>在 bash 或 zsh 配置文件（例如：.zshrc）加入：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ulimit -n 51200</span><br></pre></td></tr></table></figure>

<h3 id="sysctl-conf"><a href="#sysctl-conf" class="headerlink" title="sysctl.conf"></a>sysctl.conf</h3><p>配置路径：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo vim /etc/sysctl.conf</span></span><br></pre></td></tr></table></figure>
<p>添加配置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fs.file-max &#x3D; 51200</span><br><span class="line"></span><br><span class="line">net.core.default_qdisc &#x3D; fq</span><br><span class="line">net.ipv4.tcp_congestion_control &#x3D; bbr</span><br><span class="line"></span><br><span class="line"># KCP: for better handling of UDP packets</span><br><span class="line">net.core.rmem_max&#x3D;26214400 &#x2F;&#x2F; BDP - bandwidth delay product</span><br><span class="line">net.core.rmem_default&#x3D;26214400</span><br><span class="line">net.core.wmem_max&#x3D;26214400</span><br><span class="line">net.core.wmem_default&#x3D;26214400</span><br><span class="line">net.core.netdev_max_backlog&#x3D;2048 &#x2F;&#x2F; proportional to -rcvwnd</span><br><span class="line">net.core.somaxconn &#x3D; 65535</span><br><span class="line"></span><br><span class="line">net.ipv4.tcp_keepalive_time &#x3D; 60</span><br><span class="line">net.ipv4.tcp_keepalive_intvl &#x3D; 10</span><br><span class="line">net.ipv4.tcp_keepalive_probes &#x3D; 6</span><br><span class="line">net.ipv4.tcp_mtu_probing &#x3D; 1</span><br><span class="line">net.ipv4.tcp_timestamps &#x3D; 0</span><br><span class="line">net.ipv4.tcp_fastopen &#x3D; 3</span><br><span class="line">net.ipv4.tcp_syncookies &#x3D; 1</span><br><span class="line">net.ipv4.tcp_fin_timeout &#x3D; 30</span><br><span class="line">net.ipv4.tcp_mem &#x3D; 25600 51200 102400</span><br><span class="line">net.ipv4.tcp_rmem &#x3D; 4096 87380 67108864</span><br><span class="line">net.ipv4.tcp_wmem &#x3D; 4096 65536 67108864</span><br><span class="line">net.ipv4.tcp_tw_reuse &#x3D; 0</span><br><span class="line">net.ipv4.tcp_tw_recycle &#x3D; 0</span><br><span class="line">net.ipv4.tcp_fin_timeout &#x3D; 30</span><br></pre></td></tr></table></figure>
<p>加载配置：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo sysctl --system</span></span><br></pre></td></tr></table></figure>

<p>使用 iperf 测试服务器的直接网速：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 服务端</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> iperf -s</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 客户端</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> iperf -c <span class="variable">$yourhost</span> -i 2 -t 30</span></span><br></pre></td></tr></table></figure>
<p>测速来平均服务器的网速有：<br>17.1 Mbits/sec</p>
<p>使用 fast.com 测试平均结果显示：<br>10 Mbits/sec</p>
<p>以下配置方案可能会更好：<br><a href="https://teddysun.com/569.html">使用 Docker 快速部署 Shadowsocks-libev + v2ray-plugin</a></p>
<p>技术无罪，谨守初心。</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul>
<li><a href="https://www.ruanyifeng.com/blog/2016/03/systemd-tutorial-part-two.html">Systemd 入门教程：实战篇 - 阮一峰的网络日志</a></li>
<li><a href="https://shadowsocks.org/en/config/advanced.html">Shadowsocks - Advanced</a></li>
<li><a href="https://bitsflow.org/network/tuning-tcp-performance/">优化TCP服务端</a></li>
</ul>
]]></content>
      <categories>
        <category>信息技术</category>
      </categories>
      <tags>
        <tag>代理</tag>
      </tags>
  </entry>
  <entry>
    <title>搜索引擎使用技巧</title>
    <url>/se-operators/</url>
    <content><![CDATA[<p><img data-src="http://images.xyang.xin/2020%2F05%2F29%2F1590724982.png?x-oss-process=style/title_800" alt="1590724982.png"></p>
<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>生活离不开搜索引擎了，我曾尝试在思考，是不是未来的开卷考试，会允许使用某个特定的搜索引擎。<span id="more"></span></p>
<p>什么是搜索引擎呢？搜索引擎就像一本不断更新的通讯录，它日夜不停的到处网罗手机号码及个人资料，也有一些”推销员“主动的向其提供自己的联系方式。人们通过这本通讯录可以快速的找到自己感兴趣的内容。</p>
<h2 id="常用的搜索方式"><a href="#常用的搜索方式" class="headerlink" title="常用的搜索方式"></a>常用的搜索方式</h2><p>如何使用搜索引擎？那和使用手机上的通讯录相差无几，通过姓名可以找到这个人的名片，包含手机号、地址、其他手机号；通过手机号，也可以找到这个人得名片，如果通讯录中有的话。</p>
<p>想要了解鱼香肉丝的做法，就输入 <code>鱼香肉丝</code>，我想要麻辣口味的鱼香肉丝呢，就输入 <code>鱼香肉丝 麻辣</code>。</p>
<p>通过以上方式——简单的关键字查询，对于大部分情况足矣。</p>
<p>在 Google 搜索引擎输入框输入：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">the world will be better 鱼香肉丝</span><br></pre></td></tr></table></figure>
<p>Then 回车：<br><img data-src="http://images.xyang.xin/2020%2F05%2F31%2F1590917944.png?x-oss-process=style/title_800" alt="1590917944.png"></p>
<p>点击红色框框里面的 <code>world</code>，输入框里的 <code>world</code> 机会被加上引号，代表搜索结果中必须包含 <code>world</code>（must include）。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">the &quot;world&quot; will be better 鱼香肉丝</span><br></pre></td></tr></table></figure>

<p>对，我也是一个“推销员”，所以我把我的联系方式提交给了通讯录，那我怎么知道通讯录里面有没有我呢？<code>site:blog.xyang.xin</code>。</p>
<p>这些就是我日常所使用到的搜索方法了。</p>
<h2 id="搜索优化"><a href="#搜索优化" class="headerlink" title="搜索优化"></a>搜索优化</h2><p>今天在 <a href="http://www.ruanyifeng.com/blog/2020/05/weekly-issue-109.html">新一期的科技爱好者周刊</a> 中看到：“<a href="https://quickref.dev/">Quickref</a> 一个针对程序员的搜索引擎，只搜索编程相关的网站。”出于好奇去看了一下：<br><img data-src="http://images.xyang.xin/2020%2F05%2F31%2F15909154253728.jpg?x-oss-process=style/title_800" alt="15909154253728.jpg"></p>
<p>首页有点不一样，多了一些内容：</p>
<ul>
<li>默认逐字搜索（搜索结果必须同时包含输入的所有关键字）；</li>
<li><code>~</code> 用于将关键字设置为可选（也就是搜索结果不必一定包含该关键字）；</li>
<li><code>-</code> 减号，排除该关键字（搜索结果不包含该关键字）；</li>
<li><code>site:</code> 仅针对某个特定网址进行搜索；</li>
<li><code>intitle:</code> 搜索结果仅显示网站标题包含关键字的内容；</li>
<li><code>*</code> 通配符；</li>
<li><code>!gh</code> 重定向到 Github 搜索；</li>
<li><code>!mdn</code> 重定向到 Mozilla MDN 搜索。</li>
</ul>
<p>为什么 Google、百度等搜索引擎都没有在首页给出类似的操作符 (Operators) 提示列表，或者显示一个链接到帮助文档？</p>
<p>我认为有如下原因：</p>
<ol>
<li>大多数情况下最基本的搜索方式就足够用了，不需要花费很多时间去进行额外的学习，我至今就仅仅使用了前文所阐述的几种搜索方法；</li>
<li>百度、Google 等搜索引擎作为通用软件，将 KISS(Keep it simple, stupid) 原则运用到极致，软件就是要用起来越简单越好。</li>
</ol>
<p>搜索引擎的核心价值无疑是拼尽全力把你最感兴趣的内容送到你的眼前，但是要懂一个人的心，在能读取你想法的机器研发出来之前，简直太难。所以为了让搜索引擎更懂我们，我认为进一步学习一些搜索引擎操作符是有必要的。Google 是我最常用的搜索引擎，百度有时也用，但下面介绍的操作符仅在 Google 上测试有效。</p>
<ul>
<li><code>@</code> 搜索社交媒体：<code>@twitter</code>；</li>
<li><code>-</code> 搜索结果不包含该关键字；</li>
<li><code>&quot;&quot;</code> 引号中的内容在搜索结果中必须完全匹配；</li>
<li><code>..</code> 在一定范围内搜索：<code>$50..$100</code>；</li>
<li><code>OR</code> 合并搜索，将两个搜索语句搜索到的内容合并起来显示：<code>site:nytimes.com OR @twitter</code>，搜索结果将同时显示 <code>site:nytimes.com</code> 搜索到的内容和 <code>@twitter</code> 搜索到的内容。需要 <code>AND</code> 吗？空格其实相当于 <code>AND</code>，需要 <code>NOT</code> 吗？<code>-</code> 相当于 <code>NOT</code>；</li>
<li><code>site:</code>,<code>site:youtube.com</code> 或者 <code>site:.gov</code>、<code>site:.edu</code>；</li>
<li><code>related:</code>，<code>related:google.com</code> 搜索结果就有 Yahoo、Bing、DuckDuckGo 等搜索引擎，可能因为其独特算法的原因，目前百度、Yandex 都没有，这个不好用，可能对美国本土网站支持比较好；</li>
<li><code>intext:</code> 搜索主体部分包含关键字的网页，<code>intext:&quot;仰望星空 埋头工作&quot;</code></li>
<li><code>allintext:</code> 搜索主体部分包含所有关键词的网页。<code>allintext: 鱼香肉丝 鳗鱼饭 威士忌 </code>；<br><img data-src="http://images.xyang.xin/2020%2F06%2F01%2F1591012218.png?x-oss-process=style/title_800?x-oss-process=style/title_800" alt="1591012218.png"></li>
<li><code>intitle</code> 搜索标题包含关键词的网页，<code>intitle:&quot;world peace&quot;</code>；</li>
<li><code>allintitle</code> 搜索标题包含所有关键词的网页；</li>
<li><code>inurl</code> 搜索 URL 包含关键词的网页，<code>inurl:plant</code>；</li>
<li><code>allinurl</code> 搜索 URL 中包含所有关键词的网页，<code>allinurl:plant growing</code>；</li>
<li><code>intext:</code> 搜索主体部分包含关键词的网页，<code>intext:grow</code>；</li>
<li><code>allintext:</code> 搜索主体部分包含所有关键词的网页，<code>allintext:pant growing</code>；</li>
<li><code>filetype:</code> 针对文件类型进行搜索，<code>filetype:doc</code><a href="https://support.google.com/webmasters/answer/35287?hl=en">Google 可索引的文件类型</a></li>
<li><code>imagesize:</code> 搜索指定尺寸的图片，<code>imagesize:500x400</code>，<a href="https://www.google.com/advanced_image_search">Google 高级图片搜索</a>；</li>
<li><code>inanchor:</code> 搜索 anchor 包含关键词的网页，什么是 anchor？<code>&lt;a src=&quot;https://blog.xyang.xin&quot;&gt;world peace&lt;/a&gt;</code>，这里的 <code>world peace</code> 就是 <code>anchor</code>，一个链接除开其既定的功能，例如可以点击进行跳转，还有就是其内容 <code>src</code> 里的 URL，以及 <code>&lt;a&gt;&lt;/a&gt;</code> 标签所包含 <code>anchor</code>；<br><img data-src="http://images.xyang.xin/2020%2F06%2F03%2F1591161153.png?x-oss-process=style/title_800" alt="1591161153.png"></li>
<li><code>allinanchor:</code> 搜索 anchor 包含所有关键词的网页，<code>allinanchor:world peace</code>；</li>
<li><code>cache:</code> 查看 Google 对相应网站的缓存情况，<code>cache:www.wikipedia.org</code>；</li>
<li><code>define:</code> 该操作符将展示一个关键词简明定义的信息卡，在信息卡下面是字典和其它在线参考的链接。<code>define:&quot;world peace&quot;</code> 和 <code>define: world peace</code> 搜索结果几乎一样；<br><img data-src="http://images.xyang.xin/2020%2F06%2F03%2F1591173332.png?x-oss-process=style/title_800" alt="1591173332.png"></li>
<li><code>stocks:</code>stocks（股市），搜索结果将显示与金融相关的内容，<code>stocks:dell</code> 与 <code>dell</code> 将得到不同的搜索结果；</li>
<li><code>wheather:</code> 查看特定地点的天气，<code>weather:beijing</code>；</li>
<li><code>map:</code> 查看特定地点的地图，<code>map: 北京 </code>；</li>
<li><code>in</code> 单位转换，常用的单位都有 <code>$329 in CNY</code>，<code>100cm in m</code>；</li>
<li><code>()</code> 对搜索语句进行分组。</li>
</ul>
<blockquote>
<p>Tip：</p>
<ol>
<li><p>Google 搜索通常会忽略不属于操作符的标点符号，英文大小写不影响搜索结果。不管加不加 <code>&quot;&quot;</code> 引号，标点符号和英文大小写都不影响搜索结果。</p>
</li>
<li><p>不要在操作符与搜索关键字之间留空格。<code>site:nytimes.com</code>，而不是 <code>site：nytimes.com</code>。</p>
</li>
<li><p>上述的关键词都包含关键词和关键句，简单理解不管词还是句都是字符串。<code>&quot;&quot;</code> 引号包含的内容为什么是完全匹配，因为搜索引擎将其整体视为一个字符串，并且它的另一层含义是必须包含。所以说 <code>intitle</code>、<code>intext</code> 如果搜索的内容是一个语句里面有空格的话，就必须用 <code>&quot;&quot;</code> 扩起来。</p>
</li>
<li><p>有些操作符可能因为更新而不可用，并且很难找到官方的更新说明，但是那些基本的应该不会被改变。</p>
</li>
</ol>
</blockquote>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul>
<li><a href="https://support.google.com/websearch/answer/2466433?hl=en">Refine web searches - Google Search Help</a></li>
<li><a href="https://builtmighty.com/blog/search-sites-google-site-search/">How to Search Any Website Using a Google Site Search | Built Mighty</a></li>
<li><a href="https://ahrefs.com/blog/google-advanced-search-operators/">Google Search Operators: The Complete List (42 Advanced Operators)</a></li>
<li>Stephan Spencer.《Google Power Search: The Essential Guide to Finding Anything Online With Google》.Second Edition.2017</li>
</ul>
]]></content>
      <categories>
        <category>信息技术</category>
      </categories>
      <tags>
        <tag>SE</tag>
        <tag>搜索引擎</tag>
        <tag>Google</tag>
      </tags>
  </entry>
  <entry>
    <title>Vim 自动补全之 YCM</title>
    <url>/shell-java/</url>
    <content><![CDATA[<p>IDEA 打开得太慢了，我需要一款轻量级的 IDE，不想装其他乱七八糟的编译器咋办？搞事情！</p>
<span id="more"></span>
<h2 id="sublime"><a href="#sublime" class="headerlink" title="sublime"></a>sublime</h2><p>sublime 通过简单的配置后可以实现 java 代码的高亮提示和编译功能，并且大多编译错误也能基本上精确到行。<br>然而 sublime 内置的终端无法输入，虽然在日常的算法中输入操作很少涉及，, 但还是很不爽。</p>
<h2 id="Vim"><a href="#Vim" class="headerlink" title="Vim"></a>Vim</h2><p>这里需要一定的 Vim 基础，新手请执行 <code>vimtutor</code> 查看 Vim 官方教程，再继续往后看。<br>在终端通过 java 命令即可实现 java 代码的编译与运行。<br>vim 不过起到的是编辑器的作用。<br>对于编辑器我们不仅有高亮的基本要求，同样也需要基本的代码补全功能, Vim 的 YCM 插件能较好的实现代码补全功能。<br>下面介绍通过 vim 的 vim-plug 插件管理器 来安装 YCM 。</p>
<h2 id="预备工作"><a href="#预备工作" class="headerlink" title="预备工作"></a>预备工作</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">xcode-select --install</span><br><span class="line">brew install cmake vim</span><br></pre></td></tr></table></figure>

<h2 id="vim-plug-安装"><a href="#vim-plug-安装" class="headerlink" title="vim-plug 安装"></a>vim-plug 安装</h2><p><a href="https://github.com/junegunn/vim-plug">junegunn/vim-plug</a></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl -fLo ~/.vim/autoload/plug.vim --create-dirs \</span><br><span class="line">    https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim</span><br></pre></td></tr></table></figure>
<h2 id="安装-YCM"><a href="#安装-YCM" class="headerlink" title="安装 YCM"></a>安装 YCM</h2><p><a href="https://github.com/Valloric/YouCompleteMe">YCM Github</a></p>
<h3 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h3><p>YCM 可通过 vim-plug 下载，而安装使用则需要进一步的编译。</p>
<p>在 .vimrc 文件中添加 <code>Plug &#39;Valloric/YouCompleteMe&#39; </code> 再执行 :PluginInstall 即可。</p>
<h3 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h3><p>YCM 基于 cmake 进行编译的，所以在安装之前如下命令先通过 brew 安装 cmake。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd ~&#x2F;.vim&#x2F;plugged&#x2F;YouCompleteMe</span><br><span class="line">python3 .&#x2F;install.py --java-completer</span><br></pre></td></tr></table></figure>
<p>请使用 python3 。</p>
<p>安装好之后，由于我的 python3 缺乏很多依赖性，通过以下命令检验 python 所缺乏的依赖。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd ~&#x2F;.vim&#x2F;plugged&#x2F;YouCompleteMe&#x2F;third_party&#x2F;ycmd</span><br><span class="line">cp ycmd&#x2F;default_settings.json . &amp; python3 ycmd --options_file default_settings.json</span><br></pre></td></tr></table></figure>
<p>如果输出如下，是 python 环境的问题考虑重启然后重装：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[1]    8629 segmentation fault  python3 ycmd --options_file default_settings.json</span><br></pre></td></tr></table></figure>
<p>若有如下报错：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ModuleNotFoundError: No module named &#39;bottle&#39;</span><br><span class="line">ModuleNotFoundError: No module named &#39;waitress&#39;</span><br></pre></td></tr></table></figure>
<p>逐句执行 <code>pip3 install bottle</code> <code>pip3 install waitress</code>即可解决。<br>如果显示是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">No module named &#39;ycm_core&#39;</span><br></pre></td></tr></table></figure>
<p>是没有问题的</p>
<h2 id="YCM-安装-C-family-的自动补全"><a href="#YCM-安装-C-family-的自动补全" class="headerlink" title="YCM 安装 C-family 的自动补全"></a>YCM 安装 C-family 的自动补全</h2><h3 id="编译安装"><a href="#编译安装" class="headerlink" title="编译安装"></a>编译安装</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd ~&#x2F;.vim&#x2F;plugged&#x2F;YouCompleteMe</span><br><span class="line">python3 .&#x2F;install.py --clang-completer</span><br></pre></td></tr></table></figure>
<h3 id="安装-ycm-gennerator"><a href="#安装-ycm-gennerator" class="headerlink" title="安装 ycm-gennerator"></a>安装 ycm-gennerator</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Plugin &#39;rdnetto&#x2F;YCM-Generator&#39;</span><br></pre></td></tr></table></figure>
<h3 id="生成-ycm-extra-conf-py-文件到-YCM-中"><a href="#生成-ycm-extra-conf-py-文件到-YCM-中" class="headerlink" title="生成 .ycm_extra_conf.py 文件到 YCM 中"></a>生成 .ycm_extra_conf.py 文件到 YCM 中</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python3 .ycm_extra_conf.py ~&#x2F;.vim&#x2F;plugged&#x2F;YouCompleteMe&#x2F;third_party&#x2F;ycmd</span><br></pre></td></tr></table></figure>
<h3 id="在-vimrc-中添加"><a href="#在-vimrc-中添加" class="headerlink" title="在 ~/.vimrc 中添加"></a>在 ~/.vimrc 中添加</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let g:ycm_global_ycm_extra_conf &#x3D; &#39;～&#x2F;.vim&#x2F;plugged&#x2F;YouCompleteMe&#x2F;third_party&#x2F;ycmd&#x2F;.ycm_extra_conf.py&#39;</span><br></pre></td></tr></table></figure>

<h2 id="go-语言"><a href="#go-语言" class="headerlink" title="go 语言"></a>go 语言</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd ~/.vim/plugged/YouCompleteMe</span><br><span class="line">python3 ./install.py --go-completer</span><br></pre></td></tr></table></figure>

<h2 id="其他语言参数"><a href="#其他语言参数" class="headerlink" title="其他语言参数"></a>其他语言参数</h2><ul>
<li>C family support: <code>python3 ./install.py --clang-completer</code></li>
<li>C# support: <code>python3 ./install.py --cs-completer </code>（install Mono with Homebrew or by downloading the <a href="http://www.mono-project.com/docs/getting-started/install/mac/">Mono macOS package</a> ）</li>
<li>Go support: <code>python3 ./install.py --go-completer</code> </li>
<li>JavaScript and TypeScript support: <code>python3 ./install.py --ts-completer</code> </li>
<li>Rust support: <code>python3 ./install.py --rust-completer</code></li>
<li>Java support: <code>python3 ./install.py --java-completer</code></li>
</ul>
<h2 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">:PlugUpdate</span><br></pre></td></tr></table></figure>
<p>或</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd ~&#x2F;.vim&#x2F;plugged&#x2F;YouCompleteMe</span><br><span class="line">git clean -f</span><br><span class="line">git pull</span><br><span class="line">git submodule update --recursive --init</span><br><span class="line">.&#x2F;install.py --go-completer</span><br></pre></td></tr></table></figure>

<h2 id="错误解决"><a href="#错误解决" class="headerlink" title="错误解决"></a>错误解决</h2><p>升级 catalina 后 brew 安装的 python3 执行异常，解决方案如下：<br><a href="https://forums.developer.apple.com/thread/119429">My application crashed with invalid load of lib… |Apple Developer Forums</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;zsh</span><br><span class="line">brew update &amp; brew upgrade &amp; brew install openssl</span><br><span class="line">cd &#x2F;usr&#x2F;local&#x2F;Cellar&#x2F;openssl&#x2F;1.0.2t&#x2F;lib</span><br><span class="line">sudo cp libssl.1.0.0.dylib libcrypto.1.0.0.dylib &#x2F;usr&#x2F;local&#x2F;lib&#x2F;</span><br><span class="line">cd &#x2F;usr&#x2F;local&#x2F;lib</span><br><span class="line">mv libssl.dylib libssl_bak.dylib</span><br><span class="line">mv libcrypto.dylib libcrypto_bak.dylib</span><br><span class="line">sudo ln -s libssl.1.0.0.dylib libssl.dylib</span><br><span class="line">sudo ln -s libcrypto.1.0.0.dylib libcrypto.dylib</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>信息技术</category>
      </categories>
      <tags>
        <tag>开发工具</tag>
      </tags>
  </entry>
  <entry>
    <title>程序中的 “脚手架”</title>
    <url>/scaffold/</url>
    <content><![CDATA[<blockquote>
<p>百度百科: 脚手架是为了保证各施工过程顺利进行而搭设的工作平台。</p>
</blockquote>
<h2 id="脚手架概念"><a href="#脚手架概念" class="headerlink" title="脚手架概念"></a>脚手架概念</h2><p>编程领域中的“脚手架（Scaffolding）”指的是能够快速搭建项目“骨架”的一类工具。在新建项目时，你不得不手动创建固定的文件目录，繁琐而累赘。脚手架的作用就是帮助你完成这些重复性的工作，包括一键生成主要的目录结构、安装依赖等等。</p>
<span id="more"></span>

<h2 id="React-脚手架"><a href="#React-脚手架" class="headerlink" title="React 脚手架"></a>React 脚手架</h2><ul>
<li><a href="https://github.com/facebook/create-react-app">facebook/create-react-app</a></li>
<li>go 语言框架 beego 的脚手架 bee（go get github.com/beego/bee）</li>
</ul>
]]></content>
      <categories>
        <category>信息技术</category>
      </categories>
      <tags>
        <tag>信息技术</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 剪贴板小技巧</title>
    <url>/ssh-clipboard-iterm2/</url>
    <content><![CDATA[<h2 id="初步识-vim-剪贴板"><a href="#初步识-vim-剪贴板" class="headerlink" title="初步识 vim 剪贴板"></a>初步识 vim 剪贴板</h2><p>对于文本的复制粘贴，系统会提供剪贴板，剪贴板在 vim 中被称为寄存器，并且 vim 有很多寄存器，寄存器使用的语法：<code>&quot;&#123;register&#125;</code>，当然了寄存器指令不会单独使用，后面都会跟代表复制的 <code>y</code> 或代表粘贴的 <code>p</code>，执行 <code>&quot;ay</code> 就将选中的内容复制到了 <code>a</code> 寄存器，<span id="more"></span>寄存器都是有自己的名字的，感兴趣的同学，欲知详细内容请参见帮助文档：<code>:help registers</code>。</p>
<p>那咱们平时执行 <code>yy</code> 或者选中 <code>y</code> 使用的寄存器叫什么名字呢？它叫匿名寄存器 (<code>&quot;&quot;</code>)。<code>y</code> 就等于 <code>&quot;&quot;y</code>。</p>
<p>比较重要的是，系统剪贴板寄存器 <code>&quot;*</code>。通过 <code>&quot;*p</code> 就可以把系统剪贴板上的内容粘贴到 vim 文件内了。</p>
<p><code>*p</code> 从系统剪贴板粘贴容易，而要从 vim 复制到系统剪贴板，首先选中文本，然后执行 <code>&quot;*y</code>，这多麻烦，所以我选择：</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="comment">&quot; .vimrc</span></span><br><span class="line"><span class="keyword">set</span> clipboard=unnamed</span><br></pre></td></tr></table></figure>
<p>这样就让系统剪贴板 (<code>&quot;*</code>) 和匿名剪贴板 (<code>&quot;&quot;</code>) 内容保持同步了。<code>y</code> 就同时等效于 <code>&quot;&quot;y</code> 、 <code>&quot;*y</code> ，而 <code>p</code> 等价于 <code>&quot;&quot;p</code>、<code>&quot;*p</code> 以及 <code>command+v</code> 或者 Windows 的 <code>ctrl+v</code>。</p>
<h2 id="远程剪贴板操作"><a href="#远程剪贴板操作" class="headerlink" title="远程剪贴板操作"></a>远程剪贴板操作</h2><p>通过 SSH 连接到了一台远程 Linux 服务器，这时候该任何复制粘贴呢？</p>
<p>Someone said at once: “Stupid! Mac 上当然是鼠标选中然后 <code>command+c</code>、<code>command+v</code> 了，Windows 上是 <code>ctrl+c</code>、<code>ctrl+v</code>，虽然 <code>ctrl+v</code> 会和 vim 切换成可视模式冲突，但是我用 <code>ctrl+shift+v</code> 就解决了。”</p>
<p>这方法很便捷，并且我也经常使用，但是在使用过程中主要遇到以下两个问题：</p>
<ol>
<li>如果你的 vim 开启了行号，鼠标选中多行的时候，会选中行号，复制下来的内容也会也行号。我的 vim 是默认开启行号的。</li>
<li>只能复制一个窗口大小的内容。</li>
</ol>
<p>其实还有一个问题，就是不能完全脱离鼠标，我是三分之二键盘党，所以我认为这不是主要问题。</p>
<p>这些问题不是都已经解决了吗？如果设置了 <code>set clipboard=unnamed</code>，直接选中（注意不是鼠标选中，而是 vim 中的选中 <code>shift+v</code> 上下键）然后 <code>y</code>，然后 <code>p</code>。那你试试 <code>command+v</code> 或 <code>ctrl+v</code> 呢？保证不是你刚刚复制的内容。</p>
<p>短路了吧？重新认识一下，你现在同时使用了两个系统，一个是本地，一个是远程服务器，<code>y</code> 复制的内容在远程服务器上呢，还在你公司，在杭州，在北京，还是在海外呢？</p>
<p>那我不用 <code>command+v</code> 可好，有 <code>p</code>，还少按一个键。</p>
<p>漂亮！你已经找到答案了。</p>
<h3 id="剪贴板远程传送"><a href="#剪贴板远程传送" class="headerlink" title="剪贴板远程传送"></a>剪贴板远程传送</h3><p>那如果我想将远程服务器的一段字符传送到本地呢？有人说 <strong>scp</strong>，但在实际操作中，通过 <strong>scp</strong> 或者 <strong>ftp</strong>，传送文件还 ok，传送一段文本的即时性就太差了。</p>
<p>找到两种比较好的办法，但是针对的客户端是 Mac 或者 Linux，据了解 Windows 自带有 Linux 子系统，可以开启试试。</p>
<p>方法一：</p>
<blockquote>
<p>该方法使用了一个叫 <strong>clipper</strong> 的 <strong>go</strong> 语言程序，以及 <strong>vim-clipper</strong> 插件，两个项目的链接都在下面。但是我没有用过这种方式，一方面配置较多，而且要在本地跑额外的程序，可能功能比较强大但是我用不了这么多，另一方面就是有第二种比较适合我的方式。</p>
</blockquote>
<ul>
<li><a href="https://github.com/wincent/clipper">wincent/clipper: ✂️ Clipboard access for local and remote tmux sessions</a></li>
<li><a href="https://github.com/wincent/vim-clipper">wincent/vim-clipper: Clipper integration for Vim</a></li>
</ul>
<p>For Mac User:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> brew install clipper</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> brew services start clipper</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ssh -R localhost:8377:localhost:8377 user@host.example.org</span></span><br></pre></td></tr></table></figure>

<p>For Linux User:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> yum install golang</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">clone</span> git://git.wincent.com/clipper.git</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> clipper</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> go build</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo cp clipper /usr/<span class="built_in">local</span>/bin</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> cp contrib/linux/systemd-service/clipper.service ~/.config/systemd/user</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> systemctl --user daemon-reload</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> systemctl --user <span class="built_in">enable</span> clipper.service</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> systemctl --user start clipper.service</span></span><br></pre></td></tr></table></figure>

<p>方法二：<br>该方式，仅适合使用 <strong>Mac</strong> 及 <strong>iTerm.app</strong> 的用户。</p>
<p><code>iTerm-&gt;Perferences-&gt; Selection-&gt;Application in terminal may access clipboard</code>（选择开启），可能版本更新这个功能的位置会有所变动。</p>
<p>在远程服务器执行如下命令(如果使用的是<strong>bash</strong>将<strong>zsh</strong>改为<strong>bash</strong>即可)：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ cd</span><br><span class="line">$ curl -L https:&#x2F;&#x2F;iterm2.com&#x2F;shell_integration&#x2F;install_shell_integration_and_utilities.sh | zsh</span><br></pre></td></tr></table></figure>
<p>命令下载<code>.iterm2_shell_integration.zsh</code>脚本到用户根目录，还有一些小程序到<code>~/.iterm2</code>目录下，<br>并在<code>.zshrc</code>末尾生成<code>test -e &quot;$&#123;HOME&#125;/.iterm2_shell_integration.zsh&quot; &amp;&amp; source &quot;$&#123;HOME&#125;/.iterm2_shell_integration.zsh&quot; </code><br>卸载的时候也只需要将这三个部分删除掉即可。</p>
<p>在vim配置文件<code>.vimrc</code>下添加如下代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if !empty(&#39;~&#x2F;.iterm2&#x2F;it2copy&#39;)</span><br><span class="line">  vmap &lt;silent&gt; &lt;Leader&gt;y :&#39;&lt;,&#39;&gt;:w !~&#x2F;.iterm2&#x2F;it2copy&lt;CR&gt;&lt;CR&gt;</span><br><span class="line">endif</span><br></pre></td></tr></table></figure>

<p>此时<code>shift+v</code>选中文本，执行 <code>&lt;leader&gt;y</code>，文本就到你本地的剪贴板啦。不信你就<code>command+v</code>。</p>
]]></content>
      <categories>
        <category>信息技术</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>剪贴板</tag>
        <tag>Vim</tag>
      </tags>
  </entry>
  <entry>
    <title>SSM 错误集锦</title>
    <url>/ssm-Error/</url>
    <content><![CDATA[<ol>
<li>class path resource [spring/] cannot be resolved to URL because it does not exist</li>
</ol>
<ul>
<li>条件：这是非编译情况下利用mvn的插件war:war生成war包，运行后所报的错误。</li>
<li>原因：未将resources下的配置文件引入war包中。</li>
<li>解决方法：先执行代码，再生成war包。<span id="more"></span></li>
</ul>
<ol start="2">
<li>check the manual that corresponds to your MySQL server version for the right syntax to use near … , The error may involve .insert-Inline</li>
</ol>
<ul>
<li>原因：mysql 向数据库插入数据时错误， 可能触及到mysql的保留字，例如 key。</li>
<li>解决办法： 插入语句不能起别名，该方式不可取。加键盘左上角的撇号，例<code>key</code>。</li>
</ul>
<ol start="3">
<li><p>java.lang.Double cannot be cast to java.lang.String<br>list中查出来个别数据是 double，转换为 String。<br>String periodTime = String.valueOf(list.get(0));</p>
</li>
<li><p>Error running ‘tomcat’: Can’t find catalina.jar</p>
</li>
</ol>
<ul>
<li>原因：tomcat 升级导致路径改变</li>
<li>解决办法：Idea 在 Edit Configuration 中修改 tomcat 路径至 libexec</li>
</ul>
]]></content>
      <categories>
        <category>信息技术</category>
      </categories>
      <tags>
        <tag>ssm</tag>
      </tags>
  </entry>
  <entry>
    <title>SSM 问题集锦</title>
    <url>/ssm-question/</url>
    <content><![CDATA[<h1 id="SSM-问题集锦"><a href="#SSM-问题集锦" class="headerlink" title="SSM 问题集锦"></a>SSM 问题集锦</h1><h2 id="SSM-基础的搭建过程"><a href="#SSM-基础的搭建过程" class="headerlink" title="SSM 基础的搭建过程"></a>SSM 基础的搭建过程</h2><p><a href="https://blog.csdn.net/yangxinyujy/article/details/80656771">IntelliJ IDEA 创建 Maven 管理下的 SSM 项目基础全过程</a><br><a href="https://github.com/yangxinyujy/ssmdemo">yangxinyujy/ssmdemo: ssm 基础框架</a></p>
<span id="more"></span>

<h2 id="Tomcat-部署时-war-和-war-exploded-区别"><a href="#Tomcat-部署时-war-和-war-exploded-区别" class="headerlink" title="Tomcat 部署时 war 和 war exploded 区别"></a>Tomcat 部署时 war 和 war exploded 区别</h2><p>war 模式：将WEB工程以包的形式上传到服务器，可以称之为是发布模式，这是先打成 war 包，再发布；<br>war exploded模式：将 WEB 工程以当前文件夹的位置关系上传到服务器，通过直接把文件夹、jsp 页面 、classes 等,移到 Tomcat 部署文件夹里面的方式，进行加载部署。因此这种方式支持热部署，一般在开发的时候也是用这种方式。</p>
]]></content>
      <categories>
        <category>信息技术</category>
      </categories>
      <tags>
        <tag>ssm</tag>
      </tags>
  </entry>
  <entry>
    <title>Vim8 操作简记</title>
    <url>/vim-manipulate/</url>
    <content><![CDATA[<p>Normal 模式是 Vim 默认打开状态。我们可以通过 Normal 模式，任何其它模式，我们可以在 Normal 模式下对文本进行浏览、排版、修改。Normal 模式在 Vim 中具有举足轻重的作用。</p>
<p>在 Normal 模式下，除了基本的移动指令 (j、k、h、l)、插入指令 (i、a)、撤销指令 (u、U) 等。Vim 通过 “操作符 + 运作命令 = 操作”（出自《Vim 实用技巧 第 2 版》） 扩展出了大量的操作指令。</p>
<span id="more"></span>
<p>指令、操作、操作指令都是，由人向计算机输入指令，计算机就会返回程序预设的结果。不过操作给我的感觉更像动词，所以后面我用指令来代替他。如上述等式所言指令由两部分组成，即 operator 和 motion，用前者指定行为，后者指定作用范围。还有一些只能在 Visual 模式或 operator 后面使用的叫：text object selection，文本对象选择器。</p>
<p>有一条额外的规则，即当一个操作符命令被连续调用两次时候，它会作用于当前行。如：<code>dd</code> 删除当前行；<code>yy</code> 复制当前行；<code>&gt;&gt;</code> 缩进当前行；<code>gUgU</code> 将当前行转换为大写，可以简写为 <code>gUU</code>。</p>
<h2 id="常用指令"><a href="#常用指令" class="headerlink" title="常用指令"></a>常用指令</h2><h3 id="Characterwise-motions"><a href="#Characterwise-motions" class="headerlink" title="Characterwise motions"></a>Characterwise motions</h3><ul>
<li>dl 向右删除一个字符<ul>
<li>d (delete)</li>
<li>l ( 右移一个字符，和 left 没有关系，键位好按）</li>
<li>一般用 x 代替</li>
</ul>
</li>
<li>dh 向左删除一个字符<ul>
<li>h ( 左移一个字符）</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li>dw 向右删除至下一个单词的开头<ul>
<li>w (words forward)</li>
<li>W 大写表示只使用空格作为分隔</li>
</ul>
</li>
<li>de 向左删除至单词的末尾，如果本身处于单词末尾，那么删除至下一个单词末尾<ul>
<li>e (Forward to the end of word)</li>
<li>E 大写表示只使用空格作为分隔</li>
</ul>
</li>
<li>dge 向左删除至上一个单词的末尾<ul>
<li>ge (Backward to the end of word)</li>
<li>gE 大写表示只使用空格作为分隔</li>
</ul>
</li>
<li>db 向右删除至单词的开头，如果本身处于单词开头，那么删除至上一个单词的开头<ul>
<li>b (words backward)</li>
<li>B 大写表示只使用空格作为分隔</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li>dd 删除当前行</li>
<li>d^ 删除光标之前的内容至空白字符处 (non-blank character)</li>
<li>d0 删除光标之前的内容</li>
<li><del>dg_ 删除光标之后的内容至空白字符处</del></li>
<li>d$ 删除光标及光标之后的内容</li>
</ul>
<h3 id="Linewise-motions"><a href="#Linewise-motions" class="headerlink" title="Linewise motions"></a>Linewise motions</h3><ul>
<li>dj 删除本行及下一行</li>
<li>dk 删除本行及上一行 </li>
<li>dG 删除至文章末尾<ul>
<li>G (Goto line，默认最后一行）</li>
</ul>
</li>
<li>dgg 删除至文章开头<ul>
<li>gg（Goto line，默认最后一行）</li>
</ul>
</li>
<li>ggdG (删除整篇文章内容)<br>使用 <code>gg*G</code> 对整篇文章进行操作比较麻烦，安装插件可以更加便捷：<br><a href="https://github.com/kana/vim-textobj-entire">kana/vim-textobj-entire</a><br>执行 <code>dae</code> 就可以达到和执行 <code>ggdG</code> 一样的效果。</li>
</ul>
<h3 id="Text-object-selection"><a href="#Text-object-selection" class="headerlink" title="Text object selection"></a>Text object selection</h3><ul>
<li>daw 删除一个单词<ul>
<li>aw (a word)</li>
<li>2daw 或 d2aw 将忽略空格，删除两个单词</li>
<li>aW</li>
</ul>
</li>
<li>diw 删除一个单词<ul>
<li>iw (inner word)</li>
<li>2diw 或 d2iw 包含空格，即删除一个单词和空格</li>
<li>iW</li>
</ul>
</li>
<li>das 删除一个句子及后面的空白（没对中文句子进行支持）</li>
<li><del>dis 删除一个句子</del></li>
<li>dap 删除一个段落<ul>
<li>ap（a paragraph）</li>
</ul>
</li>
<li><del>dip 删除一个段落</del></li>
<li>da]、da[ 删除 [] 块内容，包含 []</li>
<li>di]、di[ 删除 [] 块内容，不含 []</li>
<li>da)、da(、dab</li>
<li>di)、di(、dib</li>
<li>da&gt;、da&lt;</li>
<li>di&gt;、di&lt;</li>
<li>dat 删除标签块，例如<aa></aa>，包含<aa></aa></li>
<li>dit</li>
<li>da}、da{、daB</li>
<li>di}、di{、diB</li>
<li>da”</li>
<li>di”</li>
<li>da’</li>
<li>di’</li>
<li>da`</li>
<li>di`</li>
</ul>
<h3 id="Operators"><a href="#Operators" class="headerlink" title="Operators"></a>Operators</h3><ul>
<li>c change</li>
<li>d delete</li>
<li>y 复制到寄存器</li>
<li>g~ 反转文本大小写）</li>
<li>gU 转换为大写</li>
<li>gu 转换为小写</li>
</ul>
<blockquote>
<p>Tips:<br>我们可以发现 Operator 操作符是不能单独使用的。</p>
<p>在 motions 或者组合指令前面加 n，可以达到执行 n 次的效果，例如：<code>2daw</code>，将删除两个单词，然后使用 <code>u</code> 可以一次性撤销。也可以在执行 <code>daw</code> 后使用 <code>.</code> 操作符，达到一样的效果，这需要执行 <code>u</code> 两次才能完全撤销。 </p>
<p>word 和 WORD 的区别在于，word 可以由：<code>spaces</code>,<code>tabs</code>,<code>&lt;EOL&gt;</code> 分隔，而 WORD 仅使用 spaces 作为分隔。相同之处在于：它们都是由字母、数字和下划线或其他非空字符序列组成。而在中文中的表现却有所不同：将连续的纯汉字视为一个“单词”。</p>
<p>文本对象选择器中的 i 和 a 的区别在于：i 选择没有 space 的文本对象，而 a 包含 space。</p>
<p>对中文句子不那么友好的情况，因此 <code>. </code> 英文句号加空格来判断一个句子的结尾，</p>
<p>我在感觉没啥用的部分加了删除线。</p>
</blockquote>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul>
<li><a href="https://vimhelp.org/">Vim: help.txt</a></li>
<li>《Vim 实用技巧 (第 2 版)》</li>
</ul>
]]></content>
      <categories>
        <category>信息技术</category>
      </categories>
      <tags>
        <tag>Vim</tag>
      </tags>
  </entry>
  <entry>
    <title>vim-fugitive ——【一天一个 vim 插件】</title>
    <url>/vim-plugin-everday-2/</url>
    <content><![CDATA[<p>作为一个 10k+ star 的 vim 插件，<a href="https://github.com/tpope/vim-fugitive">tpope/vim-fugitive</a> 自称为 Git 的第一 Vim 插件并不为过。Fugitive 让你在当前 buffer 缓冲区通过<code>:Git</code>或<code>:G</code>，可以直接使用 git 命令。可以看作是<code>!git XX</code> 命令的改进和优化，除了使用 silent，静默模式外，你不会看到 “Press ENTER or type command to continue”，还对一些命令进行了优化。</p>
<span id="more"></span>

<h2 id="温故"><a href="#温故" class="headerlink" title="温故"></a>温故</h2><p>回顾一下上一个插件 vim-gitgutter 的使用方法：</p>
<ul>
<li><code>[c</code> 和 <code>]c</code> 在有所变动的区块间跳转。</li>
<li><leader>hp，显示预览，hunk preview</li>
<li><leader>hs，暂存代码块，hunk stage</li>
<li><leader>hu，撤销更改，hunk undo</li>
<li><leader>hd，禁用 gitgutter</li>
<li><leader>he，启用 gitgutter</li>
</ul>
<h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><ul>
<li>所有命令都以<code>:G</code>或<code>:Git</code>打头，两种写法等价。</li>
<li><code>:G -p &#123;args&#125;</code><ul>
<li>运行任意 git 命令都可以加上，-p，这样将捕获输出到一个临时文件，并且对临时文件执行<code>:split</code>水平分割。如果使用<code>:0G -p &#123;args&#125;</code>，将用<code>:edit</code>代替。通常用于 diff 和 log 这个指令。</li>
<li>例：<code>:G -p diff</code>,<code>:G --paginate diff</code></li>
</ul>
</li>
<li><code>G</code><ul>
<li>不带参数，会打开一个类似于 git-status 的简要窗口，在窗口中，使用 <code>g?</code> 将打开 fugitive-maps 快捷键映射帮助。</li>
</ul>
</li>
<li><code>G push</code><ul>
<li>执行 <code>git push</code></li>
</ul>
</li>
<li><code>GBrowse</code></li>
</ul>
<hr>
<p>待续：<br>由于我的很多 git 知识还不够完善，后面补充了再续写。<br>更多内容参见<code>:help fugitive</code></p>
]]></content>
      <categories>
        <category>信息技术</category>
      </categories>
      <tags>
        <tag>vim</tag>
        <tag>一天一个 vim 插件</tag>
      </tags>
  </entry>
  <entry>
    <title>React-Vim 开发环境</title>
    <url>/vim-react/</url>
    <content><![CDATA[<h2 id="实现功能"><a href="#实现功能" class="headerlink" title="实现功能"></a>实现功能</h2><ol>
<li>react 代码高亮、自动补全。</li>
<li>执行<code>./node_modules/.bin/eslint --fix src/App.js</code> 即可对App.js 进行代码错误检测和格式化。</li>
<li>变更代码自动对代码进行格式化。<span id="more"></span>

</li>
</ol>
<h2 id="换源"><a href="#换源" class="headerlink" title="换源"></a>换源</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm config set registry=http://registry.npmjs.org</span><br><span class="line">npm config set disturl https://npm.taobao.org/dist</span><br></pre></td></tr></table></figure>

<h2 id="插件安装"><a href="#插件安装" class="headerlink" title="插件安装"></a>插件安装</h2><p>建议使用 vim-plug 包管理器（<a href="https://blog.xyang.xin/shell-java/#sublime">安装方式</a>）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vim ~.&#x2F;vimrc</span><br></pre></td></tr></table></figure>

<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span> nu!               <span class="comment">&quot; 显示行号</span></span><br><span class="line"><span class="keyword">set</span> hls               <span class="comment">&quot; 寻找时匹配高亮显示</span></span><br><span class="line"><span class="keyword">syntax</span> <span class="keyword">on</span>             <span class="comment">&quot; 语法高亮</span></span><br><span class="line"><span class="keyword">set</span> background=dark</span><br><span class="line"><span class="keyword">colorscheme</span> solarized</span><br><span class="line"><span class="keyword">set</span> <span class="built_in">shiftwidth</span>=<span class="number">2</span>      <span class="comment">&quot; 设置格式化时代码缩进为2个空格</span></span><br><span class="line"><span class="keyword">set</span> tabstop=<span class="number">2</span>         <span class="comment">&quot; tab键缩进为4格子</span></span><br><span class="line"><span class="keyword">set</span> expandtab         <span class="comment">&quot; tab键转换为空格</span></span><br><span class="line"><span class="keyword">set</span> incsearch         <span class="comment">&quot; 很聪明的查找,输入一个字符马上自动匹配,而不是输入完再查找</span></span><br><span class="line"><span class="keyword">set</span> ignorecase        <span class="comment">&quot; 搜索时大小写不敏感</span></span><br><span class="line"><span class="keyword">set</span> wildmenu          <span class="comment">&quot; vim 自身命令行模式智能补全</span></span><br><span class="line"><span class="keyword">set</span> <span class="keyword">ts</span>=<span class="number">4</span>              <span class="comment">&quot; 设置 tab 键为四个空格</span></span><br><span class="line"><span class="keyword">set</span> <span class="built_in">cindent</span>           <span class="comment">&quot; 设置自动缩近</span></span><br><span class="line"><span class="keyword">set</span> <span class="built_in">shiftwidth</span>=<span class="number">4</span>      <span class="comment">&quot; 设置每一级缩进长度为4</span></span><br><span class="line"><span class="keyword">set</span> nocompatible      <span class="comment">&quot; 自动补全</span></span><br><span class="line"><span class="keyword">set</span> backspace=<span class="number">2</span>       <span class="comment">&quot; 解决不能删除的问题</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">call</span> plug#begin(<span class="string">&#x27;~/.vim/plugged&#x27;</span>)</span><br><span class="line"><span class="comment">&quot; react 插件</span></span><br><span class="line">Plug <span class="string">&#x27;pangloss/vim-javascript&#x27;</span></span><br><span class="line">Plug <span class="string">&#x27;mxw/vim-jsx&#x27;</span></span><br><span class="line">Plug <span class="string">&#x27;mattn/emmet-vim&#x27;</span></span><br><span class="line">Plug <span class="string">&#x27;w0rp/ale&#x27;</span></span><br><span class="line">Plug <span class="string">&#x27;skywind3000/asyncrun.vim&#x27;</span></span><br><span class="line"><span class="keyword">call</span> plug#end()</span><br><span class="line"></span><br><span class="line"> <span class="comment">&quot; emmet-vim</span></span><br><span class="line"> <span class="keyword">let</span> <span class="variable">g:user_emmet_leader_key</span>=<span class="string">&#x27;&lt;C-e&gt;&#x27;</span></span><br><span class="line"> <span class="keyword">let</span> <span class="variable">g:user_emmet_jsx</span> = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&quot; react 自动格式化</span></span><br><span class="line"><span class="keyword">autocmd</span> BufWritePost *.js AsyncRun -post=<span class="keyword">checktime</span> ./node_modules/.bin/eslint --<span class="keyword">fix</span> %</span><br></pre></td></tr></table></figure>

<h2 id="依赖安装"><a href="#依赖安装" class="headerlink" title="依赖安装"></a>依赖安装</h2><p>以 create-react-app 为例</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npx create-react-app create-react-app</span><br><span class="line">cd create-react-app</span><br><span class="line">./node_modules/.bin/eslint --init</span><br><span class="line"><span class="meta">#</span><span class="bash"> Use a popular style guide ——&gt; Airbnb ——&gt; y ——&gt; JavaScript ——&gt; n</span></span><br><span class="line">npm install --save--dev eslint-config-airbnb</span><br><span class="line">或：</span><br><span class="line">yarn add --dev eslint-config-airbnb</span><br></pre></td></tr></table></figure>

<h2 id="修改-eslintrc-js-配置"><a href="#修改-eslintrc-js-配置" class="headerlink" title="修改 .eslintrc.js 配置"></a>修改 .eslintrc.js 配置</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vim .eslintrc.js</span><br></pre></td></tr></table></figure>

<p>覆盖原文本如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    <span class="string">&quot;root&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="string">&quot;parserOptions&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;parser&quot;</span>: <span class="string">&#x27;babel-eslint&#x27;</span>,</span><br><span class="line">         <span class="string">&quot;sourceType&quot;</span>: <span class="string">&#x27;module&#x27;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">&quot;extends&quot;</span>: [</span><br><span class="line">        <span class="string">&quot;eslint:recommended&quot;</span>,</span><br><span class="line">        <span class="string">&quot;plugin:react/recommended&quot;</span>,</span><br><span class="line">        <span class="string">&quot;eslint-config-airbnb&quot;</span>,</span><br><span class="line">    ],</span><br><span class="line">    <span class="string">&quot;plugins&quot;</span>: [</span><br><span class="line">        <span class="string">&quot;react&quot;</span>,</span><br><span class="line">    ],</span><br><span class="line">    <span class="string">&quot;rules&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;react/jsx-filename-extension&quot;</span>: [<span class="number">1</span>, &#123; <span class="string">&quot;extensions&quot;</span>: [<span class="string">&quot;.js&quot;</span>, <span class="string">&quot;.jsx&quot;</span>] &#125;],</span><br><span class="line">        <span class="string">&quot;react/prefer-stateless-function&quot;</span>: <span class="string">&quot;off&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h2><p><a href="https://drivy.engineering/setting-up-vim-for-react/">Setting up Vim for React development | Drivy Engineering</a><br><a href="https://blog.xcatliu.com/2017/08/25/eslint-config-alloy/">我花了两个月时间，定制出了心目中「完美」的 ESLint 规则，我用四个空格缩进 - 流浪小猫的博客</a></p>
]]></content>
      <categories>
        <category>信息技术</category>
      </categories>
      <tags>
        <tag>vim</tag>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title>vim 多文件类型自动补全方案</title>
    <url>/vim-multiple-filetype-deoplete/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>多文件类型也可以叫混合文件类型(multiple filetype), 比如 HTML 里面写 CSS, JS 代码，虽然不提倡，但偶尔也有这个需求。</p>
<p>根据常识，我们知道，往往针对不同的文本类型，vim 或其插件，会出发不同的事件，例如特定的语法高亮、特定的语法检测、特定的自动补全方案等。<br>几乎每个 vim user 的 vimrc 中都会有如下配置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">filetype plugin indent on</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<p>其中的 filetype on 表示：</p>
<blockquote>
<p>每次一个新的或者已经存在的文件被编辑时，Vim 会试图识别文件的类型，并设置’filetype’ 选项。同时，也触发 FileType 事件。该事件可以设置语法高亮，特定选项，等等。———— 出自 《vim 参考手册》，译者: Willis、tocer</p>
</blockquote>
<p>那么是否能直接通过修改文件的 filetype 值实现多文件类型的自动补全呢？ 答案是否定的，因为这将引起语法检测，语法高亮等一系列的变化，这是我们所不能接受的。</p>
<p>github 上已经有人大致实现了这个功能，主要通过 <code>deoplete.nvim</code> 和 <code>context_filetype.vim</code>两个插件。都是一个作者写的，前者提供一个可扩展的 vim 自动补全框架，后者支持前者实现多文件类型自动补全。</p>
<h2 id="实际操作"><a href="#实际操作" class="headerlink" title="实际操作"></a>实际操作</h2><p>修改 <code>.vimrc</code> 文件如下：<br>（下面提供的插件安装方式都是基于 <code>vim-plug</code> 的。不要再用 <code>vundle</code> 了，因为它目前不支持多线程，下载插件很慢。）</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="built_in">has</span>(<span class="string">&#x27;nvim&#x27;</span>)</span><br><span class="line">  Plug <span class="string">&#x27;Shougo/deoplete.nvim&#x27;</span>, &#123; <span class="string">&#x27;do&#x27;</span>: <span class="string">&#x27;:UpdateRemotePlugins&#x27;</span> &#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  Plug <span class="string">&#x27;Shougo/deoplete.nvim&#x27;</span></span><br><span class="line">  Plug <span class="string">&#x27;roxma/nvim-yarp&#x27;</span></span><br><span class="line">  Plug <span class="string">&#x27;roxma/vim-hug-neovim-rpc&#x27;</span></span><br><span class="line"><span class="keyword">endif</span></span><br><span class="line"></span><br><span class="line">Plug <span class="string">&#x27;Shougo/context_filetype.vim&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&quot; context_filetype.vim 插件的配置</span></span><br><span class="line"><span class="keyword">if</span> !exists(<span class="string">&#x27;g:context_filetype#same_filetypes&#x27;</span>)</span><br><span class="line">  <span class="keyword">let</span> <span class="variable">g:context_filetype</span>#filetypes = &#123;&#125;</span><br><span class="line"><span class="keyword">endif</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:context_filetype</span>#filetypes.svelte = [</span><br><span class="line">\ &#123;<span class="string">&#x27;filetype&#x27;</span> :<span class="string">&#x27;javascript&#x27;</span>, <span class="string">&#x27;start&#x27;</span>: <span class="string">&#x27;&lt;script&gt;&#x27;</span>, <span class="string">&#x27;end&#x27;</span>: <span class="string">&#x27;&lt;/script&gt;&#x27;</span>&#125;,</span><br><span class="line">\ &#123;<span class="string">&#x27;filetype&#x27;</span> :<span class="string">&#x27;css&#x27;</span>, <span class="string">&#x27;start&#x27;</span>: <span class="string">&#x27;&lt;style&gt;&#x27;</span>, <span class="string">&#x27;end&#x27;</span>: <span class="string">&#x27;&lt;/style&gt;&#x27;</span>&#125;,</span><br><span class="line">\ ]</span><br><span class="line"></span><br><span class="line"><span class="comment">&quot; deoplete.nvim 插件的配置</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:deoplete</span>#enable_at_startup = <span class="number">1</span></span><br><span class="line"><span class="keyword">autocmd</span> InsertLeave,CompleteDone * <span class="keyword">if</span> <span class="built_in">pumvisible</span>() == <span class="number">0</span> | <span class="keyword">pclose</span> | <span class="keyword">endif</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">call</span> deoplete#custom#var(<span class="string">&#x27;omni&#x27;</span>, <span class="string">&#x27;functions&#x27;</span>, &#123;</span><br><span class="line">\ <span class="string">&#x27;css&#x27;</span>: [<span class="string">&#x27;csscomplete#CompleteCSS&#x27;</span>],</span><br><span class="line">\ <span class="string">&#x27;javascript&#x27;</span>: [<span class="string">&#x27;javascriptcomplete#CompleteJS&#x27;</span>],</span><br><span class="line">\ <span class="string">&#x27;html&#x27;</span>: [<span class="string">&#x27;htmlcomplete#CompleteTags&#x27;</span>],</span><br><span class="line">\&#125;)</span><br><span class="line"><span class="keyword">call</span> deoplete#custom#var(<span class="string">&#x27;omni&#x27;</span>, <span class="string">&#x27;input_patterns&#x27;</span>, &#123;</span><br><span class="line">\ <span class="string">&#x27;javascript&#x27;</span>: <span class="string">&#x27;[^. *\t]\.\w*&#x27;</span>,</span><br><span class="line">\ &#125;)</span><br><span class="line"><span class="comment">&quot; 支持 &lt;tab&gt;</span></span><br><span class="line"><span class="keyword">inoremap</span> <span class="symbol">&lt;silent&gt;</span><span class="symbol">&lt;expr&gt;</span> <span class="symbol">&lt;TAB&gt;</span> <span class="built_in">pumvisible</span>() ? <span class="string">&quot;\&lt;C-n&gt;&quot;</span> :</span><br><span class="line">\ <span class="symbol">&lt;SID&gt;</span>check_back_space() ? <span class="string">&quot;\&lt;TAB&gt;&quot;</span> :</span><br><span class="line">\ deoplete#mappings#manual_complete()</span><br><span class="line"><span class="function"><span class="keyword">function</span>! <span class="title">s</span>:<span class="title">check_back_space</span><span class="params">()</span> <span class="title">abort</span> &quot;&#123;&#123;&#123;</span></span><br><span class="line">  <span class="keyword">let</span> <span class="keyword">col</span> = <span class="keyword">col</span>(<span class="string">&#x27;.&#x27;</span>) - <span class="number">1</span></span><br><span class="line">  <span class="keyword">return</span> !col || <span class="built_in">getline</span>(<span class="string">&#x27;.&#x27;</span>)[<span class="keyword">col</span> - <span class="number">1</span>]  =~ <span class="string">&#x27;\s&#x27;</span></span><br><span class="line"><span class="keyword">endfunction</span><span class="comment">&quot;&#125;&#125;&#125;</span></span><br></pre></td></tr></table></figure>
<p>执行 :PlugInstall</p>
<h2 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h2><p>作为一个 <code>vimscript</code> 还没入门的新手，看了大半天代码，了解如下：</p>
<p><code>context_filetype.vim</code> 插件，通过 <code>context_filetype#get()</code> 入口函数在光标处于<code>&lt;style&gt; &lt;/style&gt;</code>范围内时，返回如下格式的字典：</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">&#123;<span class="string">&#x27;range&#x27;</span>: [[<span class="number">9</span>, <span class="number">1</span>], [<span class="number">12</span>, <span class="number">4</span>]], <span class="string">&#x27;filetype&#x27;</span>: <span class="string">&#x27;css&#x27;</span>&#125;</span><br></pre></td></tr></table></figure>
<p>该字典含义为 {范围：[ 标签起始位置，标签结束位置 ]，文件类型 }</p>
<p>但是我没有明白 <code>deoplete.nvim</code> 是如何使用这个接口的。</p>
<p>作者让我看 <a href="https://github.com/Shougo/deoplete.nvim/blob/master/rplugin/python3/deoplete/context.py">context.py</a> 这段代码，我只能弱弱的回复一个”Thanks”。</p>
]]></content>
      <categories>
        <category>信息技术</category>
      </categories>
      <tags>
        <tag>vim</tag>
        <tag>multiple filetype</tag>
      </tags>
  </entry>
  <entry>
    <title>vim-gitgutter ——【一天一个 vim 插件】</title>
    <url>/vim-plugin-everday-1/</url>
    <content><![CDATA[<p><img data-src="http://images.xyang.xin/2020%2F06%2F28%2Fscreenshot.png?x-oss-process=style/title_800" alt="screenshot.png"><br>在此截图你可以看见：</p>
<ul>
<li>183-184 行是新建的；</li>
<li>186-187 行有所变动；</li>
<li>在底部的预览区中显示改动情况（<leader>hp）。<br>(<a href="https://github.com/airblade/vim-gitgutter">出处</a>)<br><a href="https://github.com/airblade/vim-gitgutter">airblade/vim-gitgutter</a> </li>
</ul>
<p>在 vim 标志栏（sign column，行号左边的一列，通常为隐藏状态）中显示 git diff（git 差异）</p>
<span id="more"></span>

<p>这个系列主要以记住各类有用的 vim 插件的功能与使用方法为目的。</p>
<h2 id="安装配置"><a href="#安装配置" class="headerlink" title="安装配置"></a>安装配置</h2><p>安装插件的方法，一般分为常规安装与插件管理器安装。常规安装将插件整个放入目录：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">~&#x2F;.vim&#x2F;pack&#x2F;vendor&#x2F;start</span><br></pre></td></tr></table></figure>
<p>而插件管理器安装有相似的语法，却各不相同。插件管理器安装有一定的性能亏损，但是如果有大量插件存在的情况下，没有插件管理器，将难以管理。</p>
<p>系列目前选择 <a href="https://github.com/junegunn/vim-plug">junegunn/vim-plug</a> 插件管理器作为插件的安装方式。全程使用<code>xterm-256color</code>，没有使用<code>gui</code>。</p>
<p>在 <code>.vimrc</code> 中写入并保存：</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="built_in">empty</span>(<span class="built_in">glob</span>(<span class="string">&#x27;~/.vim/autoload/plug.vim&#x27;</span>))</span><br><span class="line">    <span class="keyword">silent</span> !curl -fLo ~/.<span class="keyword">vim</span>/autoload/plug.<span class="keyword">vim</span> --create-dirs</span><br><span class="line">                \ http<span class="variable">s:</span>//raw.githubusercontent.<span class="keyword">com</span>/junegunn/<span class="keyword">vim</span>-plug/master/plug.<span class="keyword">vim</span></span><br><span class="line">    <span class="keyword">au</span> VimEnter * PlugInstall --<span class="keyword">sync</span> | <span class="keyword">source</span> $MYVIMRC</span><br><span class="line"><span class="keyword">endif</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">call</span> plug#begin(<span class="string">&#x27;~/.vim/plugged&#x27;</span>)</span><br><span class="line">Plug <span class="string">&#x27;airblade/vim-gitgutter&#x27;</span></span><br><span class="line"><span class="keyword">call</span> plug#end()</span><br></pre></td></tr></table></figure>
<p>重新用 Vim 打开一个文件，执行命令：<code>:PlugInstall</code>，好了 <code>vim-plug</code> 插件管理器 和 <code>vim-gitgutter</code> 插件都安装好了。</p>
<p>标志栏背景颜色显示很丑的话，我的默认显示灰色，添加如下设置以改善：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">highlight SignColumn ctermbg&#x3D;NONE</span><br></pre></td></tr></table></figure>

<p>当修改文件后，标志栏会自动刷新，而刷新的延迟决定于vim的updatetime，默认的是4000ms，建议修改如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">updatetime&#x3D;100</span><br></pre></td></tr></table></figure>
<h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><p>通过 <code>[c</code> 和 <code>]c</code> 在有所变动的区块间跳转。<br><leader>hp，显示预览，hunk preview<br><leader>hs，暂存代码块，hunk stage<br><leader>hu，撤销更改，hunk undo</p>
<p>以上是默认的映射，可以自行修改如下：</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="keyword">nmap</span> ]h <span class="symbol">&lt;Plug&gt;</span>(GitGutterNextHunk)</span><br><span class="line"><span class="keyword">nmap</span> [h <span class="symbol">&lt;Plug&gt;</span>(GitGutterPrevHunk)</span><br><span class="line"><span class="keyword">nmap</span> <span class="symbol">&lt;leader&gt;</span>hp <span class="symbol">&lt;Plug&gt;</span>(GitGutterPreviewHunk)</span><br><span class="line"><span class="keyword">nmap</span> <span class="symbol">&lt;leader&gt;</span>hs <span class="symbol">&lt;Plug&gt;</span>(GitGutterStageHunk)</span><br><span class="line"><span class="keyword">nmap</span> <span class="symbol">&lt;leader&gt;</span>hu <span class="symbol">&lt;Plug&gt;</span>(GitGutterUndoHunk)</span><br></pre></td></tr></table></figure>

<p>You can explicitly turn vim-gitgutter off and on (defaults to on):</p>
<p>如果在某个git项目下，不想看见这个标志栏的提示，可以使用下面的命令：</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">:GitGutterDisable</span><br><span class="line">:GitGutterEnable</span><br><span class="line"></span><br><span class="line">:GitGutterBufferDisable</span><br><span class="line">:GitGutterBufferEnable</span><br></pre></td></tr></table></figure>
<p>绑定快捷键，例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nmap &lt;leader&gt;hd :GitGutterDisable&lt;CR&gt;</span><br><span class="line">nmap &lt;leader&gt;he :GitGutterEnable&lt;CR&gt;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>信息技术</category>
      </categories>
      <tags>
        <tag>vim</tag>
        <tag>一天一个 vim 插件</tag>
      </tags>
  </entry>
</search>
