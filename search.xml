<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>阿里云 ECS 使用</title>
    <url>/ECS/</url>
    <content><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p><a href="https://www.alibabacloud.com/help/zh/doc-detail/25367.htm?spm=a2c63.p38356.b99.2.615e1bbcsZH9Ry">阿里云官方文档</a></p>
<span id="more"></span>

<h2 id="远程连接服务器常用的几种方式"><a href="#远程连接服务器常用的几种方式" class="headerlink" title="远程连接服务器常用的几种方式"></a>远程连接服务器常用的几种方式</h2><p>SSH —— 远程<br>SFTF —— 文件传输，22端口</p>
<h2 id="安全组"><a href="#安全组" class="headerlink" title="安全组"></a>安全组</h2><h2 id="设置公网入方向-——-即允许具有指定-IP-的主机访问服务器的哪个端口"><a href="#设置公网入方向-——-即允许具有指定-IP-的主机访问服务器的哪个端口" class="headerlink" title="设置公网入方向 —— 即允许具有指定 IP 的主机访问服务器的哪个端口"></a>设置公网入方向 —— 即允许具有指定 IP 的主机访问服务器的哪个端口</h2><ol>
<li>设置端口范围 22/22 协议类型自定义TCP 授权对象公网ip，22端口常用于ssh连接。</li>
<li>设置端口范围 80/80 协议类型自定义TCP 授权对象0.0.0.0/0。<br>允许所有人通过 http 访问你的服务器。<br>80 端口常用于 http 协议访问 web 网站。相对应的 443 端口用于 https 协议访问 web 网站。3306 端口常用于数据库远程连接。出于安全考虑：如果向所有人打开 22 端口和 3306 端口，应当确保密码的复杂程度，以防强行爆破。对于新手建议将 22 端口和 3306 端口设置为仅允许指定IP访问。</li>
</ol>
<h2 id="设置公网出方向-——-服务器出口的限制"><a href="#设置公网出方向-——-服务器出口的限制" class="headerlink" title="设置公网出方向 —— 服务器出口的限制"></a>设置公网出方向 —— 服务器出口的限制</h2><p>没有特殊需求不需要设置。</p>
]]></content>
      <categories>
        <category>信息技术</category>
      </categories>
      <tags>
        <tag>云服务</tag>
      </tags>
  </entry>
  <entry>
    <title>目标和关键成果法 (Objectives and Key Results)</title>
    <url>/OKRs/</url>
    <content><![CDATA[<blockquote>
<p>The Objective is the direction.<br>The key results have to be measured.<br>Yes.No.Simple</p>
</blockquote>
<h1 id="Why"><a href="#Why" class="headerlink" title="Why"></a>Why</h1><p>Being took to the wrong objectives is unacceptable.<br>被带向错误的目标是让人无法接受的。</p>
<span id="more"></span>

<p>Truly transformational teams combine their ambitions to their passion and to their purpose，and they develop a clear and compelling sense of why.<br>真正变革型的团队都会将自己的雄心、热情和目标结合到一起，他们很清楚为何要做，且理由令人信服。</p>
<h1 id="Objective"><a href="#Objective" class="headerlink" title="Objective"></a>Objective</h1><p>Significant (重要)<br>Concrete （具体）<br>Action-oriented （以行动为导向）<br>Inspirational （激励人心）</p>
<p>If the heart doesn’t find a perfect rhyme with the head, then your passion means nothing.<br>如果内心找不到与大脑和谐的韵律，你的热情就毫无用处。</p>
<h1 id="Good-key-results"><a href="#Good-key-results" class="headerlink" title="Good key results"></a>Good key results</h1><p>Specific &amp; Time-bound（明确、有时间限制）<br>Aggressive Yet Realistic（激进、现实）<br>Measurable &amp; Verifiable (可衡量、可评估)</p>
<h1 id="Why-1"><a href="#Why-1" class="headerlink" title="Why"></a>Why</h1><p>OKRs as transparent vessels, that are made from the whats and hows of our ambitions. What really matters is the why that we pour into those vessels. Thats’s why we do our work.<br> OKRS 可以看做是一个透明的容器，它由野心勃勃的“做什么”和“怎么做”构成。 真正的关键在于放进容器中的“为什么” 那是我们工作的原因。</p>
<h1 id="Write-down-your"><a href="#Write-down-your" class="headerlink" title="Write down your"></a>Write down your</h1><p>Values (the right metrics)<br>Objectives<br>Key results</p>
]]></content>
      <categories>
        <category>思想文化</category>
      </categories>
      <tags>
        <tag>方法</tag>
      </tags>
  </entry>
  <entry>
    <title>用 acme.sh 从 Let&#39;s Encrypt 免费获取持续的 SSL 证书支持</title>
    <url>/acme-sh/</url>
    <content><![CDATA[<h2 id="acme-sh-简介"><a href="#acme-sh-简介" class="headerlink" title="acme.sh 简介"></a>acme.sh 简介</h2><p>acme.sh 简化了 Let’s Encrypt 官方的证书签发过程。<br>目前主要有如下两类 Let’s Encrypt 证书的签发方式：</p>
<ul>
<li>http 认证方式</li>
<li>dns 方式<span id="more"></span>

</li>
</ul>
<p>http 需要 80 端口的贯通。<br>dns 方式不适用于所有的解析商，对域名的管理需要较高的权限。</p>
<p><a href="https://github.com/Neilpang/acme.sh/wiki/%E8%AF%B4%E6%98%8E">github 安装说明</a></p>
<h2 id="acme-sh-实际问题解决"><a href="#acme-sh-实际问题解决" class="headerlink" title="acme.sh 实际问题解决"></a>acme.sh 实际问题解决</h2><p>案例介绍：<br>一台 gentoo 服务器中仅对外网开放 80 和 443 端口，而当前的 80 端口使用 haproxy 代理。<br>最终解决方案：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">acme.sh --issue -d XXXX --standalone --pre-hook &quot;killall haproxy&quot; --post-hook &quot;/usr/local/haproxy/start.sh&quot; --force</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>信息技术</category>
      </categories>
      <tags>
        <tag>ssl</tag>
        <tag>acme.sh</tag>
        <tag>letsencrypt</tag>
      </tags>
  </entry>
  <entry>
    <title>《厉害了我的国》(2018)讲述纲要</title>
    <url>/amazing-china/</url>
    <content><![CDATA[<h1 id="《厉害了我的国》-2018-讲述纲要"><a href="#《厉害了我的国》-2018-讲述纲要" class="headerlink" title="《厉害了我的国》(2018)讲述纲要"></a>《厉害了我的国》(2018)讲述纲要</h1><blockquote>
<p>导演: 卫铁<br>类型: 纪录片<br>制片国家/地区: 中国大陆<br>语言: 汉语普通话<br>上映日期: 2018-03-02(中国大陆)<br>片长: 90分钟<br>又名: Amazing China</p>
</blockquote>
<span id="more"></span>

<blockquote>
<p>《厉害了，我的国》，以《辉煌中国》为基础素材制作的纪录电影。《辉煌中国》8个摄制组历时3个月，走遍全国31个省区市，拍摄了近3200个小时的高清纪实素材、300多个小时的航拍素材，采访了108位人物，记录下众多珍贵的历史瞬间。内容采用“内容众筹”的创新方式，搭建创作平台，面向全国征集五年来百姓眼中的成就故事、百姓身边的巨大变化，由百姓自己讲述精彩“中国故事”，众筹案例线索、照片、短视频等逾万条</p>
</blockquote>
<h2 id="基础设施建设，中国制造，创新引擎"><a href="#基础设施建设，中国制造，创新引擎" class="headerlink" title="基础设施建设，中国制造，创新引擎"></a>基础设施建设，中国制造，创新引擎</h2><h3 id="大国工程，交通运输业"><a href="#大国工程，交通运输业" class="headerlink" title="大国工程，交通运输业"></a>大国工程，交通运输业</h3><p>中国桥–港珠澳大桥<br>中国车–高铁<br>中国港口–智能码头<br>中国船</p>
<h3 id="中国资源调配"><a href="#中国资源调配" class="headerlink" title="中国资源调配"></a>中国资源调配</h3><p>南水北调<br>西气东输二线<br>世界级特高压工程<br>信息资源–网络强国</p>
<h2 id="自主创新"><a href="#自主创新" class="headerlink" title="自主创新"></a>自主创新</h2><h3 id="2017-05-05-大飞机梦"><a href="#2017-05-05-大飞机梦" class="headerlink" title="2017.05.05 大飞机梦"></a>2017.05.05 大飞机梦</h3><p>自主研发大飞机航电系统集成</p>
<h3 id="自主制造海上钻井平台"><a href="#自主制造海上钻井平台" class="headerlink" title="自主制造海上钻井平台"></a>自主制造海上钻井平台</h3><h3 id="深海探测"><a href="#深海探测" class="headerlink" title="深海探测"></a>深海探测</h3><p>蛟龙号<br>中国深潜器</p>
<h3 id="太空探测"><a href="#太空探测" class="headerlink" title="太空探测"></a>太空探测</h3><p>FAST射电望远镜（中国天眼）<br>嫦娥三号<br>量子卫星“墨子号”–量子通信<br>天宫二号–空间实验室</p>
<h3 id="创新型青年人才"><a href="#创新型青年人才" class="headerlink" title="创新型青年人才"></a>创新型青年人才</h3><p>国家创新活力<br>科技发展希望</p>
<h2 id="我国社会主要矛盾已经转化为人民日益增长的美好生活需要和不平衡不充分的发展之间的矛盾"><a href="#我国社会主要矛盾已经转化为人民日益增长的美好生活需要和不平衡不充分的发展之间的矛盾" class="headerlink" title="我国社会主要矛盾已经转化为人民日益增长的美好生活需要和不平衡不充分的发展之间的矛盾"></a>我国社会主要矛盾已经转化为人民日益增长的美好生活需要和不平衡不充分的发展之间的矛盾</h2><h3 id="缩减贫富差异"><a href="#缩减贫富差异" class="headerlink" title="缩减贫富差异"></a>缩减贫富差异</h3><p>精准扶贫<br>号召企业家向贫困地域发展<br>城乡一体化</p>
<h3 id="生态平衡"><a href="#生态平衡" class="headerlink" title="生态平衡"></a>生态平衡</h3><p>新能源 光伏发电 风电 核电站<br>污染治理，退耕还林还草工程</p>
<h3 id="教育平衡"><a href="#教育平衡" class="headerlink" title="教育平衡"></a>教育平衡</h3><p>乡村教师队伍支持计划<br>免费午餐</p>
<h3 id="文化建设"><a href="#文化建设" class="headerlink" title="文化建设"></a>文化建设</h3><p>传统文化与时代精神<br>中华民族价值追求</p>
<h3 id="医疗"><a href="#医疗" class="headerlink" title="医疗"></a>医疗</h3><p>家庭医生签约服务制度全覆盖</p>
<h3 id="养老"><a href="#养老" class="headerlink" title="养老"></a>养老</h3><h3 id="公共安全–保障小康的隐形卫视"><a href="#公共安全–保障小康的隐形卫视" class="headerlink" title="公共安全–保障小康的隐形卫视"></a>公共安全–保障小康的隐形卫视</h3><h3 id="国家安全-军事"><a href="#国家安全-军事" class="headerlink" title="国家安全-军事"></a>国家安全-军事</h3><h3 id="对外开放"><a href="#对外开放" class="headerlink" title="对外开放"></a>对外开放</h3><p>40年改革开放成就今日中国位于世界前列的国际地位<br>开着门，世界能够进入中国，中国也才能走向世界<br>一带一路<br>中欧经济联系紧密<br>桃李不言，下自成蹊  经济大融合 发展大联动 成功大共享<br>带动非洲繁荣<br>中国对外开放的追求–既要让自己过得好也要让别人过的好<br>建立人类命运共同体</p>
]]></content>
      <categories>
        <category>思想文化</category>
      </categories>
      <tags>
        <tag>中国</tag>
      </tags>
  </entry>
  <entry>
    <title>《一本小小的红色写作书》读书笔记</title>
    <url>/book-hsxzs/</url>
    <content><![CDATA[<p><img data-src="http://images.xyang.xin/2019-05%2F1558180143.png?x-oss-process=style/title_140" alt="1558180143.png-w140"></p>
<span id="more"></span>
<p><img data-src="http://images.xyang.xin/2019-07%2F%E4%B8%80%E6%9C%AC%E5%B0%8F%E5%B0%8F%E7%9A%84%E7%BA%A2%E8%89%B2%E5%86%99%E4%BD%9C%E4%B9%A6.png" alt="一本小小的红色写作书.png"></p>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>图中对《一本小小的红色写作书》的脉络要点进行总结，用于写作中的参考。（图谱内容较多，建议保存后浏览）</p>
<h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><ol>
<li><p>引导句<br> 在一篇个人随笔中，这句话可以作为引导语，放在文章的最开头：<br>我将通过详述个人和职业生涯的三个特殊的转折点，来呈现我是个什么样的人：凭借曲棍球奖学金上大学时期、与维和部队共同度过的一年、入职伦敦一家商贸企业期间。</p>
<p> 在商务报告中，以下句子可以作为引导语，放在报告的最开头：<br>基于最近调查所得信息，本报告概述了我们公司面临的三大问题：员工流失、店铺盗窃和低水平客户服务。</p>
</li>
<li><p>类比<br> 生产部门与销售部门、营销部门之间的关系，使用“枪和子弹”类比：“生产部门生产子弹，营销部门瞄枪，销售部门扣动扳机。”</p>
</li>
<li><p>暗喻<br> 他有钢铁般的勇气。</p>
</li>
<li><p>正式<br> 无缩略形式和人称代词。</p>
</li>
</ol>
<h2 id="摘录"><a href="#摘录" class="headerlink" title="摘录"></a>摘录</h2><h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><p>当你说一件事情的时候，确保你说清楚了。如此，你言说的机会才合理。</p>
<h3 id="风格"><a href="#风格" class="headerlink" title="风格"></a>风格</h3><p>简短地展现以便他们阅读，清楚地展现以便他们欣赏，如画般地展现以便他们记忆，最重要的是，准确地展现以便他们被它的光明所指引。</p>
<h3 id="可读性"><a href="#可读性" class="headerlink" title="可读性"></a>可读性</h3><p>第一稿的愉悦源于欺骗自己它离真正的作品已经相当接近了；其后稿的愉悦部分源于意识到自己没有被第一稿蒙骗。</p>
]]></content>
      <categories>
        <category>思想文化</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
        <tag>写作</tag>
      </tags>
  </entry>
  <entry>
    <title>《如何阅读一本书》读书笔记</title>
    <url>/book-rhydybs/</url>
    <content><![CDATA[<p><img data-src="http://images.xyang.xin/2019-09%2Frhydybs.jpeg?x-oss-process=style/title_140" alt="rhydybs.jpeg-w140"></p>
<span id="more"></span>
<p><img data-src="http://images.xyang.xin/2019-09%2F%E3%80%8A%E5%A6%82%E4%BD%95%E9%98%85%E8%AF%BB%E4%B8%80%E6%9C%AC%E4%B9%A6%E3%80%8B.png" alt="《如何阅读一本书》.png"></p>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>图中对《如何阅读一本书》的脉络要点进行总结，用于阅读时的参考。（图谱内容较多，建议保存后浏览）。</p>
<p>书中提出了四种阅读层次，层次逐级递增，较高层次的阅读包含较低层次的阅读。基础阅读是对字词句意思的理解，是阅读的基础。使用检视阅读来理清书的脉络，来甄别一本书是否值得读，是否适合现在读。使用分析阅读来细细品味一本好书。主题阅读适用于学术研究或对自己感兴趣的问题的探究性学习。</p>
<!-- more -->
<h2 id="摘录"><a href="#摘录" class="headerlink" title="摘录"></a>摘录</h2><p>读者是要“发现”书中隐藏着的骨架。而作者则是以制造骨架为开始，但却想办法把骨架“隐藏”起来。他的目的是，用艺术的手法将骨架隐藏起来，或是说，在骨架上添加血肉。</p>
<p>所谓文章的清楚明白，就是跟纲要的区隔是否清楚有关，所谓文章的前后一贯，就是能把不同的重点条理有序地排列出来。</p>
<p>这个捷径是要靠你的检视阅读技巧来建立的。你收集好书目之后，要做的第一件事是检视书单上所有的书。在做检视阅读之前，绝不要用分析阅读来阅读。检视阅读不会让你明白有关主题的所有错综复杂的内容，或是作者所有的洞察力，但却具有两种基本的功能。第一，它会让你对自己想要研究的主题有个清晰的概念，这样接下来你针对某几本书做分析阅读时，会大有助益。第二，它会简化你的书目到一个合理的程度。</p>
<p>能够熟练检视阅读的读者，不但能在心中将书籍分类，而且能对内容有一个粗浅的了解。他也会用非常短的时间就发现，这本书谈的内容对他研究的主题到底重不重要————这可能要等到读下本书的时候才能发现。但是有两件事至少他已经知道其中之一。那就是他不是发现这本书必须回头再读一次，以获得启发，便是知道不论这本书多有趣又多丰富，却毫无启发性，因此不值得重新再读。</p>
]]></content>
      <categories>
        <category>思想文化</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
        <tag>阅读</tag>
      </tags>
  </entry>
  <entry>
    <title>position ——【每天一点 CSS】</title>
    <url>/css-everday-1/</url>
    <content><![CDATA[<p>今天来聊聊关于CSS的属性<code>position</code>，它的取值如下：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">position</span>: static;   // 初始值</span><br><span class="line"><span class="attribute">position</span>: relative; // 相对定位</span><br><span class="line"><span class="attribute">position</span>: absolute; // 绝对定位</span><br><span class="line"><span class="attribute">position</span>: fixed;    // 固定定位</span><br></pre></td></tr></table></figure>
<p>定位不是继承的。</p>
<span id="more"></span>

<h2 id="static"><a href="#static" class="headerlink" title="static"></a>static</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p><code>static</code>是元素定位的默认值，让元素出现在常规文档流中。</p>
<h2 id="relative"><a href="#relative" class="headerlink" title="relative"></a>relative</h2><h3 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h3><p>每个元素在页面的文档流中都有一个自然位置，相对于这个原始位置进行移动就称为<em>相对定位</em>。而其周围的元素完全不受此影响。相对定位会在原先的位置留下空白。</p>
<h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><ol>
<li>作为绝对定位的参照。</li>
<li>使用<code>top</code>、<code>right</code>、<code>bottom</code>和<code>left</code>调整元素的位置，元素在视觉上看起来就像被推到一个不同的位置。</li>
</ol>
<h2 id="absolute"><a href="#absolute" class="headerlink" title="absolute"></a>absolute</h2><h3 id="概念-2"><a href="#概念-2" class="headerlink" title="概念"></a>概念</h3><p>元素会被移出文档流。就不像<code>static</code>或者<code>relative</code>这样占用空间。</p>
<p>没有额外设置的情况下，<em>绝对定位</em>是相对于 body 进行定位的。可以对希望称为<em>绝对定位</em>参照体的祖先元素添加 <code>position: relative;</code>。</p>
<p><em>绝对定位</em>不会在原先的位置留下空白。</p>
<h2 id="fixed"><a href="#fixed" class="headerlink" title="fixed"></a>fixed</h2><h3 id="概念-3"><a href="#概念-3" class="headerlink" title="概念"></a>概念</h3><p><code>fixed</code> 有点类似于<code>absolute</code>，会被移出文档流。不一样的是<code>fixed</code>始终相对浏览器窗口定位。</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul>
<li>《HTML与CSS3基础教程（第8版）》</li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/position">position - CSS（层叠样式表） | MDN</a></li>
<li><a href="https://zellwk.com/blog/css-positions/">Understanding and Using CSS Positions | Zell Liew</a></li>
</ul>
]]></content>
      <categories>
        <category>信息技术</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>类型的动态绑定和静态绑定</title>
    <url>/dynamic-and-static-type-binding/</url>
    <content><![CDATA[<p>JavaScript 是动态绑定的语言，而 TypeScript 包装其成为静态绑定的语言。而什么是动态绑定，什么是静态绑定，它们的优劣又是什么呢？TypeScript 又为什么要“多此一举”？</p>
<span id="more"></span>

<h2 id="绑定"><a href="#绑定" class="headerlink" title="绑定"></a>绑定</h2><p>绑定是一种关联（associate），也可以是一种分配（assign）。类型绑定是将声明的变量关联到特定类型的过程。</p>
<p>动态绑定就是，在程序运行的时候，将变量绑定到类型。<br>静态绑定，在编译时，编译器将变量绑定到类型。</p>
<h2 id="编译与解释"><a href="#编译与解释" class="headerlink" title="编译与解释"></a>编译与解释</h2><p>像 JavaScript、PHP、Python、Ruby 这类解释型语言他们没有编译器。在运行之前发现变量类型是不可能的。可以参考下图解释器的工作方式。<br><img data-src="http://images.xyang.xin/2020%2F08%2F14%2Fcompiler%26interpreter.png?x-oss-process=style/title_800" alt="compiler&amp;interpreter.png"></p>
<p>而 C、C++、Go、Rust 这类编译型语言，是在编译的时候就将变量绑定到类型。静态绑定又有两种方式：下面两句 go 语言代码，都是创建了一个初始值为 10 的<code>int</code>类型的变量。前者是显式声明，程序直接写出了变量的类型为<code>int</code>；后者是隐式声明，根据值 10 推导变量的类型为<code>int</code>。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x <span class="keyword">int</span> = <span class="number">10</span></span><br><span class="line"><span class="comment">// 或</span></span><br><span class="line">x := <span class="number">10</span></span><br></pre></td></tr></table></figure>

<h2 id="Java-与-TypeScript"><a href="#Java-与-TypeScript" class="headerlink" title="Java 与 TypeScript"></a>Java 与 TypeScript</h2><p>Java 首先编译为<code>.class</code>字节码文件，而后字节码文件通过虚拟机解释执行。Java 是有编译器的，所以能够实现动态绑定，事实也是如此。</p>
<p>而 TypeScript 呢，看上去它的设计还真像 Java 呢，先通过 TSC 将 ts 代码编译为 js 代码，js 代码再通过 node、浏览器等运行环境解释执行。与前面的 go 语言代码类似。</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> today:<span class="built_in">string</span> = <span class="string">&quot;Sun&quot;</span></span><br><span class="line"><span class="keyword">let</span> tomorrow = <span class="string">&quot;Mon&quot;</span></span><br></pre></td></tr></table></figure>

<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul>
<li><a href="https://stackoverflow.com/questions/9837972/static-type-binding-vs-dynamic-type-binding">Static Type Binding Vs Dynamic Type Binding - Stack Overflow</a></li>
</ul>
]]></content>
      <categories>
        <category>信息技术</category>
      </categories>
      <tags>
        <tag>TypeScript</tag>
      </tags>
  </entry>
  <entry>
    <title>Symbol ———【一天一个 es6 语法】</title>
    <url>/es6-everday-1/</url>
    <content><![CDATA[<h2 id="什么是-Symbol"><a href="#什么是-Symbol" class="headerlink" title="什么是 Symbol?"></a>什么是 Symbol?</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> 😻 = 😺 × 😍;  <span class="comment">// SyntaxError</span></span><br></pre></td></tr></table></figure>
<p>（爆笑）这当然不是 Symbol。</p>
<ul>
<li>Undefined</li>
<li>Null</li>
<li>Boolean</li>
<li>Number</li>
<li>String</li>
<li>Object</li>
<li>Symbol (ES2015 新增)</li>
</ul>
<p>Symbol 不是字符串，不是对象，是第七种原始数据类型。每个从<code>Symbol()</code>返回的 symbol 类型的值都是唯一的。<strong>一个 symbol 类型的值能作为对象属性的标识符；这是该数据类型仅有的目的</strong>。</p>
<span id="more"></span>
<h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><p>通过以下代码就创建一个 Symbol 类型的值。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Symbol([description])</span></span><br><span class="line"><span class="keyword">let</span> s = <span class="built_in">Symbol</span>(<span class="string">&quot;我就是我&quot;</span>);</span><br><span class="line"><span class="keyword">typeof</span> s;</span><br><span class="line"><span class="comment">// &quot;symbol&quot;</span></span><br></pre></td></tr></table></figure>
<p>Symbol 中的参数对程序无实际意义，仅供调试助记。不支持语法： <code>new Symbol()</code></p>
<p>不能自动转换为字符串：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="built_in">Symbol</span>();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot; your symbol is&quot;</span> + s);</span><br><span class="line"><span class="comment">// TypeError: can&#x27;t convert symbol to string</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`your symbol is <span class="subst">$&#123;s&#125;</span>`</span>)</span><br><span class="line"><span class="comment">// TypeError: can&#x27;t conver symbol to string</span></span><br></pre></td></tr></table></figure>
<h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><h3 id="对象中的私有属性"><a href="#对象中的私有属性" class="headerlink" title="对象中的私有属性"></a>对象中的私有属性</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> cat = <span class="built_in">Symbol</span>(<span class="string">&quot;cat&quot;</span>)</span><br><span class="line"><span class="keyword">let</span> dog = <span class="built_in">Symbol</span>(<span class="string">&quot;dog&quot;</span>)</span><br><span class="line"><span class="keyword">let</span> pig = <span class="built_in">Symbol</span>(<span class="string">&quot;pig&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj = &#123; <span class="attr">property</span>: <span class="string">&quot;这是一个动物乐园&quot;</span>, [cat]: <span class="string">&quot;金点渐层猫&quot;</span>, [dog]: <span class="string">&quot;二哈&quot;</span>, [pig]: <span class="string">&quot;藏香猪&quot;</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> prop <span class="keyword">in</span> obj) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(prop + <span class="string">&quot;: &quot;</span> + obj[prop]</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印出 property: &quot;这是一个动物乐园&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertySymbols(obj))</span><br><span class="line"><span class="comment">// 打印出 [ Symbol(cat), Symbol(dog), Symbol(pig) ]</span></span><br></pre></td></tr></table></figure>
<p>基于 <code>symbol</code> 的私有属性对 <code>Object.entries</code>、 <code>Object.keys</code>、 <code>for...in</code> 等其它迭代器是不可见的。</p>
<p><code>symbol</code> 属性对 <code>JSON.stringify</code> 方法也是不可见的额。</p>
<h3 id="类中的私有属性"><a href="#类中的私有属性" class="headerlink" title="类中的私有属性"></a>类中的私有属性</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> _items = <span class="built_in">Symbol</span>(<span class="string">&#x27;stackItems&#x27;</span>);</span><br><span class="line"></span><br><span class="line">interface Stack &#123;</span><br><span class="line">  [_items]: any[];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stack</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>[_items] = [];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 添加一个新元素到栈顶</span></span><br><span class="line">  <span class="function"><span class="title">push</span>(<span class="params">element:any</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>[_items].push(element);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 移除栈顶的元素，同时返回</span></span><br><span class="line">  <span class="function"><span class="title">pop</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>[_items].pop();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 返回栈顶的元素</span></span><br><span class="line">  <span class="function"><span class="title">peek</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>[_items][<span class="built_in">this</span>[_items].length - <span class="number">1</span>];</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">// 没有任何元素true，否则false</span></span><br><span class="line">  <span class="function"><span class="title">isEmpty</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>[_items].length === <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 移除栈里的所有元素</span></span><br><span class="line">  <span class="function"><span class="title">clear</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>[_items] = [];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 返回栈里的元素个数</span></span><br><span class="line">  <span class="function"><span class="title">size</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>[_items].length;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">print</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.toString());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">toString</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>[_items].toString();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getSymbol</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">const</span> stack = <span class="keyword">new</span> Stack();</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Object</span>.getOwnPropertySymbols(stack);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">testSymbol</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> stack = <span class="keyword">new</span> Stack();</span><br><span class="line">  <span class="keyword">return</span> stack[_items];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(testSymbol());</span><br><span class="line"><span class="comment">// []</span></span><br><span class="line"><span class="built_in">console</span>.log(getSymbol()[<span class="number">0</span>]);</span><br><span class="line"><span class="comment">// Symbol(stackItems)</span></span><br></pre></td></tr></table></figure>

<p>注意区别 <code>stack[_items]</code> 和<code>stack[&#39;_items&#39;]</code></p>
<p>前者是访问属性名为 Symbol 的特殊方式。<br>后者是访问一般属性的方法与 <code>stack._items </code>相同。</p>
<p>我猜测正因为这种特殊的访问方式使其无法通过<code>for...in</code>，<code>for...of</code>或 <code>Object.keys()</code> 等方法枚举。</p>
<p>通过 <code>testSymbol()</code> 方法在我看来，其并不能达到实现私有变量的目的，仅仅使属性名或方法名不与别人提供的对象产生冲突。是一种保证每个属性名独一无二的方式。</p>
<hr>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul>
<li><a href="https://hacks.mozilla.org/2015/06/es6-in-depth-symbols/">ES6 In Depth: Symbols - Mozilla Hacks - the Web developer blog</a></li>
<li><a href="https://es6.ruanyifeng.com/#docs/symbol">Symbol - ECMAScript 6入门</a></li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Symbol">Symbol - JavaScript | MDN</a></li>
</ul>
]]></content>
      <categories>
        <category>信息技术</category>
      </categories>
      <tags>
        <tag>【一天一个 es6 语法】</tag>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>箭头函数( =&gt; ） ———【一天一个 es6 语法】</title>
    <url>/es6-everday-2/</url>
    <content><![CDATA[<h2 id="Function"><a href="#Function" class="headerlink" title="Function"></a>Function</h2><p>每个函数都是 <code>Function</code> 类型的实例，由于函数是对象，因此函数名实际上也是一个指向函数对象的指针，函数通常是使用<strong>函数声明语法</strong>定义的：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span> (<span class="params">num1, num2</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<p>这与下面使用<strong>函数表达式</strong>定义函数的方式几乎相差无几：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> sum = <span class="function"><span class="keyword">function</span>(<span class="params">num1, num2</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>最后一种定义函数的方式是使用<code>Function</code>构造函数，最后一个参数始终都被看成是函数体，而前面的参数则枚举出了新函数的参数：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Function</span>(<span class="string">&quot;num1&quot;</span>, <span class="string">&quot;num2&quot;</span>, <span class="string">&quot;return num1 + num2&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>其中<strong>函数声明语法</strong>具有函数声明提升（function declaration hoisting）,解析器会率先读取函数声明，并使其在执行任何代码之前可用。其余的时候<strong>函数声明</strong>与<strong>函数表达式</strong>的语法其实是等价的。</p>
<p>箭头函数针对的是<strong>函数表达式</strong>定义的函数。</p>
<h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> funcName = <span class="function"><span class="keyword">function</span>(<span class="params">para</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;xxx&quot;</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">var</span> funcName = <span class="function"><span class="params">para</span> =&gt;</span> para + <span class="string">&quot;xxx&quot;</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> funcName = <span class="function"><span class="keyword">function</span>(<span class="params">para1, para2</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(para1 + <span class="string">&quot; and &quot;</span> + para2);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//等同于</span></span><br><span class="line"><span class="keyword">var</span> funcName = <span class="function">(<span class="params">para1, para2</span>) =&gt;</span> <span class="built_in">console</span>.log(para1 + <span class="string">&quot; and &quot;</span> + para2);</span><br></pre></td></tr></table></figure>

<p>从形式上来看也就是把<strong>函数表达式</strong>定义的函数，function 去掉，在参数括号外面加 =&gt; 。没有参数用()占位，只有一个参数时可以省略括号，后面的代码块部分多于一条语句就要用大括号括起来，而只有一条语句可以省略大括号，如果是 return 语句，还可以省略 return。</p>
<p>当然仅仅为了好看，箭头函数存在的意义并不大。</p>
<h2 id="使用注意点"><a href="#使用注意点" class="headerlink" title="使用注意点"></a>使用注意点</h2><p>（1）函数体内的 this 对象，就是定义时所在的对象，而不是使用时所在的对象。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> objName = &#123;</span><br><span class="line">    <span class="attr">food</span>: [<span class="string">&quot;chicken&quot;</span>, <span class="string">&quot;hamburger&quot;</span>, <span class="string">&quot;French Fries&quot;</span>],</span><br><span class="line">    <span class="attr">print</span>: <span class="function"><span class="keyword">function</span>(<span class="params">delay=<span class="number">1000</span></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="built_in">this</span>.resorts.join(<span class="string">&quot;,&quot;</span>))</span><br><span class="line">        &#125;, delay)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">objName.print() <span class="comment">// Cannot read property &#x27;join&#x27; of undefined</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> objName = &#123;</span><br><span class="line">    <span class="attr">food</span>: [<span class="string">&quot;chicken&quot;</span>, <span class="string">&quot;hamburger&quot;</span>, <span class="string">&quot;French Fries&quot;</span>],</span><br><span class="line">    <span class="attr">print</span>: <span class="function"><span class="keyword">function</span>(<span class="params">delay=<span class="number">1000</span></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="built_in">this</span>.resorts.join(<span class="string">&quot;,&quot;</span>))</span><br><span class="line">        &#125;, delay)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">objName.print() <span class="comment">//chicken, hamburger, French Fries</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> objName = &#123;</span><br><span class="line">    <span class="attr">food</span>: [<span class="string">&quot;chicken&quot;</span>, <span class="string">&quot;hamburger&quot;</span>, <span class="string">&quot;French Fries&quot;</span>],</span><br><span class="line">    <span class="attr">print</span>: <span class="function">(<span class="params">delay=<span class="number">1000</span></span>)=&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="built_in">this</span>.resorts.join(<span class="string">&quot;,&quot;</span>))</span><br><span class="line">        &#125;, delay)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">objName.print() <span class="comment">//Cannot read property &#x27;join&#x27; of undefined</span></span><br></pre></td></tr></table></figure>
<p>第三段代码将 <code>print</code> 函数声明改为一个箭头函数的形式意味着其中关键字 <code>this</code> 指代的对象就是 <code>object</code>（浏览器中是 <code>window</code>）。<br><code>setTimeout()</code>方法设置一个定时器，该定时器在定时器到期后执行一个函数或指定的一段代码，上面的代码都是 1s 后执行 <code>console.log</code> 所在的函数。</p>
<p>（2）不可使用<code>arguments</code>对象，如果要用，可以用扩展运算符(<code>...</code>)将函数参数搜集到一个数组中。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>(<span class="params">...theArgs</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> theArgs;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>（3）箭头函数没有自己的 <code>this</code>。<br>不能用 <code>call()</code>、<code>apply()</code>、<code>bind()</code> 这些方法去改变 <code>this</code> 的指向。</p>
<hr>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul>
<li>《Javascript 高级程序设计（第3版）》</li>
<li><a href="https://es6.ruanyifeng.com/#docs/function">函数的扩展 - ECMAScript 6入门</a></li>
</ul>
]]></content>
      <categories>
        <category>信息技术</category>
      </categories>
      <tags>
        <tag>【一天一个 es6 语法】</tag>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>解构赋值 ———【一天一个 es6 语法】</title>
    <url>/es6-everyday-3/</url>
    <content><![CDATA[<h2 id="何为解构赋值"><a href="#何为解构赋值" class="headerlink" title="何为解构赋值"></a>何为解构赋值</h2><p>解构赋值语法是一种 javascript 表达式。通过解构赋值，可以将属性/值从对象/数组中取出，复制给其他变量。</p>
<span id="more"></span>

<h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><h3 id="对象解构赋值"><a href="#对象解构赋值" class="headerlink" title="对象解构赋值"></a>对象解构赋值</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> regularPerson = &#123;</span><br><span class="line">    <span class="attr">firstName</span>: <span class="string">&quot;Bill&quot;</span>,</span><br><span class="line">    <span class="attr">lastnNme</span>: <span class="string">&quot;Wilson&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> lordify = <span class="function">(<span class="params">&#123;firstName&#125;</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;firstName&#125;</span> of Canterbury`</span>;</span><br><span class="line">&#125;</span><br><span class="line">lordify(regularPerson);     <span class="comment">// Bill of Canterbury</span></span><br></pre></td></tr></table></figure>
<h3 id="数组解构赋值"><a href="#数组解构赋值" class="headerlink" title="数组解构赋值"></a>数组解构赋值</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> [firstResort] = [<span class="string">&quot;Kirkwood&quot;</span>, <span class="string">&quot;Squaw&quot;</span>, <span class="string">&quot;Alpine&quot;</span>];</span><br><span class="line"><span class="built_in">console</span>.log(firstResort); <span class="comment">// kirkwood</span></span><br><span class="line"><span class="keyword">var</span> [,,thirdResort] = [<span class="string">&quot;Kirkwood&quot;</span>, <span class="string">&quot;Squaw&quot;</span>, <span class="string">&quot;Alpine&quot;</span>];</span><br><span class="line"><span class="built_in">console</span>.log(thirdResort]; <span class="comment">// Alpine</span></span><br></pre></td></tr></table></figure>
<h3 id="字符串解构赋值"><a href="#字符串解构赋值" class="headerlink" title="字符串解构赋值"></a>字符串解构赋值</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> [a, b, c, d, e = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">a <span class="comment">// &quot;h&quot;</span></span><br><span class="line">b <span class="comment">// &quot;e&quot;</span></span><br><span class="line">c <span class="comment">// &quot;l&quot;</span></span><br><span class="line">d <span class="comment">// &quot;l&quot;</span></span><br><span class="line">e <span class="comment">// &quot;o&quot;</span></span><br></pre></td></tr></table></figure>
<p>类似数组的对象都有一个<code>length</code>属性，因此还可以对这个属性解构赋值。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> &#123;<span class="attr">length</span>: len&#125; = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">len <span class="comment">// 5</span></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment">解构赋值 - JavaScript | MDN</a></li>
<li><a href="https://es6.ruanyifeng.com/#docs/destructuring">变量的解构赋值 - ECMAScript 6入门</a></li>
<li>《React 学习手册》</li>
</ul>
]]></content>
      <categories>
        <category>信息技术</category>
      </categories>
      <tags>
        <tag>【一天一个 es6 语法】</tag>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>人生</title>
    <url>/flesh/</url>
    <content><![CDATA[<h2 id="他的话可信吗"><a href="#他的话可信吗" class="headerlink" title="他的话可信吗"></a>他的话可信吗</h2><blockquote>
<p>听人谈话的时候，我们需要了解这人是谁，他是处在何种角度，代表何种阶级谈话的。</p>
</blockquote>
<p>他的话是他的经验之谈，是他从权威的书籍中得知，论坛上看到，还是他仅仅只是为了让你相信而虚构或者是一个看似正确而往往值得商榷的。</p>
<span id="more"></span>

<h2 id="好话"><a href="#好话" class="headerlink" title="好话"></a>好话</h2><blockquote>
<p>听见好话一定要多长心眼，好话会让你做出的决策违背初心，待后知后觉，晚矣。</p>
</blockquote>
<p>投票软件多少是有漏洞的，从开发人员的角度利用漏洞刷票是很容易被发现，且破坏比赛的公平度的。很多亲人朋友呢很支持我，感觉一个投票闹得挺辛苦的。就不得不在群里向主办方反馈，不一会儿开发投票软件公司的老总进来了，也不说是解决问题。</p>
<p>主办方第一轮给出的结果，随便找个理由，说没有刷票行为。<br>网络投票看是否刷票，一般都是看着某一天投票数是否波动过大，尤其是最后一天，或者票数数量过多，咱们开始怀疑刷票。然而这都只是怀疑，技术部门要是不想解决也是没办法的。<br>然而当投票网站上有访问量和投票数那就不一样了，当投票数大于访问量？这是什么怪物？页面都没被访问，你又是怎么点击投票按钮的，这就是异常刷票了。</p>
<p>这种情况主办方如果不证明是系统漏洞，抑或是抓出一个有刷票行为的队伍来，那这个主办方麻烦就大了，网络舆情还是很管用的。</p>
<p>后面主办方不得不抓出了一个，五天投票，前面四天总共几十票，最后一天下午飙几万的队伍。据肉眼观察肯定是不止一个的。</p>
<p>但是同时那个老总私聊到我，简单的说“本科进决赛很优秀了，有时间聊一下”。再加上我本身对这软件公司是没有敌意的，因为系统安全性技术比较难，本身抱着的态度就是能找出刷票的队伍，解决问题就行了。</p>
<p>他这一句话导致的最终结果就是，简单的将刷票最厉害的队伍解决了，而放下了第一轮结果所公布的无赖行为和更多的不公平性的愤懑。</p>
<p>一句好话让我对公平性诉求，从解决，到最简单的解决。</p>
<h2 id="解决生活中的难题"><a href="#解决生活中的难题" class="headerlink" title="解决生活中的难题"></a>解决生活中的难题</h2><p>倘若有条件自己给自己安排一件难题，例如考研究生、公务员，不是生活强加给我们的，那便是为了多一种生活体验。抱着解决问题的心态去攻坚克难，坚持下去完整的度过有计划的每一天便是一种胜利。</p>
<h2 id="为什么不同"><a href="#为什么不同" class="headerlink" title="为什么不同"></a>为什么不同</h2><p>假若我们抱怨，抱怨自己没有出生在名门旺族，抱怨自己没有一个好看的脸蛋。然而人之所以是自己，正是源于这些后天难以更改的不同之处。</p>
]]></content>
      <categories>
        <category>思想文化</category>
      </categories>
      <tags>
        <tag>人生</tag>
      </tags>
  </entry>
  <entry>
    <title>基于 GitHub Pages 的 Hexo+NexT 博客搭建</title>
    <url>/githubpages-hexo-next/</url>
    <content><![CDATA[<h1 id="基于-GitHub-Pages-的-Hexo-NexT-博客-——-引导篇"><a href="#基于-GitHub-Pages-的-Hexo-NexT-博客-——-引导篇" class="headerlink" title="基于 GitHub Pages 的 Hexo + NexT 博客 —— 引导篇"></a>基于 GitHub Pages 的 Hexo + NexT 博客 —— 引导篇</h1><h2 id="基于-GitHub-Pages-的-Hexo-NexT-博客概述"><a href="#基于-GitHub-Pages-的-Hexo-NexT-博客概述" class="headerlink" title="基于 GitHub Pages 的 Hexo + NexT 博客概述"></a>基于 GitHub Pages 的 Hexo + NexT 博客概述</h2><p>使用这一套博客系统架构您将获得稳定免费、美观、易定制的个人博客。通过 Markdown 语法编辑文章，git命令发布文章，优雅的博客发布体验。</p>
<span id="more"></span>

<h2 id="搭建本博客系统的技术条件"><a href="#搭建本博客系统的技术条件" class="headerlink" title="搭建本博客系统的技术条件"></a>搭建本博客系统的技术条件</h2><ol>
<li>基本的终端命令与理解，比如：如何 cd 进入一个需要进入的文件夹。</li>
<li>GitHub项目创建和项目下载。</li>
</ol>
<h1 id="GitHub-Pages"><a href="#GitHub-Pages" class="headerlink" title="GitHub Pages"></a>GitHub Pages</h1><h2 id="GitHub-Pages-简介"><a href="#GitHub-Pages-简介" class="headerlink" title="GitHub Pages 简介"></a>GitHub Pages 简介</h2><p>GitHub Pages 是GitHub免费为用户提供的，适用于 GitHub 用户发布自己的网页内容（静态网页）。<a href="https://pages.github.com/">官网🐱</a><br>GitHub Pages 的容量限制为1GB，流量限制为一个月100GB。GitHub用户名将作为github.com的二级域名，而每一个 github repository 都是可以部署在GitHub Pages上的，这样低成本的为前端开发人员免费的提供了一台稳定免费的测试服务器和域名。</p>
<p>GitHub Pages 同样是个人博客的优良载体, 以下教程将基于 GitHub Pages 打造个人博客。</p>
<h2 id="GitHub-Pages-博客项目建立"><a href="#GitHub-Pages-博客项目建立" class="headerlink" title="GitHub Pages 博客项目建立"></a>GitHub Pages 博客项目建立</h2><p>将项目创建于 GitHub Pages 的根目录下（”/“）。<br>保持创建普通GitHub项目的姿势，将项目名称命名为 GitHub用户名.github.io。<br>URL == “GitHub用户名.github.io/“</p>
<p>每个GitHub项目都可以部署到 GitHub Pages，作为二级路径(“项目名/“)。<br>Settings -&gt; GitHub Pages -&gt; Source -&gt; master branch<br>URL == “GitHub用户名.github.io/项目名/“</p>
<h1 id="Hexo"><a href="#Hexo" class="headerlink" title="Hexo"></a>Hexo</h1><h2 id="Hexo-简介"><a href="#Hexo-简介" class="headerlink" title="Hexo 简介"></a>Hexo 简介</h2><p>Hexo 基于Node.js开发是一 个纯静态的博客框架，使用Markdown渲染引擎文章。 </p>
<h2 id="Hexo-安装及配置"><a href="#Hexo-安装及配置" class="headerlink" title="Hexo 安装及配置"></a>Hexo 安装及配置</h2><p>Hexo 详细安装及配置请参考<br><a href="https://hexo.io/zh-cn/docs/">Hexo 官方文档</a><br>建议：完成官方文档“建站”继续查看后面的内容。<br>配置文件 : 后面都要加空格。<br>对_config.yml站点配置文件简要配置。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># URL</span><br><span class="line">url: https://GitHub用户名.github.io/</span><br></pre></td></tr></table></figure>
<h2 id="Hexo-的使用"><a href="#Hexo-的使用" class="headerlink" title="Hexo 的使用"></a>Hexo 的使用</h2><p>相信您已经了解source文件夹是您以后存放文章的地方，并且已经看见官方文档中的这句话“Markdown 和 HTML 文件会被解析并放到 public 文件夹，而其他文件会被拷贝过去。”<br>而这个public文件夹的内容正是需要上传到GitHub Pages的内容，如何去生成呢？请继续往后看。</p>
<p>写完文章发布到服务器之前，先看看效果呗！现在source/_posts文件夹里面正好有一篇hello-world。<br>在站点文件夹根目录下执行如下命令（插件都在该目录安装）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ npm install hexo-server --save</span><br></pre></td></tr></table></figure>
<p>安装完成后，输入以下命令以启动服务器，您的网站会在 <a href="http://localhost:4000/">http://localhost:4000</a> 下启动。在服务器启动期间，Hexo 会监视文件变动并自动更新，您无须重启服务器。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ hexo s (即 hexo server)</span><br></pre></td></tr></table></figure>
<p>现在介绍两种发布文章的方式, 建议Windows用户用第一种，Mac用户使用第二种：</p>
<p>方案一：通过 hexo-deployer-git 插件<br>在站点文件夹根目录下执行如下命令（插件都在该目录安装）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>
<p>文件解析生成 public 文件夹</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ hexo g (即 hexo generate)</span><br></pre></td></tr></table></figure>
<p>配置_config.yml站点配置文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Deployment</span><br><span class="line">## Docs: https://hexo.io/docs/deployment.html</span><br><span class="line">deploy:</span><br><span class="line">   type: git</span><br><span class="line">   repository: 您下载自己项目的URL (项目在 GitHub Pages 根目录：https://github.com/GitHub用户名.github.io.git/)</span><br><span class="line">    branch: master</span><br></pre></td></tr></table></figure>
<p>项目部署</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ hexo d (即 hexo deploy)</span><br></pre></td></tr></table></figure>
<p>这里会提示输入您的github账号密码，通过前面提到的 URL 访问到您的博客， 项目部署成功。</p>
<p>方案二： 通过 git 命令部署<br>进入站点文件夹根目录，克隆您的项目到本地（目的是获取 .git 文件夹，这是 git 的全部）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git clone https://github.com/GitHub用户名/GitHub用户名.github.io.git .deploy/GitHub用户名.github.io</span><br></pre></td></tr></table></figure>
<p>解析及部署命令如下（可将以下命令直接 deploy.sh 脚本文件里 ）: </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ hexo generate                      # 文件解析生成 public 文件夹</span><br><span class="line">$ cp -R public/* .deploy/GitHub用户名.github.io  # 复制 public 文件夹的全部内容到 .deploy 隐藏文件夹下</span><br><span class="line">$ cd .deploy/GitHub用户名.github.io</span><br><span class="line">$ git add .</span><br><span class="line">$ git commit -m “update”</span><br><span class="line">$ git push origin master</span><br></pre></td></tr></table></figure>
<p>将 deploy.sh 脚本文件放在站点文件夹根目录，cd 进入根目录，执行命令如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ sh deploy.sh</span><br></pre></td></tr></table></figure>
<p>这里会提示输入您的github账号密码，通过前面提到的 URL 访问到您的博客， 项目部署成功。</p>
<p>这一小节记住两个命令： hexo s 和 hexo d 或 sh deploy.sh<br>事实上 hexo s -s 更常使用（详情查看<a href="https://hexo.io/zh-cn/docs/server">官方文档 -&gt; 服务器</a>）</p>
<h2 id="使用个人域名"><a href="#使用个人域名" class="headerlink" title="使用个人域名"></a>使用个人域名</h2><p>如果想要使用自己的域名，在域名解析的时候使用CNAME记录类型。并实现个人博客向个人域名的映射，在source文件夹下创建CNAME文件（无后缀名），在文件中直接写入您的域名（http:// 后面的内容）</p>
<h1 id="NexT"><a href="#NexT" class="headerlink" title="NexT"></a>NexT</h1><h2 id="NexT-简介"><a href="#NexT-简介" class="headerlink" title="NexT 简介"></a>NexT 简介</h2><p>NexT 是一款完全基于 Hexo 的主题，使用者众多，成熟度高，我们可以基于它创造出属于我们不一样的个人博客。 </p>
<p>下面更多的是对该主题一些基本配置的讲述，请勿照搬，按自己的喜好描绘属于自己的博客吧。</p>
<h2 id="NexT-安装及配置"><a href="#NexT-安装及配置" class="headerlink" title="NexT 安装及配置"></a>NexT 安装及配置</h2><p>建议下载最新版本<br><a href="https://github.com/theme-next/hexo-theme-next/blob/master/docs/zh-CN/README.md">v6.0.x版本 GitHub 地址</a></p>
<p>NexT 详细安装及配置请参考<br><a href="https://theme-next.iissnan.com/getting-started.html">NexT 官方文档</a><br><a href="https://github.com/iissnan/hexo-theme-next/wiki">NexT 使用文档 GitHub Wiki</a>  </p>
<p>NexT 的配置围绕配置文件，对内置样式与第三方插件进行配置。（NexT 配置文件在 NexT 主题根目录，文件名和站点配置文件名相同）。</p>
<h2 id="外观设置"><a href="#外观设置" class="headerlink" title="外观设置"></a>外观设置</h2><p>目前官方有四款外观供选择，在 NexT 的配置文件下搜索 Schemes 删除注释符号 # 即可使用。 </p>
<h2 id="footer-页脚的配置"><a href="#footer-页脚的配置" class="headerlink" title="footer 页脚的配置"></a>footer 页脚的配置</h2><p>搜索 footer 将 powered theme 的 enable 调整为 false。</p>
<h2 id="添加标签-tags-页"><a href="#添加标签-tags-页" class="headerlink" title="添加标签 tags 页"></a>添加标签 tags 页</h2><p>执行以下命令将在 source 文件夹下将生成 tags 文件夹，打开修改里面的 index 文件添加 type : “tags”。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ hexo new page tags</span><br></pre></td></tr></table></figure>
<h2 id="添加分类-categories-页"><a href="#添加分类-categories-页" class="headerlink" title="添加分类 categories 页"></a>添加分类 categories 页</h2><p>执行以下命令将在 source 文件夹下将生成 categories 文件夹，打开修改里面的 index 文件添加 type : “categories”。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ hexo new page categories</span><br></pre></td></tr></table></figure>
<h2 id="分类和标签的应用"><a href="#分类和标签的应用" class="headerlink" title="分类和标签的应用"></a>分类和标签的应用</h2><p>事实上，分类和标签都是 hexo 实现的， 可查看官方文档 Front-matter 部分。</p>
<p>Front-matter 是通过 hexo new 生成的 md 文件 - - - 以上的区域。<br>categories 是有顺序性和层次性的而 tags 没有，例如:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">categories:</span><br><span class="line">- 人文</span><br><span class="line">- 散文</span><br><span class="line">tags:</span><br><span class="line">- 毕淑敏</span><br><span class="line">- 早年</span><br></pre></td></tr></table></figure>
<h2 id="menu-菜单栏配置"><a href="#menu-菜单栏配置" class="headerlink" title="menu 菜单栏配置"></a>menu 菜单栏配置</h2><p>搜索 menu 你可以选择打开一些菜单按钮 || 后面对应的是 Font Awesome 图标名。<br><a href="https://fontawesome.com/?from=io">Font Awesome</a><br><a href="http://www.fontawesome.com.cn/faicons/">图标库 – Font Awesome 中文网</a></p>
<h2 id="sidebar-侧边栏配置"><a href="#sidebar-侧边栏配置" class="headerlink" title="sidebar 侧边栏配置"></a>sidebar 侧边栏配置</h2><p>搜索 site_state， 文章、标签和分类默认在侧边栏中显示链接。</p>
<h2 id="social-社交链接配置"><a href="#social-社交链接配置" class="headerlink" title="social 社交链接配置"></a>social 社交链接配置</h2><p>搜索 social, 打开或自行添加。</p>
<h2 id="avatar-添加侧边栏头像"><a href="#avatar-添加侧边栏头像" class="headerlink" title="avatar 添加侧边栏头像"></a>avatar 添加侧边栏头像</h2><p>建议使用 对象存储OSS 存储图片或其他文件，易于管理。</p>
<h2 id="creative-commons-知识共享协议"><a href="#creative-commons-知识共享协议" class="headerlink" title="creative_commons 知识共享协议"></a>creative_commons 知识共享协议</h2><ul>
<li>署名（BY）</li>
<li>署名（BY）-禁止演绎（ND）</li>
<li>署名（BY）-非商业性使用（NC）</li>
<li>署名（BY）-非商业性使用（NC）-禁止演绎（ND）</li>
<li>署名（BY）-非商业性使用（NC）-相同方式共享（SA）</li>
<li>署名（BY）-相同方式共享（SA）</li>
</ul>
<h2 id="onmobile"><a href="#onmobile" class="headerlink" title="onmobile"></a>onmobile</h2><p>对于 Muse 和 Mist 两种外观生效，在手机端打开侧边栏。</p>
<h2 id="设置多说-DISQUS-评论"><a href="#设置多说-DISQUS-评论" class="headerlink" title="设置多说 DISQUS 评论"></a>设置多说 DISQUS 评论</h2><p>DISQUS 和 GitHub Pages 有一个相似之处,用户的站点 URL 会生成一个 Shortname, 二级域名与之对应, 所以注册完后点击头像左边的 Admin, 点击 Settings 选择注册的网站, Shortname 在 Website Name 的上面。其实不用查看也可猜出 Shortname, 将域名的 . 替换成 - 即可， 例如 <a href="https://blog.xyang.xin/">https://blog.xyang.xin</a> 对应的 Shortname 为 blog-xyang-xin。</p>
<p>关闭 tags 和 pages 页面的评论窗口，分别在它们的 index 文件添加 comments: false。</p>
<h1 id="基于-GitHub-Pages-的-Hexo-NexT-博客-——-样式优化篇"><a href="#基于-GitHub-Pages-的-Hexo-NexT-博客-——-样式优化篇" class="headerlink" title="基于 GitHub Pages 的 Hexo + NexT 博客 —— 样式优化篇"></a>基于 GitHub Pages 的 Hexo + NexT 博客 —— 样式优化篇</h1><h2 id="为文章边框添加立体阴影效果"><a href="#为文章边框添加立体阴影效果" class="headerlink" title="为文章边框添加立体阴影效果"></a>为文章边框添加立体阴影效果</h2><p>定位：themes/next/source/css/_common/components/post/post.styl文件<br>修改：在use-motion .post 下，添加box-shadow的代码 box-shadow <a href="https://www.cssmatic.com/box-shadow">生成网站</a></p>
<h2 id="修改菜单栏的文字颜色"><a href="#修改菜单栏的文字颜色" class="headerlink" title="修改菜单栏的文字颜色"></a>修改菜单栏的文字颜色</h2><p>定位：themes/next/source/css/_schemes/Mist/menu.styl文件<br>修改：在.menu-item a下添加color: 颜色</p>
<h2 id="修改文章底部的那个带-号的标签"><a href="#修改文章底部的那个带-号的标签" class="headerlink" title="修改文章底部的那个带#号的标签"></a>修改文章底部的那个带#号的标签</h2><p>定位：themes/next/layout/_macro/post.swig<br>修改：搜索 rel=”tag”&gt;#，将 # 换成 <i class="fa fa-tag"></i></p>
<h2 id="文章内链接"><a href="#文章内链接" class="headerlink" title="文章内链接"></a>文章内链接</h2><p>定位：themes/next/source/css/_custom/custom.styl 文件<br>添加：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.post-body p a &#123;</span><br><span class="line">  color: #0593d3;</span><br><span class="line">  border-bottom: none;</span><br><span class="line">  &amp;:hover &#123;</span><br><span class="line">    color: #0477ab;</span><br><span class="line">    text-decoration: underline;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="修改网站背景样式，自动切换背景图"><a href="#修改网站背景样式，自动切换背景图" class="headerlink" title="修改网站背景样式，自动切换背景图"></a>修改网站背景样式，自动切换背景图</h2><p>定位：themes/next/source/css/_custom/custom.styl 文件<br>添加：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 背景</span><br><span class="line">.main-inner &#123; </span><br><span class="line">    margin-top: 60px;</span><br><span class="line">    padding: 60px 60px 60px 60px;</span><br><span class="line">    background: #fff;</span><br><span class="line">	  opacity: 0.9;</span><br><span class="line">    min-height: 500px;</span><br><span class="line">&#125;</span><br><span class="line">body &#123;</span><br><span class="line">    background:url(https://source.unsplash.com/random/1600x900);</span><br><span class="line">    background-repeat: no-repeat;</span><br><span class="line">    background-attachment:fixed;</span><br><span class="line">    background-position:50% 50%;</span><br><span class="line">    background-size:cover;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意：.mian-inner 将覆盖前文提到的文章的阴影将 box-shadow 代码剪切到 .main-inner 里面即可。</p>
<h2 id="对-header-的修改"><a href="#对-header-的修改" class="headerlink" title="对 header 的修改"></a>对 header 的修改</h2><h3 id="更改头部-site-title-的字体颜色"><a href="#更改头部-site-title-的字体颜色" class="headerlink" title="更改头部 site-title 的字体颜色"></a>更改头部 site-title 的字体颜色</h3><p>定位：theme/next/source/css/_common/components/header/site-meta.styl 文件，找到.brand{}。<br>添加：color: 颜色</p>
<h3 id="头部背景颜色与透明度"><a href="#头部背景颜色与透明度" class="headerlink" title="头部背景颜色与透明度"></a>头部背景颜色与透明度</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.header &#123;</span><br><span class="line">          background:rgba(13,26,31,0.8) none repeat scroll !important;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<h2 id="对-footer-的修改"><a href="#对-footer-的修改" class="headerlink" title="对 footer 的修改"></a>对 footer 的修改</h2><h3 id="修改-footer-的文字居中"><a href="#修改-footer-的文字居中" class="headerlink" title="修改 footer 的文字居中"></a>修改 footer 的文字居中</h3><p>定位：themes/next/source/css/_schemes/Mist/index.styl 文件中的 footer。<br>修改：将 .footer-inner 的 text-align: left 修改为 center。</p>
<h3 id="底部文字颜色"><a href="#底部文字颜色" class="headerlink" title="底部文字颜色"></a>底部文字颜色</h3><p>定位：theme/next/source/css/_custom/custom.styl 文件<br>添加：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.footer-inner &#123;color: 颜色代码;&#125;</span><br></pre></td></tr></table></figure>
<h3 id="底部背景颜色与透明度"><a href="#底部背景颜色与透明度" class="headerlink" title="底部背景颜色与透明度"></a>底部背景颜色与透明度</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.footer &#123;</span><br><span class="line">          background:rgba(13,26,31,0.8) none repeat scroll !important;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<h2 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h2><p><a href="http://theme-next.iissnan.com/getting-started.html">开始使用 - NexT 使用文档</a></p>
]]></content>
      <categories>
        <category>信息技术</category>
      </categories>
  </entry>
  <entry>
    <title>Hexo 博客进阶</title>
    <url>/hexo-advance/</url>
    <content><![CDATA[<h2 id="文章简介"><a href="#文章简介" class="headerlink" title="文章简介"></a>文章简介</h2><p>本文介绍 Hexo 博客的一些进阶操作。</p>
<ul>
<li>解决 Github Pages 不被百度抓取的问题；</li>
<li>使用 gulp 压缩资源，实现访问加速。</li>
<li>在博客中添加音频和视频；<span id="more"></span>
<h2 id="Github-Pages-不被百度抓取的方法"><a href="#Github-Pages-不被百度抓取的方法" class="headerlink" title="Github Pages 不被百度抓取的方法"></a>Github Pages 不被百度抓取的方法</h2>并通过域名 CNAME 实现国内外分流，<h3 id="Coding-Pages"><a href="#Coding-Pages" class="headerlink" title="Coding Pages"></a>Coding Pages</h3><a href="https://help.coding.net/docs/devops/cd/static-website.html#%E8%87%AA%E5%AE%9A%E4%B9%89%E5%9F%9F%E5%90%8D%E8%AE%BE%E7%BD%AE">CODING 静态网站服务 - CODING 帮助中心</a></li>
</ul>
<h3 id="私有的-OSS"><a href="#私有的-OSS" class="headerlink" title="私有的 OSS"></a>私有的 OSS</h3><p>以阿里云oss为例<br><img data-src="https://images.xyang.xin/2020-04/1586841854.png" alt="开通子目录首页"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install --save hexo-deployer-oss</span><br></pre></td></tr></table></figure>
<p><code>_config.yml</code> 配置</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">oss</span></span><br><span class="line">  <span class="attr">accessKeyId:</span> <span class="string">&lt;your</span> <span class="string">accessKeyId&gt;</span></span><br><span class="line">  <span class="attr">accessKeySecret:</span> <span class="string">&lt;your</span> <span class="string">accessKeySecret&gt;</span></span><br><span class="line">  <span class="attr">bucket:</span> <span class="string">&lt;your</span> <span class="string">bucket&gt;</span></span><br><span class="line">  <span class="attr">region:</span> <span class="string">&lt;your</span> <span class="string">region&gt;</span></span><br></pre></td></tr></table></figure>
<p>  其中 region 以北京地区的 oss 为例填 <code>oss-cn-beijing</code></p>
<h2 id="使用-gulp-压缩资源"><a href="#使用-gulp-压缩资源" class="headerlink" title="使用 gulp 压缩资源"></a>使用 gulp 压缩资源</h2><p>使用 gulp 压缩资源，提高访问速度。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install gulp-cli -g</span><br><span class="line">npm install gulp gulp-htmlclean gulp-htmlmin gulp-imagemin gulp-clean-css gulp-uglify --save-dev</span><br></pre></td></tr></table></figure>

<p>项目根目录新建<code>gulpfile.babel.js</code>，添加如下内容：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> gulp <span class="keyword">from</span> <span class="string">&#x27;gulp&#x27;</span></span><br><span class="line"><span class="keyword">import</span> cleancss <span class="keyword">from</span> <span class="string">&#x27;gulp-clean-css&#x27;</span></span><br><span class="line"><span class="keyword">import</span> uglify <span class="keyword">from</span> <span class="string">&#x27;gulp-uglify-es&#x27;</span></span><br><span class="line"><span class="keyword">import</span> htmlmin <span class="keyword">from</span> <span class="string">&#x27;gulp-htmlmin&#x27;</span></span><br><span class="line"><span class="keyword">import</span> htmlclean <span class="keyword">from</span> <span class="string">&#x27;gulp-htmlclean&#x27;</span></span><br><span class="line"><span class="keyword">import</span> imagemin <span class="keyword">from</span> <span class="string">&#x27;gulp-imagemin&#x27;</span></span><br><span class="line"><span class="keyword">import</span> babel <span class="keyword">from</span> <span class="string">&#x27;gulp-babel&#x27;</span></span><br><span class="line"></span><br><span class="line">gulp.task(<span class="string">&#x27;minify-html&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> gulp.src(<span class="string">&#x27;./public/**/*.html&#x27;</span>)</span><br><span class="line">    .pipe(htmlclean(&#123;</span><br><span class="line">      <span class="attr">protect</span>: <span class="regexp">/&lt;\!--%fooTemplate\b.*?%--&gt;/g</span>,</span><br><span class="line">      edit: <span class="function">(<span class="params">html</span>) =&gt;</span> &#123; <span class="keyword">return</span> html.replace(<span class="regexp">/\begg(s?)\b/ig</span>, <span class="string">&#x27;omelet$1&#x27;</span>); &#125;</span><br><span class="line">    &#125;))</span><br><span class="line">    .pipe(htmlmin(&#123;</span><br><span class="line">      <span class="attr">removeComments</span>: <span class="literal">true</span>,</span><br><span class="line">      <span class="attr">collapseWhitespace</span>: <span class="literal">true</span>,</span><br><span class="line">      <span class="attr">collapseBooleanAttributes</span>: <span class="literal">true</span>,</span><br><span class="line">      <span class="attr">removeEmptyAttributes</span>: <span class="literal">true</span>,</span><br><span class="line">      <span class="attr">removeScriptTypeAttributes</span>: <span class="literal">true</span>,</span><br><span class="line">      <span class="attr">removeStyleLinkTypeAttributes</span>: <span class="literal">true</span>,</span><br><span class="line">      <span class="attr">minifyJS</span>: <span class="literal">true</span>,</span><br><span class="line">      <span class="attr">minifyCSS</span>: <span class="literal">true</span>,</span><br><span class="line">    &#125;))</span><br><span class="line">    .on(<span class="string">&#x27;error&#x27;</span>, <span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&#x27;html Error!&#x27;</span>, err.message);</span><br><span class="line">      <span class="built_in">this</span>.end();</span><br><span class="line">    &#125;)</span><br><span class="line">    .pipe(gulp.dest(<span class="string">&#x27;./public&#x27;</span>))</span><br><span class="line">&#125;);</span><br><span class="line">gulp.task(<span class="string">&#x27;clean-css&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> gulp.src(<span class="string">&#x27;./public/**/*.css&#x27;</span>)</span><br><span class="line">    .pipe(cleancss())</span><br><span class="line">    .pipe(gulp.dest(<span class="string">&#x27;./public&#x27;</span>));</span><br><span class="line">&#125;);</span><br><span class="line">gulp.task(<span class="string">&#x27;minify-js&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> gulp.src(<span class="string">&#x27;./public/js/**/*.js&#x27;</span>)</span><br><span class="line">    .pipe(uglify())</span><br><span class="line">    .pipe(gulp.dest(<span class="string">&#x27;./public&#x27;</span>));</span><br><span class="line">&#125;);</span><br><span class="line">gulp.task(<span class="string">&#x27;minify-images&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> gulp.src(<span class="string">&#x27;./public/images/**/*.*&#x27;</span>)</span><br><span class="line">    .pipe(imagemin())</span><br><span class="line">    .pipe(gulp.dest(<span class="string">&#x27;./public/images&#x27;</span>))</span><br><span class="line">&#125;);</span><br><span class="line">gulp.task(<span class="string">&#x27;default&#x27;</span>, gulp.parallel(<span class="string">&#x27;minify-html&#x27;</span>, <span class="string">&#x27;clean-css&#x27;</span>, <span class="string">&#x27;minify-js&#x27;</span>, <span class="string">&#x27;minify-images&#x27;</span>, <span class="function">(<span class="params">done</span>) =&gt;</span> &#123;</span><br><span class="line">  done();</span><br><span class="line">&#125;));</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>由于是 es6 语法， 需要使用 babel 转译。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install --save-dev gulp-babel @babel/register @babel/preset-env @babel/core</span><br></pre></td></tr></table></figure>
<p>创建<code>.babel.json</code> 文件，添加内容如下：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;presets&quot;</span>: [</span><br><span class="line">    <span class="string">&quot;@babel/env&quot;</span></span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">&quot;plugins&quot;</span>: []</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>终端执行如下命令即可：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo g &amp;&amp; gulp</span><br></pre></td></tr></table></figure>

<p>如有报错，可以尝试删除<code>node_modules</code>文件，然后重新执行<code>npm install</code>。</p>
<h2 id="在博客中插入音频与视频"><a href="#在博客中插入音频与视频" class="headerlink" title="在博客中插入音频与视频"></a>在博客中插入音频与视频</h2><h3 id="音频"><a href="#音频" class="headerlink" title="音频"></a>音频</h3><h4 id="更快捷的方案一"><a href="#更快捷的方案一" class="headerlink" title="更快捷的方案一"></a>更快捷的方案一</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">frameborder</span>=<span class="string">&quot;no&quot;</span> <span class="attr">border</span>=<span class="string">&quot;0&quot;</span> <span class="attr">marginwidth</span>=<span class="string">&quot;0&quot;</span> <span class="attr">marginheight</span>=<span class="string">&quot;0&quot;</span> <span class="attr">width</span>=<span class="string">430</span> <span class="attr">height</span>=<span class="string">86</span> <span class="attr">src</span>=<span class="string">&quot;XXX&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br></pre></td></tr></table></figure>
<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=430 height=86 src="https://music.xyang.xin/%E5%9C%A8%E8%BF%99%E4%B8%AA%E4%B8%96%E7%95%8C%E7%9B%B8%E9%81%87.mp3"></iframe>

<h4 id="更强大的方案二（Github）"><a href="#更强大的方案二（Github）" class="headerlink" title="更强大的方案二（Github）"></a>更强大的方案二（<a href="https://github.com/MoePlayer/hexo-tag-aplayer#usage">Github</a>）</h4><h3 id="视频"><a href="#视频" class="headerlink" title="视频"></a>视频</h3><h4 id="更快捷的标签方式"><a href="#更快捷的标签方式" class="headerlink" title="更快捷的标签方式"></a>更快捷的标签方式</h4><p>iframe 将web页嵌入到另一个网页</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">width</span>=<span class="string">&quot;854&quot;</span> <span class="attr">height</span>=<span class="string">&quot;480&quot;</span> <span class="attr">src</span>=<span class="string">&quot;//player.bilibili.com/player.html?aid=51918958&amp;cid=90895494&amp;page=1&quot;</span> <span class="attr">scrolling</span>=<span class="string">&quot;no&quot;</span> <span class="attr">border</span>=<span class="string">&quot;0&quot;</span> <span class="attr">frameborder</span>=<span class="string">&quot;no&quot;</span> <span class="attr">framespacing</span>=<span class="string">&quot;0&quot;</span> <span class="attr">allowfullscreen</span>=<span class="string">&quot;true&quot;</span>&gt;</span> <span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br></pre></td></tr></table></figure>

<iframe width="854" height="480" src="//player.bilibili.com/player.html?aid=51918958&cid=90895494&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>

<h4 id="更强大的-hexo-tag-dplayer-插件"><a href="#更强大的-hexo-tag-dplayer-插件" class="headerlink" title="更强大的 hexo-tag-dplayer 插件"></a>更强大的 <a href="https://github.com/MoePlayer/hexo-tag-dplayer">hexo-tag-dplayer</a> 插件</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install hexo-tag-dplayer --save</span><br></pre></td></tr></table></figure>

<h3 id="PDF"><a href="#PDF" class="headerlink" title="PDF"></a>PDF</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">object</span> <span class="attr">data</span>=<span class="string">&quot;mypdf.pdf&quot;</span> <span class="attr">type</span>=<span class="string">&quot;application/pdf&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">width</span>=<span class="string">&quot;800&quot;</span> <span class="attr">height</span>=<span class="string">&quot;1200&quot;</span> <span class="attr">typemustmatch</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>You don&#x27;t have a PDF plugin, but you can <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;myfile.pdf&quot;</span>&gt;</span>download the PDF file.<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">object</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://developer.mozilla.org/zh-CN/docs/Learn/HTML/Multimedia_and_embedding/%E5%85%B6%E4%BB%96%E5%B5%8C%E5%85%A5%E6%8A%80%E6%9C%AF">从对象到iframe - 其他嵌入技术 - 学习 Web 开发 | MDN</a><br><a href="https://luanzhuxian.github.io/post/e5ac3b51.html">使用 Gulp 压缩 Hexo | 栾铸显的博客</a><br><a href="https://shuoit.net/tech-notes/use-gulp-to-speed-hexo-1547999542.html">引入gulp压缩整站资源进一步提高写作效率 - 说IT</a></p>
]]></content>
      <categories>
        <category>信息技术</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>从 Github 下载目标仓库指定文件夹</title>
    <url>/github-download-folder/</url>
    <content><![CDATA[<p>从 Github 下载目标仓库指定文件夹。</p>
<span id="more"></span>

<p><a href="https://github.com/HR/github-clone">HR/github-clone: ⬇️ git clone repo subdirectories</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pip install git+git://github.com/HR/github-clone#egg=ghclone</span><br><span class="line">ghclone https://github.com/HR/Crypter/tree/master/app</span><br><span class="line">ghclone https://github.com/HR/Picturesque/tree/master/app/src -t li50d67757gm20556d53f08126215725a698560b</span><br></pre></td></tr></table></figure>
<p>下载私有库文件的时候需要 -t 参数，需要提供账户的 OAuth token：<br><a href="https://docs.github.com/en/github/authenticating-to-github/creating-a-personal-access-token">Creating a personal access token - GitHub Docs</a></p>
<hr>
<h2 id="git-svn-踩坑日记"><a href="#git-svn-踩坑日记" class="headerlink" title="git-svn 踩坑日记"></a>git-svn 踩坑日记</h2><p>太晚了，踩了半天坑，没踩出来，不过记录一下吧，没准以后还会用到 git-svn，再继续解决。<br>目标是通过 git svn 下载资源的目录，想法是从 stackoverflow 来的，我对 svn 一点都不了解：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git svn clone https://github.com/user/repo/folder/folder</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">xcode-select --install</span><br></pre></td></tr></table></figure>
<p>执行前面的命令检查 CommandLineTools 是否安装，如有弹窗选择：是。一般重装系统或者系统大版本升级都要重新安装一次。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ brew reinstall git</span><br><span class="line">$ brew install apr-util</span><br><span class="line">$ brew install perl</span><br><span class="line">$ PERL_MM_OPT=&quot;INSTALL_BASE=$HOME/perl5&quot; cpan local::lib</span><br><span class="line">$ echo &#x27;eval &quot;$(perl -I$HOME/perl5/lib/perl5 -Mlocal::lib=$HOME/perl5)&quot;&#x27; &gt;&gt; ~/.zshrc</span><br><span class="line">$ echo &#x27;export PATH=&quot;/usr/local/opt/apr/bin:$PATH&quot;&#x27; &gt;&gt; ~/.zshrc</span><br><span class="line">$ echo &#x27;export PATH=&quot;/usr/local/opt/apr-util/bin:$PATH&quot;&#x27; &gt;&gt; ~/.zshrc</span><br><span class="line">$ cpan SVN::Core  # 这命令耗时很久</span><br></pre></td></tr></table></figure>

<h3 id="报错信息："><a href="#报错信息：" class="headerlink" title="报错信息："></a>报错信息：</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Can&#x27;t locate SVN/Core.pm in @INC (you may need to install the SVN::Core module) (@INC contains: /usr/local/Cellar/git/2.27.0/share/perl5</span><br></pre></td></tr></table></figure>

<p>修改文件<code>/usr/local/opt/git/libexec/git-core/git-svn</code>的第一行， <code>#!/usr/bin/perl</code> 为 <code>#!/usr/local/bin/perl</code>。</p>
<h3 id="最终报错："><a href="#最终报错：" class="headerlink" title="最终报错："></a>最终报错：</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Bad URL passed to RA layer: Unrecognized URL scheme for &#x27;https://github.com/PacktPub</span><br><span class="line">lishing/Hands-On-Full-Stack-Development-with-Go&#x27; at /usr/local/Cellar/git/2.27.0/sha</span><br><span class="line">re/perl5/Git/SVN.pm line 148.</span><br></pre></td></tr></table></figure>
<p>git 关联的 svn 是它自带的 svn：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git svn --version</span><br><span class="line"># // git-svn version 2.27.0 (svn 1.8.11)</span><br><span class="line">$ svn --version</span><br><span class="line"># //svn, version 1.14.0 (r1876290)</span><br></pre></td></tr></table></figure>
<p>和上一个报错有共同之处。</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul>
<li><a href="https://github.com/HR/github-clone">HR/github-clone: ⬇️ git clone repo subdirectories</a></li>
<li><a href="https://teratail.com/questions/268932">Perl - git-svnを使用しようとした際に出るCan’t locate SVN/Core.pmというエラーの解決方法｜teratail</a></li>
<li><a href="https://stackoverflow.com/questions/61637163/git-svn-cant-locate-svn-core-pm-after-fresh-installation-of-macos-catalina-10-1">perl - git-svn Can’t locate SVN/Core.pm after fresh installation of macOS Catalina 10.15.4 - Stack Overflow</a></li>
</ul>
]]></content>
      <categories>
        <category>信息技术</category>
      </categories>
      <tags>
        <tag>Github</tag>
        <tag>git-svn</tag>
      </tags>
  </entry>
  <entry>
    <title>由简入深配置 iTem2 终端</title>
    <url>/iterm2/</url>
    <content><![CDATA[<h1 id="iTerm2"><a href="#iTerm2" class="headerlink" title="iTerm2"></a>iTerm2</h1><p>brew 安装 zsh<br>    <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">brew install zsh</span><br><span class="line">sudo chsh -s /usr/local/bin/zsh</span><br></pre></td></tr></table></figure><br>从 zsh 切换回 bash<br>    <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">chsh -s /bin/bash</span><br></pre></td></tr></table></figure></p>
<span id="more"></span>
<p>PS：如果从 bash 切换到 zsh，但想保留 bash 所设置的环境变量，可在 .zshrc文件末尾添加 </p>
<pre><code><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">source ~/.bash_profile</span><br></pre></td></tr></table></figure>
</code></pre>
<p>安装 oh my zsh  </p>
<pre><code><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">curl -L https://github.com/robbyrussell/oh-my-zsh/raw/master/tools/install.sh | sh</span><br></pre></td></tr></table></figure>
</code></pre>
<h2 id="自动提示命令"><a href="#自动提示命令" class="headerlink" title="自动提示命令"></a>自动提示命令</h2><p>我们输入命令时，终端会自动提示你接下来可能要输入的命令，这时按 → 便可输出这些命令，非常方便。<br>设置如下：</p>
<ul>
<li><p>克隆仓库到本地 ~/.oh-my-zsh/custom/plugins 路径下</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git clone git://github.com/zsh-users/zsh-autosuggestions $ZSH_CUSTOM/plugins/zsh-autosuggestions</span><br></pre></td></tr></table></figure></li>
<li><p>用 vim  ~/.zshrc 打开文件，下滑找到插件设置命令，默认是 <code>plugins=(git)</code> ，我们把它修改为</p>
<p>  <code>plugins=(zsh-autosuggestions git)</code></p>
</li>
<li><p>要修改提示命令的颜色才看得到效果<br><img data-src="https://images.xyang.xin/2018-11/1541985092.png" alt="-c666"><br>然后这样 vim 的颜色也会随之改变</p>
</li>
<li><p>修改提示颜色在 .zshrc 文件中添加如下命令</p>
<p>  <code>ZSH_AUTOSUGGEST_HIGHLIGHT_STYLE=&#39;fg=value&#39;</code></p>
</li>
</ul>
<h2 id="主题"><a href="#主题" class="headerlink" title="主题"></a>主题</h2><p>安装成功后，用vim ~/.zshrc打开隐藏文件，修改主题为agnoster</p>
<p>PS：<a href="https://github.com/powerline/fonts/blob/master/Meslo%20Slashed/Meslo%20LG%20M%20Regular%20for%20Powerline.ttf">zsh主题</a>，参考主题连接选择自己喜欢的主题。</p>
<pre><code>`ZSH_THEME=&quot;agnoster&quot;`
</code></pre>
<p>应用这个主题需要特殊的字体支持，否则会出现乱码情况，这时我们来配置字体：</p>
<ul>
<li><p>使用<a href="https://github.com/powerline/fonts/blob/master/Meslo%20Slashed/Meslo%20LG%20M%20Regular%20for%20Powerline.ttf"> Meslo</a> 字体，点开连接点击 view raw 下载字体。</p>
</li>
<li><p>安装字体到系统字体册。</p>
<h2 id="语法高亮"><a href="#语法高亮" class="headerlink" title="语法高亮"></a>语法高亮</h2><p>  <code>brew install zsh-syntax-highlighting</code><br>在.zshrc中追加以下内容:  </p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">source /usr/local/share/zsh-syntax-highlighting/zsh-syntax-highlighting.zsh</span><br><span class="line">plugins=(</span><br><span class="line">    git</span><br><span class="line">    zsh-autosuggestions</span><br><span class="line">    zsh-syntax-highlighting # 务必在最后</span><br><span class="line">    ）</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="给-iTerm-中Vim配色"><a href="#给-iTerm-中Vim配色" class="headerlink" title="给 iTerm 中Vim配色"></a>给 iTerm 中Vim配色</h2><p>首先<a href="https://github.com/altercation/solarized">下载solarized</a>  </p>
<pre><code><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ cd solarized  </span><br><span class="line">$ cd vim-colors-solarized/colors  </span><br><span class="line">$ mkdir -p ~/.vim/colors   </span><br><span class="line">$ cp solarized.vim ~/.vim/colors/</span><br><span class="line">$ vi ~/.vimrc  </span><br></pre></td></tr></table></figure>
</code></pre>
<p>加入下面三行设置即可：  </p>
<pre><code><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">syntax enable  </span><br><span class="line">set background=dark  </span><br><span class="line">colorscheme solarized</span><br></pre></td></tr></table></figure>
</code></pre>
<h2 id="给ls配色"><a href="#给ls配色" class="headerlink" title="给ls配色"></a>给ls配色</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vim .zshrc</span><br><span class="line">export LSCOLORS=&quot;exfxcxdxbxexexabagacad&quot;</span><br></pre></td></tr></table></figure>

<h2 id="安装-thefuck-纠错插件"><a href="#安装-thefuck-纠错插件" class="headerlink" title="安装 thefuck 纠错插件"></a>安装 thefuck 纠错插件</h2><p><code>brew install thefuck</code><br>修正上一条错误的输入</p>
<h2 id="安装-autojump"><a href="#安装-autojump" class="headerlink" title="安装 autojump"></a>安装 autojump</h2><p><code>brew install autojump</code><br> // zshrc新增<br> [[ -s $(brew –prefix)/etc/profile.d/autojump.sh ]] &amp;&amp; . $(brew –prefix)/etc/profile.d/autojump.sh<br> // 生效配置<br><code> source ~/.zshrc</code></p>
<h2 id="让终端走代理"><a href="#让终端走代理" class="headerlink" title="让终端走代理"></a>让终端走代理</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">export http_proxy=http://127.0.0.1:1080;export https_proxy=http://127.0.0.1:1080</span><br><span class="line">curl pub.dartlang.org  # 无输出则设置成功</span><br><span class="line"># 需要代理服务器支持 http</span><br></pre></td></tr></table></figure>
<h2 id="iterm2-vim-开启滚轮"><a href="#iterm2-vim-开启滚轮" class="headerlink" title="iterm2 vim 开启滚轮"></a>iterm2 vim 开启滚轮</h2><p>在 iterm2中配置如下<br><img data-src="https://images.xyang.xin/2018-11/1541989133.png" alt="-c666"></p>
<h2 id="配置-download-with-scp"><a href="#配置-download-with-scp" class="headerlink" title="配置 download with scp"></a>配置 download with scp</h2><p>本地和服务器都需要安装 iterm2 的 shell integration。</p>
<p>在服务器端配置文件 <code>.zshrc</code> 下面这段<strong>之后</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">test -e &quot;$&#123;HOME&#125;/.iterm2_shell_integration.zsh&quot; &amp;&amp; source &quot;$&#123;HOME&#125;/.iterm2_shell_integration.zsh&quot; || true</span><br></pre></td></tr></table></figure>
<p>添加：<br><code>export iterm2_hostname=远程服务器公网Ip</code></p>
<p>在服务器端，ls 然后点击鼠标右键，可以下载文件。<br>在客户端，拖拽，然后按住 option 键，拖拽至服务器终端，可以进行上传。<br>使用的是 scp 协议。</p>
]]></content>
      <categories>
        <category>信息技术</category>
      </categories>
      <tags>
        <tag>开发工具</tag>
      </tags>
  </entry>
  <entry>
    <title>编程语言之 Java</title>
    <url>/java-language/</url>
    <content><![CDATA[<h1 id="Integer-parseInt-与-Integer-valueOf-的比较"><a href="#Integer-parseInt-与-Integer-valueOf-的比较" class="headerlink" title="Integer.parseInt() 与 Integer.valueOf() 的比较"></a>Integer.parseInt() 与 Integer.valueOf() 的比较</h1><p>Integer.parseInt() 和 Integer.valueOf() 都是用来 将String转换为Int的。</p>
<ul>
<li>Integer.parseInt()，返回一个原子类型int.<ul>
<li>parseInt() 只是调用parseInt, 并且返回原子类型int.</li>
</ul>
</li>
<li>Integer.valueOf(), 返回的是封装的Integer对象。<ul>
<li> valueOf 也会调用parseInt, 但是返回Integer对象。而且它会维护一个cache，如果int值在cache范围内，直接从cache中取对象，如果不在，则会新创建一个对象。</li>
</ul>
</li>
</ul>
<p>如果我们只是需要一个int值，parseInt是合适的，而且效率要高，但是如果用valueOf就多此一举了，性能会下降。<br><a href="https://www.imooc.com/article/37688">🐱文章</a></p>
]]></content>
      <categories>
        <category>信息技术</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>学习 HTTP 协议笔记</title>
    <url>/learn-http-basics/</url>
    <content><![CDATA[<h2 id="网络模型"><a href="#网络模型" class="headerlink" title="网络模型"></a>网络模型</h2><p>五层网络模型：<br><img data-src="https://images.xyang.xin/2020%2F09%2F03%2Fclassic-five-layer-model.jpg?x-oss-process=style/title_800" alt="classic-five-layer-model.jpg"></p>
<span id="more"></span>
<p><img data-src="https://images.xyang.xin/2020%2F09%2F03%2F16fb20a7abacc050.png?x-oss-process=style/title_800" alt="16fb20a7abacc050.png"><br>OSI 七层模型是国际标准化组织的标准，由于前者过于复杂且指定周期长，在整套标准推出之前，TCP/IP 模型就已经在全球范围内被广泛使用了，所以TCP/IP模型成了事实上的国际标准。我们在学习和开发中，将两者结合，这就是五层网络模型。</p>
<h3 id="协议举例及功能"><a href="#协议举例及功能" class="headerlink" title="协议举例及功能"></a>协议举例及功能</h3><h4 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h4><p>功能：为应用软件提供了很多服务。</p>
<p>协议： HTTP、DNS、FTP（文件传输）、SSH、Telnet、SMTP（电子邮件）</p>
<h4 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h4><p>功能：向用户提供可靠的端到端服务。</p>
<p>协议： TCP、UDP</p>
<h4 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h4><p>功能：寻址、路由。</p>
<p>协议：IPV4、IPV6、RARP、ICMP(V4、V6)</p>
<p>设备：路由器、三层交换机</p>
<h4 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h4><p>功能：在通信实体间建立数据链路连接。</p>
<p>协议：以太网、Wi-Fi</p>
<p>设备：网卡、交换机</p>
<h4 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h4><p>功能：定义物理设备如何传输数据。</p>
<p>设备：光纤、集线器、RJ-45接头</p>
<h2 id="HTTP-协议发展历史"><a href="#HTTP-协议发展历史" class="headerlink" title="HTTP 协议发展历史"></a>HTTP 协议发展历史</h2><h3 id="HTTP-0-9"><a href="#HTTP-0-9" class="headerlink" title="HTTP/0.9"></a>HTTP/0.9</h3><p>HTTP 最早版本是1991年发布的0.9版本。该版本有如下特点：</p>
<ol>
<li>只有一个命令<code>GET</code>。</li>
<li>没有<code>HEADER</code>等描述数据的信息。</li>
<li>协议规定，服务器只能回应HTML格式的字符串，不能回应别的格式。</li>
<li>服务器发送完毕，就关闭TCP连接。</li>
</ol>
<h3 id="HTTP-1-0"><a href="#HTTP-1-0" class="headerlink" title="HTTP/1.0"></a>HTTP/1.0</h3><p>1996年5月，HTTP/1.0发布，内容大大增加：</p>
<ol>
<li>任何格式的内容都可以发送。</li>
<li>新增<code>POST</code>和<code>HEAD</code>命令。</li>
<li>每次通信都必须包含头信息（HTTP header）。</li>
<li>新增状态码（status code）。</li>
<li>新增多字符集支持、多部分发送（multi-part type）、权限（authorization）、缓存（cache）、内容编码（content encoding）等。</li>
</ol>
<h3 id="HTTP-1-1"><a href="#HTTP-1-1" class="headerlink" title="HTTP/1.1"></a>HTTP/1.1</h3><p>1997年1月，HTTP/1.1 版本发布，至今（2020年）仍是最流行的版本。新增的功能有：</p>
<h4 id="1-持久连接（persistent-connection）"><a href="#1-持久连接（persistent-connection）" class="headerlink" title="1. 持久连接（persistent connection）"></a>1. 持久连接（persistent connection）</h4><p>即TCP连接默认不关闭，可以被多个请求复用。默认开启<code>Connection: keep-alive</code>。</p>
<p>客户端和服务器发现对方一段时间没有活动，就可以主动关闭连接。不过，规范的做法是，客户端在最后一个请求时，发送<code>Connection:close</code>，明确要求服务器关闭TCP连接。</p>
<p>目前，对于同一个域名，大多数浏览器允许同时建立6个持久连接。</p>
<h4 id="2-管道机制（pipelining）"><a href="#2-管道机制（pipelining）" class="headerlink" title="2. 管道机制（pipelining）"></a>2. 管道机制（pipelining）</h4><p>即在同一个TCP连接里面，客户端可以同时发送多个请求。</p>
<p>举例来说，客户端需要请求两个资源。以前的做法是，在同一个TCP连接里面，先发送A请求，然后等待服务器做出回应，收到后再发出B请求。管道机制则是允许浏览器同时发出A请求和B请求，但是服务器还是按照顺序，先回应A请求，完成后再回应B请求。</p>
<h4 id="3-其他"><a href="#3-其他" class="headerlink" title="3. 其他"></a>3. 其他</h4><p>新增动词方法：<code>PUT</code>、<code>PATCH</code>、<code>OPTIONS</code>、<code>DELETE</code></p>
<p>客户端请求头新增<code>Host</code>字段，用来指定服务器的域名。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Host: www.example.com</span><br></pre></td></tr></table></figure>

<p>有了<code>Host</code>字段，就可以将请求发往同一台服务器上的不同网站。虚拟主机技术就是利用的这一点。在apache，ngnix环境下，直接通过配置文件cfg文件来配置不同的域名和网站根目录之间的映射关系。</p>
<h3 id="HTTP-2"><a href="#HTTP-2" class="headerlink" title="HTTP/2"></a>HTTP/2</h3><ol>
<li>所有数据以二进制传输</li>
<li>多工。双向的、实时的通信，就叫做多工。举例来说，在一个TCP连接里面，服务器同时收到了A请求和B请求，于是先回应A请求，结果发现处理过程非常耗时，于是就发送A请求已经处理好的部分， 接着回应B请求，完成后，再发送A请求剩下的部分。</li>
<li>头信息压缩以及服务器推送等提高效率的功能。</li>
</ol>
<h2 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h2><p>进行三次握手的目的是连接服务器指定端口，建立TCP连接，并同步连接双方的序列号和确认号，交换TCP窗口大小信息。三次握手由客户端发起，第一次握手， 客户端创建一个请求数据包，指明客户端打算连接服务器的端口，发送完毕进入<code>SYN_SEND</code>状态；二次握手，服务器端发送确认包，进入<code>SYN_RCVD</code>状态；三次握手，客户端再次发送确认包。发送完毕后，客户端进入<code>ESTABILISHED</code>状态，服务器收到后也进入<code>ESTABLISHED</code>状态。</p>
<p>二次握手后客户端和服务器端本来已经相互通信，交换信息了，本来可以直接建立连接了。但是为什么要进行三次握手呢？</p>
<p>这是服务器端为防止服务器端误会客户端的意思，服务器端开启无用连接，而浪费资源。</p>
<p>这就好比，一个你一直有好感的女孩向你发了个信息，“我喜欢你”。收到消息，你激动不已，你发了封信息“我也爱你，咱们交往吧”，然后就辗转反侧等消息，整夜没睡。但是第二天女孩说，不好意思，人家是玩的真心话大冒险。二次握手，不可靠。就是这个道理。如果有良知的美丽女孩当天就应该给人家回信进行第三次握手，拒绝或者接受。</p>
<h2 id="URI、URL和URN的区别"><a href="#URI、URL和URN的区别" class="headerlink" title="URI、URL和URN的区别"></a>URI、URL和URN的区别</h2><p>URI(Uniform resource identifier) 统一资源标识符</p>
<p>URL(uniform resource locator) 统一资源定位器（网址）<br>URN(uniform resource name) 统一资源命名（ISBN 编码）</p>
<p>URL 是 URI，URN 也是 URI。URL 和 URN 两种兼备也是 URI。<br><img data-src="https://images.xyang.xin/2020%2F09%2F03%2Furi-url-urn.png" alt="uri-url-urn.png"><br>URN定义某事物的身份，而URL提供查找该事物的方法。</p>
<p>用于标识唯一书目的ISBN系统是一个典型的URN使用范例。例如，ISBN 0-486-27557-4无二义性地标识出莎士比亚的戏剧《罗密欧与朱丽叶》的某一特定版本。为获得该资源并阅读该书，人们需要它的位置，也就是一个URL地址。在类Unix操作系统中，一个典型的URL地址可能是一个文件目录，例如file:///home/username/RomeoAndJuliet.pdf。该URL标识出存储于本地硬盘中的电子书文件。因此，URL和URN有着互补的作用。</p>
<h2 id="HTTP-报文格式"><a href="#HTTP-报文格式" class="headerlink" title="HTTP 报文格式"></a>HTTP 报文格式</h2><p>请求报文：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET /index.txt HTTP/1.0</span><br><span class="line">User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_10_5)</span><br><span class="line">Accept: */*</span><br><span class="line">Accept-Language: en</span><br></pre></td></tr></table></figure>
<p>相应报文：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">HTTP/1.0 200 OK </span><br><span class="line">Content-Type: text/plain</span><br><span class="line">Content-Length: 137582</span><br><span class="line">Expires: Thu, 05 Dec 1997 16:00:00 GMT</span><br><span class="line">Last-Modified: Wed, 5 August 1996 15:55:28 GMT</span><br><span class="line">Server: Apache 0.84</span><br><span class="line"></span><br><span class="line">&lt;html&gt;</span><br><span class="line">  &lt;body&gt;Hello World&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>TIP：其中 <code>GET</code>、<code>POST</code>等命令是语义化的定义，<code>GET</code>请求一个数据，<code>POST</code>创建一个数据，但是他们都只是协议上规定的，不是强约束的，可以手动修改其行为，有点像HTML5标签。</p>
</blockquote>
<h2 id="HTTP-状态码"><a href="#HTTP-状态码" class="headerlink" title="HTTP 状态码"></a>HTTP 状态码</h2><p>响应分为五类：<br>100-199 服务器收到请求<br>200-299 成功响应<br>300-399 重定向<br>400-499 客户端错误<br>500-599 服务器错误</p>
<p>常见的状态码：<br>200 请求成功<br>301 永久重定向（浏览器会记住返回301的网址，下次直接访问另一个网址）<br>302 临时重定向（下次再访问旧网址，还是要先访问旧网址，再根据 location 访问新网址）<br>304 资源未被修改<br>403 没有权限<br>404 资源未找到<br>500 服务器遇到了不知道如何处理的问题<br>504 网关超时</p>
<h2 id="跨域"><a href="#跨域" class="headerlink" title="跨域"></a>跨域</h2><p>同源政策：协议、域名、端口号都相同则同源。如果不同源有如下限制：</p>
<ol>
<li>当前域下的 JS 脚本不能访问其他作用域的 cookie、localStorage 和 indexDB。</li>
<li>当前域下的 JS 脚本不能操作访问其他域下的 DOM。</li>
<li>当前域下的 ajax 无法发送跨域请求。</li>
</ol>
<p>通过 <code>http://127.0.0.1:8888</code> 获取到文件<code>index.html</code>，如果文件中有一段js脚本，请求<code>http://127.0.0.1:8887</code>的数据，也就是不同源的数据，浏览器会向8887服务器发送请求，并且接收返回内容，但是会检查是否有<code>Access-Control-Allow-Origin</code>头，并且设置为允许，就会将响应内容忽略掉，并返回错误。</p>
<p>解决办法：</p>
<ol>
<li>CORS。8887的服务端响应时可以添加<code>&quot;Access-Control-Allow-Origin&quot;:&quot;http://127.0.0.1:8888&quot;</code>消息头，允许跨域请求。通过<code>Access-Control-Allow-Headers:&quot;*&quot;</code>允许跨域请求时添加的某些请求头。</li>
<li>JSONP。浏览器允许<code>&lt;link&gt;</code>、<code>&lt;img&gt;</code>、<code>&lt;script&gt;</code> 在标签上写 URL 加载内容允许跨域。JSONP 就是在<code>&lt;script&gt;</code>上加载一个链接，向服务器请求JSON数据，服务器收到请求后，将数据放在一个指定名字的回调函数里传回来，客户端修改返回的内容。</li>
<li>WebSocket。该协议不实行同源政策，只要服务器支持，就可以实现跨域。</li>
<li>window.postMessage。HTML5的跨文档通信API，允许跨窗口通信，不论这两个窗口是否同源。</li>
<li>一级域名相同的域名，可以通过设置<code>document.domain=&quot;example.com&quot;</code>来共享Cookie。</li>
</ol>
<p>以上办法解决的跨域限制是不同的，例如：CORS、JSONP和WebSocket解决了AJAX跨域的问题。而<code>document.domain</code>解决了Cookie跨域的问题，<code>window.postMessage</code>解决了DOM跨域的问题。DOM跨域，典型的例子是<code>iframe</code>窗口和<code>window.open</code>方法打开的窗口，它们与父窗口无法通信。</p>
<h2 id="HTTP-缓存"><a href="#HTTP-缓存" class="headerlink" title="HTTP 缓存"></a>HTTP 缓存</h2><h3 id="Cache-Control-头"><a href="#Cache-Control-头" class="headerlink" title="Cache-Control 头"></a>Cache-Control 头</h3><p>HTTP/1.1 定义的<code>Cache-Control</code>头用来区分对缓存机制的支持情况，请求头和响应头都支持这个属性。通过它提供的不同值来定义缓存策略。<code>*</code>表示浏览器端常用的。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// *缓存中不得存储任何关于客户端和服务端响应的内容。</span><br><span class="line">Cache-Control: no-store</span><br><span class="line"></span><br><span class="line">// *每次有请求发出时，缓存会将此请求发到服务器，服务器验证是否过期，</span><br><span class="line">// 若未过期返回304，缓存才使用本地缓存副本。</span><br><span class="line">Cache-Control: no-cache</span><br><span class="line"></span><br><span class="line">// *可以被任何中间人（中间代理、CDN等）缓存。</span><br><span class="line">Cache-Control: public</span><br><span class="line"></span><br><span class="line">// *中间人不能缓存此响应，该响应只能应用于浏览器私有缓存中。</span><br><span class="line">Cache-Control: private</span><br><span class="line"></span><br><span class="line">// *表示资源能够被缓存的最大时间。</span><br><span class="line">Cache-Control: max-age=31536000</span><br><span class="line"></span><br><span class="line">// 中间人的资源缓存时间将不使用max-age，而使用s-maxage。</span><br><span class="line">Cache-Control: s-maxage=31536000</span><br><span class="line"></span><br><span class="line">// *保证已过期的缓存不被使用，必须从服务端重新获取请求。</span><br><span class="line">Cache-Control: must-revalidate</span><br><span class="line"></span><br><span class="line">Cache-Control: proxy-revalidate</span><br><span class="line"></span><br><span class="line">// 浏览器特定时间内仍可使用过期的缓存。</span><br><span class="line">Cache-Control: max-stale = 31536000</span><br><span class="line"></span><br><span class="line">// 禁止中间人进行压缩、格式转换等。</span><br><span class="line">Cache-Control: no-transform</span><br></pre></td></tr></table></figure>

<h3 id="缓存验证"><a href="#缓存验证" class="headerlink" title="缓存验证"></a>缓存验证</h3><h4 id="Expire"><a href="#Expire" class="headerlink" title="Expire"></a>Expire</h4><p>Expire 是 HttpHeader 中代表资源的过期时间，由服务器端设置。如果带有 Expire ，则在 Expire 过期前不会发生 Http 请求，直接从缓存中读取。用户强制刷新例外（Windows:<code>ctrl+F5</code>，Mac:<code>command+option+R</code>），强制刷新是指无论如何都从服务器重新获取数据。</p>
<h4 id="Last-Modified"><a href="#Last-Modified" class="headerlink" title="Last-Modified"></a>Last-Modified</h4><p>Last-Modified 是 HttpHeader 中的资源的上次修改时间，如果带有 Last-Modified ，下一次发送 Http 请求时，将会发生带 If-modified-since 的 HttpHeader。与服务器端进行对比，如果没有过期，将会收到 304 的响应，从缓存中读取。</p>
<h4 id="Etag"><a href="#Etag" class="headerlink" title="Etag"></a>Etag</h4><p>Etag 是 HttpHeader 中代表资源的标签，在服务器端生成。如果带有 Etag ，下一次发送带 Etag 的请求，如果 Etag 没有变化将收到 304 的响应，从缓存中读取。<br>Etag 在使用时要注意相同资源多台 Web 服务器的 Etag 的一致性。所以分布式环境（比如CDN）很少使用ETag。</p>
<p>区别：<br>Expire 兼容 HTTP/1.0 浏览器。<br>Etag 更加严格的验证，可以可靠的比较指纹。<br>Last-Modified 不验证实际页面内容是否更改，对页面频繁更改的网页更加有利。</p>
<h2 id="Cookie-和-Session"><a href="#Cookie-和-Session" class="headerlink" title="Cookie 和 Session"></a>Cookie 和 Session</h2><p>Cookie 在服务端返回数据的时候通过<code>Set-Cookie</code>设置，浏览器获取Cookie后保存在本地，下次请求会自动带上，Cookie 是键值对，可以设置多个。<code>max-age</code>和<code>expires</code>设置过期时间，HttpOnly无法通过<code>document.cookie</code>访问。Session与之类似。<br>不过Session与Cookie不同之处在于，Cookie把数据放在客户端，而Session把数据放在服务器端。<br>将登陆信息等重要信息存放为Session，其他信息放在Cookie中。</p>
<p> Cookie, LocalStorage 与 SessionStorage 的区别：<br><img data-src="http://images.xyang.xin/2020%2F09%2F04%2Fcookie-localstorage-sessionstorage.png" alt="cookie-localstorage-sessionstorage.png"></p>
<h2 id="长连接和短连接"><a href="#长连接和短连接" class="headerlink" title="长连接和短连接"></a>长连接和短连接</h2><p>TCP 本身并没有长短连接的区别，长短与否，完全取决于我们怎么用它。</p>
<ul>
<li>短连接：每次通信时，创建 Socket；一次通信结束，调用 socket.close()。这就是一般意义上的短连接，短连接的好处是管理起来比较简单，存在的连接都是可用的连接，不需要额外的控制手段。</li>
<li>长连接：每次通信完毕后，不会关闭连接，这样可以做到连接的复用。长连接的好处是省去了创建连接的耗时。</li>
</ul>
<p>短连接和长连接的优势，分别是对方的劣势。想要图简单，不追求高性能，使用短连接合适，这样我们就不需要操心连接状态的管理；想要追求性能，使用长连接，我们就需要担心各种问题：比如 端对端连接的维护，连接的保活。</p>
<p>HTTP1.1规定了默认保持长连接（HTTP persistent connection ，也有翻译为持久连接），数据传输完成了保持TCP连接不断开（不发RST包、不四次握手），等待在同域名下继续用这个通道传输数据；相反的就是短连接。</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul>
<li><a href="https://coding.imooc.com/class/225.html">HTTP协议原理+实践 Web开发工程师必学-慕课网实战</a></li>
<li><a href="https://juejin.im/post/6844904049800642568">详解 四层、五层、七层 计算机网络模型 - 掘金</a></li>
<li><a href="https://zh.wikipedia.org/wiki/%E5%BA%94%E7%94%A8%E5%B1%82">应用层 - 维基百科，自由的百科全书</a></li>
<li><a href="https://zh.wikipedia.org/wiki/%E7%BD%91%E7%BB%9C%E5%B1%82">网络层 - 维基百科，自由的百科全书</a></li>
<li><a href="https://zh.wikipedia.org/wiki/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82">数据链路层 - 维基百科，自由的百科全书</a></li>
<li><a href="https://zh.wikipedia.org/wiki/%E7%89%A9%E7%90%86%E5%B1%82">物理层 - 维基百科，自由的百科全书</a></li>
<li><a href="http://www.ruanyifeng.com/blog/2016/08/http.html">HTTP 协议入门 - 阮一峰的网络日志</a></li>
<li><a href="https://blog.csdn.net/walkingmanc/article/details/49363869">同一个ip通一个80端口部署多个网站的原理-虚拟主机技术本质解析_walkingmanc的专栏-CSDN博客</a></li>
<li><a href="https://blog.csdn.net/zhanghongzheng3213/article/details/79855775">TCP为什么需要3次握手与4次挥手_zhanghongzheng3213的专栏-CSDN博客</a></li>
<li><a href="https://zh.wikipedia.org/wiki/%E7%BB%9F%E4%B8%80%E8%B5%84%E6%BA%90%E6%A0%87%E5%BF%97%E7%AC%A6">统一资源标志符 - 维基百科，自由的百科全书</a></li>
<li><a href="https://github.com/CavsZhouyou/Front-End-Interview-Notebook/blob/master/JavaScript/JavaScript.md">Front-End-Interview-Notebook/JavaScript.md at master · CavsZhouyou/Front-End-Interview-Notebook</a></li>
<li><a href="https://www.ruanyifeng.com/blog/2016/04/same-origin-policy.html">浏览器同源政策及其规避方法 - 阮一峰的网络日志</a></li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Caching_FAQ">HTTP 缓存 - HTTP | MDN</a></li>
<li><a href="https://www.iteye.com/blog/coolfiry-1189525">【技术心得】Last-Modified,Etag,Expire区别 - coolfiry - ITeye博客</a></li>
<li><a href="https://jerryzou.com/posts/cookie-and-web-storage/">详说 Cookie, LocalStorage 与 SessionStorage | 咀嚼之味</a></li>
<li><a href="https://www.jianshu.com/p/0c4de17dd6bc">Tcp长连接和keepalive - 简书</a></li>
<li><a href="https://www.cnblogs.com/duanxz/p/3623486.html">HTTP协议中的长连接和短连接（keep-alive状态） - duanxz - 博客园</a></li>
</ul>
]]></content>
      <categories>
        <category>信息技术</category>
      </categories>
      <tags>
        <tag>http</tag>
      </tags>
  </entry>
  <entry>
    <title>journal-2019-02-15</title>
    <url>/journal-2019-02-15/</url>
    <content><![CDATA[<h2 id="小孩成长与人才发展"><a href="#小孩成长与人才发展" class="headerlink" title="小孩成长与人才发展"></a>小孩成长与人才发展</h2><p>小孩是懵懂的，从家长的角度要注重其过程，从过程推导孩子的优良，若不观其过程，孩子成绩差的原因只会被家长归纳为，天资不聪、贪玩等。</p>
<p>孩子成年，便有了一定的目标与发展方向，此时我们需要更偏向于观其结果。因为老一辈人平庸，不一定孩子平庸；老一辈人罪恶，不一定孩子罪恶。尽可能将我们的善传递给孩子，对孩子的奉献，是人类奉献精神最简单的体现。</p>
<p>国家之于人才也是如此，人才之初便是懵懂的，对其评判更应注重其过程，关注其现实的影响力。在“痕迹管理”等考核方法仍有缺陷的情况下，运用互联网的技术手段实现更优良的行业考核制度，将技术与社会紧密连结。</p>
<p>参考：<a href="http://www.qstheory.cn/dukan/qs/2019-02/01/c_1124054691.htm">《基层减负 不是简单做减法》《求是》2019/03 </a></p>
]]></content>
      <categories>
        <category>思想文化</category>
      </categories>
  </entry>
  <entry>
    <title>环形链表</title>
    <url>/leetcode-142/</url>
    <content><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><a href="https://leetcode-cn.com/problems/linked-list-cycle-ii/">142. 环形链表 II - 力扣（LeetCode）</a><br>给定一个链表，返回链表入环的第一个节点。无环返回null。<br><img data-src="https://images.xyang.xin/2020%2F09%2F13%2FlinkList.jpg?x-oss-process=style/title_800" alt="linkList.jpg"></p>
<span id="more"></span>

<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>环形链表问题，通用的解法，是通过设置双指针，</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> runSlow = head</span><br><span class="line"><span class="keyword">let</span> runFast = head</span><br></pre></td></tr></table></figure>
<p>将 runFast 的速度，设置为2，runSlow 的速度设置为 1，当 runFast 所在节点等于 runSlow 所在节点代表追上了。</p>
<p>因为 runFast 和 runSlow 同时出发，且 runFast 的速度为 runSlow 速度的两倍。<br><strong>无论如何 runSlow 跑的第一圈就会被追上</strong>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(runFast &amp;&amp; runFast.next)&#123;</span><br><span class="line">    runFast = runFast.next.next</span><br><span class="line">    runSlow = runSlow.next</span><br><span class="line">    <span class="keyword">if</span> (runFast === runSlow)&#123;</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果有环，到这里我们已经能够得到，runFast 和 runSlow 的相遇点了。<br><img data-src="https://images.xyang.xin/2020%2F09%2F13%2FlinkListRYS.jpg?x-oss-process=style/title_800" alt="linkListRYS.jpg"></p>
<p>题解：<br>相遇时：</p>
<ul>
<li>runSlow 走距离为：R + Y；</li>
<li>runFast 走的距离为：R + n(Y+S) + Y</li>
<li>R + n(Y+S) + Y = 2(R + Y)</li>
<li>(n-1)Y + nS = R</li>
</ul>
<p>只要以上等式成立即可，可以任意取n，这里取n为1：R = S，<br><strong>也就是入口点的距离等于相遇点到这一圈终点的距离</strong>。</p>
<p>这是我知道了 R=S 这个结论后，再推倒的，如果不知道结论，本弱还在设圈的周长的未知数呢。并且最后一步的思想很关键。<em>任意取</em>。</p>
<p>所以根据这个结论，我们从起始点再放一个速度为 1 的节点，并且让runSlow继续跑，和这个新节点相遇的点就是入口点，这里为了节省那一点点内存，可以让runFast受累一下，让他从新从head开始以1的速度跑。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">runFast = head</span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(runFast == runSlow)&#123;</span><br><span class="line">        <span class="keyword">return</span> runFast</span><br><span class="line">    &#125;</span><br><span class="line">    runFast = runFast.next</span><br><span class="line">    runSlow = runSlow.next</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="知识积累"><a href="#知识积累" class="headerlink" title="知识积累"></a>知识积累</h2><ul>
<li>入口点的距离等于相遇点到这一圈终点的距离</li>
<li>不相关的参数可以任意设</li>
</ul>
]]></content>
      <categories>
        <category>信息技术</category>
      </categories>
      <tags>
        <tag>leecode</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>切换 Shell 需谨慎</title>
    <url>/linux-user/</url>
    <content><![CDATA[<h2 id="系统环境介绍"><a href="#系统环境介绍" class="headerlink" title="系统环境介绍"></a>系统环境介绍</h2><p>gentoo 半吊子机。<br><img data-src="https://images.xyang.xin/2018-10/1539332010.png" alt="valid login shells"></p>
<span id="more"></span>

<h2 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h2><p>执行<code>chsh -s /bin/zsh</code>命令切换成功。<br>自此导致 root 用户无法验证登陆。</p>
<p>庆幸这台服务器不止一个用户。<br>通过普通用户登陆服务器，执行 su 命令显示如下：<br><img data-src="https://images.xyang.xin/2018-10/1539333225.png" alt="执行 su 命令"></p>
<h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>解决办法如下：<br>sudo vim /etc/passwd 将 root 用户所对应的 Shell 改回 Bash。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>一台服务器应该有至少两个以上的用户。<br>下次再遇到一次这样的服务器😢再去具体研究一下。</p>
]]></content>
      <categories>
        <category>信息技术</category>
      </categories>
      <tags>
        <tag>Shell</tag>
      </tags>
  </entry>
  <entry>
    <title>鲁迅</title>
    <url>/luxun/</url>
    <content><![CDATA[<h2 id="资本"><a href="#资本" class="headerlink" title="资本"></a>资本</h2><p>凡走狗，虽或为一个资本家所豢养，其实是属于所有的资本家的，所以它遇见所有的阔人都驯良,遇见所有的穷人都狂吠。不知道谁是它的主子，真是它遇见所有阔人都驯良的原因，也就是属于资本家的证据。即使无人豢养，饿的精瘦，变成野狗了，但还是遇见所有的阔人都驯良，遇见所有的穷人都狂吠，不过这时它就愈不明白谁是主子了。</p>
<h2 id="土壤"><a href="#土壤" class="headerlink" title="土壤"></a>土壤</h2><p>天才并不是自生自长在深林荒野里的怪物，是由可以使天才生长的民众产生，长育出来的，所以没有这种民众，就没有天才。有一回拿破仑过 Alps 山，说，“我比 Alps 山还要高！”这何等英伟，然而不要忘记他后面跟着许多兵；倘没有兵，那只有被山那面的敌人捉住或者赶回，他的举动，言语，都离了英雄的界线，要归入疯子一类了。所以我想，在要求天才的产生之前，应该先要求可以使天才生长的民众。————譬如想有乔木，想看好花，一定要有好土；没有土，便没有花木了；所以土实在较花木还重要。花木非有土不可，正同拿破仑非有好兵不可一样。</p>
]]></content>
      <categories>
        <category>思想文化</category>
      </categories>
      <tags>
        <tag>鲁迅</tag>
      </tags>
  </entry>
  <entry>
    <title>解决远程服务器重装系统导致的 mac 终端无法连接的问题</title>
    <url>/mac-ssh-error/</url>
    <content><![CDATA[<p><img data-src="https://images.xyang.xin/2019-05%2F2019-05-14%20at%2017.17.png" alt="2019-05-14 at 17.17.png"><br>WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED!</p>
<p>known_hosts是记录远程主机的公钥的文件，重装服务器系统后，保存的公钥还是服务器重装之前的公钥，在ssh链接的时候首先会验证公钥，如果公钥不对，那么就会报错。</p>
<h2 id="通过如下两种方案解决该问题"><a href="#通过如下两种方案解决该问题" class="headerlink" title="通过如下两种方案解决该问题"></a>通过如下两种方案解决该问题</h2><ol>
<li><p>输入命令(推荐)：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ssh-keygen -R45.40.106.111</span><br></pre></td></tr></table></figure>
<span id="more"></span>
</li>
<li><p>删除下面文件中相关 ip 的信息（公匙）<br>~/.ssh/known_hosts</p>
</li>
</ol>
<p>.ssh文件为隐藏文件夹可通过 command + shift + . 查看。或者直接：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rm -rf ~/.ssh/known_hosts</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>信息技术</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Mac 大扫除🧹</title>
    <url>/macos-clean/</url>
    <content><![CDATA[<p>基于 macOS Catalina 版本 10.15.4, 128G固态，8GB内存。</p>
<p>通过以下命令可以查看当前路径下的所有文件及文件夹大小并从大到小排列，以 KB 为单位显示。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">du -sk *| sort -rn</span><br></pre></td></tr></table></figure>
<p>以下命令就是以K，M，G为单位，提高信息的可读性，但是不能正确按文件大小排序。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">du -sh *</span><br></pre></td></tr></table></figure>
<span id="more"></span>

<h2 id="用户文件清理"><a href="#用户文件清理" class="headerlink" title="用户文件清理"></a>用户文件清理</h2><p>我们称<code>～/</code>目录下的文件为用户文件。</p>
<ol>
<li>卸载不必要的应用，使用 柠檬清理 或者 AppCleaner 都是免费的。</li>
<li>通过 柠檬清理，CleanMyMac 等软件清理垃圾，删除无用的大文件，这类软件都只有管理用户文件的能力。</li>
<li>软件的配置、下载的插件等不能直接删除，应选择性删除：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">~/Library/Application Support/</span><br></pre></td></tr></table></figure>
<ol>
<li>应用的缓存文件可以直接删除，不放心的话使用 trash 将其放入垃圾篓，如有异常还原便可，不用担心开不了机，用户文件也就是 ~/ 目录下的文件，是不会影响系统运行的：</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rm -rf ~/Library/Caches/*</span><br><span class="line">// or</span><br><span class="line">brew install trash</span><br><span class="line">trash ~/Library/Caches/*</span><br></pre></td></tr></table></figure>
<h2 id="“系统文件”清理"><a href="#“系统文件”清理" class="headerlink" title="“系统文件”清理"></a>“系统文件”清理</h2><h3 id="清理文件定位"><a href="#清理文件定位" class="headerlink" title="清理文件定位"></a>清理文件定位</h3><p>Catalina中，系统文件从原本的文件系统中分离了，组成独立的文件系统，并且把这个文件系统从设计上设定为只能读取，不能写入。<br><img data-src="http://images.xyang.xin/2020-04%2F1586700714.png" alt="1586700714.png"> </p>
<p>而其他文件和数据存储在Macintosh HD - Data卷中，挂载在<code>/System/Volumes/Data</code>目录下，在Finder中和系统卷一样显示为Macintosh HD。<br><img data-src="http://images.xyang.xin/2020-04%2F1586754964.png" alt="1586754964.png"></p>
<p>如何区分数据卷和系统卷呢？<br>可以说除<code>/System/Volumes/Data</code>目录下的文件，其他都是数据卷文件。</p>
<p>我们还可以发现一个怪异的现象，最明显的是<code>/Users</code>和<code>/Applications</code>同样出现在<code>/System/Volumes/Data/Applications</code>和<code>/System/Volumes/Data/Users</code>，而且内容相同、检测出来大小都相同，并且没有占用额外的空间。</p>
<p>这里用到的是 “Bi-directional wormhole in path traversal” （路径遍历中的双向虫洞）—— Firmlinks，一种新的文件类型对象，类似于符号链接。通过以下命令可以查看哪些文件创建了Firmlinks：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vim /usr/share/firmlinks</span><br></pre></td></tr></table></figure>
<p><img data-src="http://images.xyang.xin/2020-04%2F1586753548.png" alt="1586753548.png"></p>
<h3 id="开始清理"><a href="#开始清理" class="headerlink" title="开始清理"></a>开始清理</h3><p>系统卷不能修改和写入，所以不会产生额外的垃圾，删除一些不用的系统应用是可以的，比如国际象棋，但是它们都不怎么占空间，所以没大必要。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo rm -rf /System/Applications/Chess.app/</span><br></pre></td></tr></table></figure>

<p>我们实际上就是对 数据卷 进行清理。暂且把除去<code>/Users</code>用户文件外的文件都称为系统文件吧，因为它们很多都是与系统功能相关的，</p>
<p>通过<code>du -sk *| sort -rn</code>命令，以下六个文件夹占的空间比较大：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">30210188	Users</span><br><span class="line">18391484	Applications</span><br><span class="line">6144100	private</span><br><span class="line">4822752	usr</span><br><span class="line">4179388	System</span><br><span class="line">3856812	Library</span><br></pre></td></tr></table></figure>
<p><code>Users</code>是用户文件我们已经清理过了<code>Applications</code>是用户下载的应用，也清理过了，重点研究后面四个文件夹。</p>
<p><code>/System/Volumes/Data/private/var/vm</code> 这里面删了又有，我删过，并没有产生什么意外。其中 sleepimage 是用于休眠期间存储主存的内容；swapfile 用于虚拟内存存储，当物理内存满了，系统会自动“调出”未被积极使用的数据，并将其存储于 swapfile。这两个都可以关闭，但是都不建议。</p>
<p><code>/System/Volumes/Data/System/Library/Speech</code> 占了两个多G空间是语音相关的文件<code>say 你好</code>系统就会说<code>你好</code>。</p>
<p><code>/System/Volumes/Data/usr</code>，usr是Unix System Resource的缩写，也就是Unix操作系统软件资源，很多通过命令行安装的软件都存放在这里，比如mac包管理器brew安装的软件都存放在里面，<code>brew uninstall</code>只会卸载软件本身而不会卸载相关依赖，通过以下命令可以安全的卸载brew安装的软件及其依赖：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">brew tap beeftornado/rmtree</span><br><span class="line">brew rmtree XX</span><br></pre></td></tr></table></figure>

<p>其实基于不同的使用习惯和用途，会产生不同的垃圾，用 <code>du</code> 命令一层层的分析查看，了解其内容含义，再清除是比较好的方法。</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul>
<li><a href="https://support.apple.com/en-us/HT210650">About the read-only system volume in macOS Catalina - Apple Support</a></li>
<li><a href="https://sspai.com/post/57052">当 Mac 升级到 Catalina 时，苹果在硬盘里施了点魔法 - 少数派</a></li>
<li><a href="https://devstreaming-cdn.apple.com/videos/wwdc/2019/710aunvynji5emrl/710/710_whats_new_in_apple_file_systems.pdf">https://devstreaming-cdn.apple.com/videos/wwdc/2019/710aunvynji5emrl/710/710_whats_new_in_apple_file_systems.pdf</a></li>
</ul>
]]></content>
      <categories>
        <category>信息技术</category>
      </categories>
      <tags>
        <tag>MacOS</tag>
      </tags>
  </entry>
  <entry>
    <title>Mac 配置上云神器 Mackup</title>
    <url>/mackup/</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><a href="https://github.com/lra/mackup">mackup</a> 是一款受关注度很高的开源软件，可运行于 osx 和 linux 系统。用于保持应用程序设置同步，可快捷的备份许多流行的应用程序。</p>
<span id="more"></span>

<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>有 brew 和 pip 两种推荐安装方式。</p>
<ul>
<li>Install Mackup<br><code>brew install mackup</code></li>
<li>Install Mackup with PIP<br><code>pip install --upgrade mackup</code></li>
</ul>
<p>还需要简单的<a href="https://github.com/lra/mackup/tree/master/doc">配置</a>才可使用。</p>
<p>创建 ～/.mackup.cfg 文件，根据需要添加配置。</p>
<p>可添加的配置如下：</p>
<ol>
<li><p>支持存储引擎：Dropbox、Google Drive、iCloud、Copy。<br> 例如选择存储到 icloud 添加如下配置即可：</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[storage]</span><br><span class="line">engine = icloud</span><br></pre></td></tr></table></figure></li>
<li><p>备份到指定文件夹。</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[storage]</span><br><span class="line">engine = file_system</span><br><span class="line">path = some/folder/in/your/home（空格不需要转义）</span><br></pre></td></tr></table></figure>
<p> 指向存储引擎的路径怎么样？是不是就支持所有的存储引擎了呢。</p>
</li>
<li><p>支持修改备份文件夹的名字，改为隐藏文件夹。（备份隐藏起来了）</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[storage]</span><br><span class="line">engine = icloud</span><br><span class="line">directory = .config/mackup</span><br></pre></td></tr></table></figure></li>
<li><p>选择你所要备份的应用。</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[applications_to_sync]</span><br><span class="line">ssh</span><br><span class="line">adium</span><br></pre></td></tr></table></figure></li>
<li><p>选择你不想备份的应用。</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[applications_to_ignore]</span><br><span class="line">ssh</span><br><span class="line">adium</span><br></pre></td></tr></table></figure></li>
<li><p>向官方提交支持应用的申请。</p>
</li>
<li><p>自定义很方便！</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mkdir ~/.mackup</span><br><span class="line">touch ~/.mackup/my-files.cfg</span><br></pre></td></tr></table></figure>
<p> 在 my-files.cfg 中配置如下</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[application]</span><br><span class="line">name = XXX </span><br><span class="line"></span><br><span class="line">[configuration_files]</span><br><span class="line">Library/XXX         (从 Library 开始末尾无 /)</span><br></pre></td></tr></table></figure>


</li>
</ol>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>备份应用的设置：</p>
<pre><code>`mackup backup`
</code></pre>
<p>强制同意备份请求：</p>
<pre><code>`mackup backup -f`
</code></pre>
<p>使用备份的设置：</p>
<pre><code>`mackup restore`
</code></pre>
<p>应用不进行备份处理：</p>
<pre><code>`mackup uninstall`
</code></pre>
<p>使用帮助：</p>
<pre><code>`mackup -h`
</code></pre>
<h2 id="注意⚠️"><a href="#注意⚠️" class="headerlink" title="注意⚠️"></a>注意⚠️</h2><p>我最初使用 Mackup 只是为了备份配置，日后更换电脑方便，而没有去理解它的精髓，所以造成了不必要的时间损失，重新手动配置了诸多环境。认识到是自己操作不当所造成后，也只能为它写下这篇博客。</p>
<p>mackup 的备份命令说执行的并不是 copy。“保持应用程序设置同步”才是它的核心要义。<br>mackup backup 相当于如下三个命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cp ~/.gitconfig ~/Dropbox/Mackup/.gitconfig</span><br><span class="line">rm ~/.gitconfig</span><br><span class="line">ln -s ~/Dropbox/Mackup/.gitconfig ~/.gitconfig</span><br></pre></td></tr></table></figure>
<ol>
<li>将配置拷贝到你所配置的 mackup 备份路径之下。</li>
<li>删除原本的配置。</li>
<li>将备份后的路径软链接到原来的路径下。</li>
</ol>
<p>每台电脑都使用云上的配置，从而达到了应用程序设置同步的目的。<br>同时使用软链接的方式节省了一定的存储空间。</p>
<p>那如果把云上的配置删了怎么办呢？那么备份过的应用都只有一个软链接。。。<br>清空了垃圾篓，这个时候该咋办呢😢，做数据恢复？还是通过云近期删除找回，icloud 我是没找回过。</p>
<p>所以理解了之后，记得执行 <code>mackup uninstall</code> 再删。😣<br>修改 mac 账户名名称前也记得 <code>mackup uninstall</code>.</p>
]]></content>
      <categories>
        <category>信息技术</category>
      </categories>
      <tags>
        <tag>开发工具</tag>
      </tags>
  </entry>
  <entry>
    <title>Mac 小问题 —— iCloud 未响应</title>
    <url>/macos-problems/</url>
    <content><![CDATA[<p>使用 iCloud Drive 将文件上传到云端，防止数据丢失，同时可以实现多台设备的协同工作。但是在使用 iCloud Drive 的过程中我遇到了程序未响应，iCoud 文件上传阻塞的问题。</p>
<span id="more"></span>

<h2 id="Finder-无法打开或持续未响应"><a href="#Finder-无法打开或持续未响应" class="headerlink" title="Finder 无法打开或持续未响应"></a>Finder 无法打开或持续未响应</h2><p>解决办法：<br>磁盘工具 -&gt; Macintosh HD（系统盘）-&gt; 急救<br>磁盘工具在以下路径：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">/System/Applications/Utilities/Disk Utility.app</span><br></pre></td></tr></table></figure>

<p>急救操作不会对你的电脑造成任何损害，甚至还有所优化。</p>
<h2 id="打开-iCloud-云盘文件夹极其缓慢"><a href="#打开-iCloud-云盘文件夹极其缓慢" class="headerlink" title="打开 iCloud 云盘文件夹极其缓慢"></a>打开 iCloud 云盘文件夹极其缓慢</h2><p>遇到的问题是：在访达中点击iCloud云盘系统就会出现转圈圈的标志，使用快捷键<code>command+alt+esc</code>（强制退出应用程序）就会看到访达处于未响应状态，这个时间会持续很久。</p>
<p>解决办法：<br>系统偏好 -&gt; Apple ID -&gt; 取消勾选iCloud云盘 -&gt; 保留副本 -&gt; 重新勾选iCloud云盘</p>
<p>此操作造成的后果是mac需要很长的一段时间和云端同步，这取决于你icloud存储的文件大小，并不会影响其他。</p>
<h2 id="文件无法上传排查"><a href="#文件无法上传排查" class="headerlink" title="文件无法上传排查"></a>文件无法上传排查</h2><p>iCloud 连续几天几夜也没同步完，经过诸多排查，例如，修改 DNS：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">114.114.114.114</span><br><span class="line">8.8.8.8</span><br></pre></td></tr></table></figure>
<p>不仅没起作用，还影响了访问其他网页。最后删除 DNS 配置，刷新 DNS 缓存：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ 2$ sudo killall -HUP mDNSResponder</span><br></pre></td></tr></table></figure>

<p>最后排查出是因为，我开发代码的工作目录都设置在了 iCloud 云盘里，文件体积虽然不大，却有上万个细小的文件，不知道是不是 iCloud 设置了某种限制，导致上传阻塞，最后将代码都移出 iCloud 问题就解决了。</p>
<p>后面又卡住了，收获到一个命令通过这个命令可以查看 iCloud 同步进度：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ brctl log -w</span><br></pre></td></tr></table></figure>
<p>虽然没看懂运行的是什么，但是能够看到一直有东西在执行。<br>通过以下三个命令对 icloud 进行重置：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 杀死icloud同步进程</span><br><span class="line">$ sudo killall bird</span><br><span class="line"># 删除 icloud 的配置文件</span><br><span class="line">$ sudo rm -rf ~/Library/Application\ Support/CloudDocs</span><br><span class="line"># 立刻关机</span><br><span class="line">$ sudo shutdown -r now</span><br></pre></td></tr></table></figure>
<p>不必担心文件丢失，效果与关闭重新关闭icloud同步类似。重新开启电脑后可以通过前面说到的命令查看 iCloud 同步的进度。</p>
<p>也可以直接使用下面的脚本：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line"></span><br><span class="line">if [[ $EUID -eq 0 ]]; then</span><br><span class="line">    echo &quot;Killing bird.&quot;</span><br><span class="line">    killall bird</span><br><span class="line">    echo &quot;Removing CloudDocs&quot;</span><br><span class="line">    cd ~/Library/Application\ Support</span><br><span class="line">    rm -rf CloudDocs</span><br><span class="line">    echo &quot;Immediately rebooting!&quot;</span><br><span class="line">    shutdown -r now</span><br><span class="line">else</span><br><span class="line">    echo &quot;</span><br><span class="line">    This script needs run as sudo. </span><br><span class="line">    Use CAUTION when doing so.</span><br><span class="line">    You accept full responsibility using this script.</span><br><span class="line">    You should know what it&#x27;s doing BEFORE you run it.</span><br><span class="line">    &quot;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>

<p>不必南辕北辙，越过中国的防火墙，iCloud 中国用户的文件存储在贵州云，而网上所谓的要获取验证文件，获取验证文件有香港的服务器。最后的任务就是等，我是让电脑喝着咖啡持续跑了接近一整天才同步完成的。</p>
<h2 id="Mac-无法同步-iPhone-剪贴板数据"><a href="#Mac-无法同步-iPhone-剪贴板数据" class="headerlink" title="Mac 无法同步 iPhone 剪贴板数据"></a>Mac 无法同步 iPhone 剪贴板数据</h2><p>iPhone 可以将 Mac 复制的内容，同步下来，而 Mac 不行。<br>解决办法：退出 iPhone 账号，并重新登陆。</p>
<h2 id="AirDrop-隔空投送文件传送"><a href="#AirDrop-隔空投送文件传送" class="headerlink" title="AirDrop 隔空投送文件传送"></a>AirDrop 隔空投送文件传送</h2><p>从 Mac 通过 AirDrop 传送文件至 iPhone，iPhone 必须有 App 可以打开传输文件格式的文件，否则文件将被遗弃。而我们需要传输一些特殊格式的文件的时候，我们可以将其压缩为 zip，这个时候 iPhone 就会接受了。</p>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul>
<li><a href="https://apple.stackexchange.com/questions/313716/icloud-drive-wont-sync-on-mac">macos - iCloud Drive Won’t Sync on Mac - Ask Different</a></li>
</ul>
]]></content>
      <categories>
        <category>信息技术</category>
      </categories>
      <tags>
        <tag>MacOS</tag>
        <tag>Finder</tag>
        <tag>iCloud</tag>
      </tags>
  </entry>
  <entry>
    <title>学习 CSS 时忽视的几个知识点</title>
    <url>/note-things-i-wish-id-known-about-css/</url>
    <content><![CDATA[<p><a href="https://cssfordesigners.com/articles/things-i-wish-id-known-about-css">Things I Wish I’d Known About CSS</a></p>
<p>文章的作者以老式的方式构建网站：查看网站源代码、复制然后修改，而没有经过阅读书籍等系统性的学习。作者在 1999 年就使用这种方式了，当时写的还是这种代码： <code>&lt;font size=&quot;4&quot; color=&quot;#000000&quot;&gt;</code>。而当 CSS 面世的时候，作者没有改变自己的学习方法，而错过了太多基本知识。文章主要介绍的是作者希望早点学到的东西。</p>
<span id="more"></span>

<h2 id="Block-inline-and-inline-block"><a href="#Block-inline-and-inline-block" class="headerlink" title="Block, inline and inline-block"></a>Block, inline and inline-block</h2><ul>
<li><code>block</code> 元素水平扩展以占据一整行（就像标题）。我们可以对它们运用垂直 margin；</li>
<li><code>inline</code> 元素仅水平扩展到足以容纳其内容（就像 <code>strong</code> 或者 <code>em</code> 元素）；</li>
<li><code>inline-block</code> 元素像 <code>inline</code> 元素，但是你可以对它们运用垂直的 margin（对 <code>button</code> 之类的元素有用）；</li>
</ul>
<h2 id="图片是内联的"><a href="#图片是内联的" class="headerlink" title="图片是内联的"></a>图片是内联的</h2><p><code>img</code> 元素默认是内联的，一般来说没什么问题，但是在尝试定位图像或添加垂直边距时会引起混乱。建议添加如下规则：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">img</span> &#123;<span class="attribute">display</span>: block;&#125;</span><br></pre></td></tr></table></figure>
<p>也可以添加 <code>max-width: 100%;</code> 以阻止块级元素突破容器。<br><a href="https://github.com/necolas/normalize.css/blob/master/normalize.css">normalize.css</a> 里面没有，我觉得是否添加智者见智。</p>
<h2 id="计算宽度"><a href="#计算宽度" class="headerlink" title="计算宽度"></a>计算宽度</h2><p>默认情况下，盒子的宽度 / 高度是通过将以下各项相加得出的：</p>
<ul>
<li>Content area（内容）</li>
<li>Padding area（内边距）</li>
<li>Border area（边框）</li>
</ul>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.box-class</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">2em</span>;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">0.1rem</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>包含 <code>.box-class</code> 类的属性的盒子的宽度就是 <code>50% + 4em + 0.2rem</code><br>默认情况下，我们用 css 设置的 <code>width</code> 属性指的仅仅只是 Content area（内容）部分的宽度。</p>
<p>下列代码将应用于所有元素，使得 <code>width</code> 属性设置的为上述三者相加的值。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">* &#123;<span class="attribute">box-sizing</span>: border-box;&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Padding-amp-margin-不一样"><a href="#Padding-amp-margin-不一样" class="headerlink" title="Padding &amp; margin 不一样"></a>Padding &amp; margin 不一样</h2><p>CSS 盒模型还有一个重要的组成部分 <code>margin</code>。</p>
<ul>
<li><code>margin</code> 是元素之间的间隔</li>
<li><code>padding</code> 是内容和边框之间的间隔</li>
</ul>
<h2 id="Margins-崩塌"><a href="#Margins-崩塌" class="headerlink" title="Margins 崩塌"></a>Margins 崩塌</h2><p>当边距崩塌时，它们将合并在一起，从而使两个元素之间的间隔变为两个边距中较大的一个。较小的边距基本上结束在较大的边距之内。</p>
<p>当两个边距相遇时，较大的边距会吸收较小的边距。如果边距值相同，则它们会相互吸收。</p>
<p>假设我们有两个相邻的 block 元素，上面一个设置 <code>margin-bottom: 1em</code> 下面一个设置 <code>margin-top: 1.5em</code>，这两个元素间的间距将合并为 <code>1.5em</code> 而不是 <code>1em + 1.5em</code>。</p>
<blockquote>
<p>Note: 当父元素设置为 <code>display: grid</code> 或 <code>display: flex</code> 时，边距不会崩塌。</p>
</blockquote>
<h2 id="浏览器具有默认样式表"><a href="#浏览器具有默认样式表" class="headerlink" title="浏览器具有默认样式表"></a>浏览器具有默认样式表</h2><p>CSS(Cascading Style Sheets) 是层叠样式表。我们必须记住，始终存在默认的浏览器样式表。它会在任何自定义样式表之前加载，而我们可以很轻易的覆盖它们。</p>
<p>声明的样式因浏览器而异。抹平差异的方法主要有两种，任选其一：</p>
<ol>
<li>CSS 重置，将所有默认样式都设置为“零”，例如 <a href="https://meyerweb.com/eric/tools/css/reset/">https://meyerweb.com/eric/tools/css/reset/</a></li>
<li>normalize.css, 对默认样式进行微调，使它们在不同的浏览器中具有相似的外观：<a href="http://necolas.github.io/normalize.css/">http://necolas.github.io/normalize.css/</a></li>
</ol>
<h2 id="任何地方都使用相对单位"><a href="#任何地方都使用相对单位" class="headerlink" title="任何地方都使用相对单位"></a>任何地方都使用相对单位</h2><p>我们可以将 <code>em</code> 用于 <code>@media</code> 查询和垂直边距，而将 <code>rem</code> 用于一致的边框宽度。</p>
<h2 id="before-和-after-需要-content"><a href="#before-和-after-需要-content" class="headerlink" title="::before 和 ::after 需要 content"></a>::before 和 ::after 需要 content</h2><p>当我们使用 <code>::before</code> 或者 <code>::after</code> 伪元素时，需要添加 <code>content</code> 属性，即使它的值为空白：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.some-class::before &#123;content: &#x27;&#x27;;&#125;</span><br></pre></td></tr></table></figure>
<p>如果不包含此属性，伪元素将不会显示。</p>
<h2 id="ch-单位"><a href="#ch-单位" class="headerlink" title="ch 单位"></a>ch 单位</h2><p>ch(character)，大致基于一行的字符数来设置宽度的时候 <code>ch</code> 很有用。</p>
<p>1ch 就是数字 0 的宽度。</p>
<p>1ch 通常比平均字符宽度宽 20％到 30％。</p>
<h2 id="Normal-flow（正常布局流）"><a href="#Normal-flow（正常布局流）" class="headerlink" title="Normal flow（正常布局流）"></a>Normal flow（正常布局流）</h2><p>“normal flow” 的意思是出现在页面上的元素和在源代码中实现的方式相同。<br>例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;h2&gt;Heading&lt;/h2&gt;</span><br><span class="line">&lt;p&gt;Paragraph text.&lt;/p&gt;</span><br></pre></td></tr></table></figure>
<p>我们期望的是 <code>&lt;h2&gt;Heading&lt;/h2&gt;</code> 出现在 <code>&lt;p&gt;Paragraph text.&lt;/p&gt;</code> 的之前 / 顶部。这就是 <em>normal flow</em>。</p>
<p>而绝对定位和浮动就脱离了 <em>normal flow</em>。</p>
<h2 id="风格化-focus-状态"><a href="#风格化-focus-状态" class="headerlink" title="风格化 :focus 状态"></a>风格化 :focus 状态</h2><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">a</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: black;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:hover</span>,</span><br><span class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:focus</span>,</span><br><span class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:active</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们最好为 <code>:focus</code> 状态添加不同的样式。因为例如鼠标悬停或者已经激活，用户再按[tab]键，<code>:focus</code>就不起作用了。</p>
<p>为防止晚出现的规则覆盖前面出现的规则，按照如下顺序定义规则：<br>link、visited、focus、hover、active（缩写为 LVPHA）<br>或者 LVHFA 的顺序也是可以的。</p>
<h2 id="nth-child"><a href="#nth-child" class="headerlink" title=":nth-child()"></a>:nth-child()</h2><p><code>p:nth-child()</code>计算所有同级元素<br><code>p:nth-of-type()</code>仅计算同级的p元素</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>:nth-child()<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Paragraph one.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Paragraph two.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Paragraph three.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Paragraph four.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Paragraph five.<span class="tag">&lt;/<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">p</span>&gt;</span>Paragraph six.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">p</span><span class="selector-pseudo">:nth-child</span>(even) &#123;</span><br><span class="line">	<span class="attribute">background</span>: orange;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img data-src="http://images.xyang.xin/2020%2F07%2F25%2F1595610186.png" alt="1595610186.png"></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">p</span><span class="selector-pseudo">:nth-of-type</span>(even) &#123;</span><br><span class="line">	<span class="attribute">background</span>: orange;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img data-src="http://images.xyang.xin/2020%2F07%2F25%2F1595610292.png" alt="1595610292.png"></p>
<h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><p>掌握CSS的基础知识很容易，但是了解事情的方式和原因对编写更好的CSS至关重要。</p>
<p>花时间学习这些东西不仅帮助我更快地编写CSS，而且还使我的代码更高效，更灵活。</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul>
<li><a href="https://cssfordesigners.com/articles/things-i-wish-id-known-about-css">Things I Wish I’d Known About CSS</a></li>
<li>《HTML5 与 CSS3 基础教程 (第 8 版)》</li>
</ul>
]]></content>
      <categories>
        <category>信息技术</category>
      </categories>
      <tags>
        <tag>css</tag>
        <tag>note</tag>
      </tags>
  </entry>
  <entry>
    <title>包管理</title>
    <url>/package-management/</url>
    <content><![CDATA[<p>大部分成熟的操作系统有着各种不同的包管理器，某些软件也有自己的包管理器。</p>
<h2 id="系统包管理器"><a href="#系统包管理器" class="headerlink" title="系统包管理器"></a>系统包管理器</h2><ul>
<li>CentOS<ul>
<li>yum</li>
</ul>
</li>
<li>Gentoo    <ul>
<li>emerge</li>
</ul>
</li>
<li>MacOS     <ul>
<li><a href="https://brew.sh/index_zh-cn">Homebrew</a><ul>
<li>Homebrew 已经成为一款跨平台的包管理器 <a href="https://github.com/Linuxbrew/brew/blob/master/README.md">Linuxbrew</a><span id="more"></span>
<h2 id="软件包管理器"><a href="#软件包管理器" class="headerlink" title="软件包管理器"></a>软件包管理器</h2></li>
</ul>
</li>
</ul>
</li>
<li>Vim<ul>
<li><a href="https://github.com/junegunn/vim-plug">vim-plug</a><ul>
<li>支持多线程下载速度快，推荐使用。</li>
</ul>
</li>
<li><a href="https://github.com/VundleVim/Vundle.vim">vundle</a><ul>
<li>老牌</li>
</ul>
</li>
</ul>
</li>
<li>Node.js<ul>
<li>npm<ul>
<li>国内源<ul>
<li><code>npm config set registry https://registry.npm.taobao.org</code></li>
<li><code>npm config set disturl https://npm.taobao.org/dist</code></li>
</ul>
</li>
</ul>
</li>
<li>yarn<ul>
<li>facebook 研发</li>
<li>国内源<ul>
<li><code>yarn config set registry https://registry.npm.taobao.org --global</code></li>
<li><code>yarn config set disturl https://npm.taobao.org/dist --global</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>Java <ul>
<li>maven</li>
</ul>
</li>
<li>Go<ul>
<li>dep</li>
<li>go modules</li>
</ul>
</li>
</ul>
<h2 id="Homebrew"><a href="#Homebrew" class="headerlink" title="Homebrew"></a>Homebrew</h2><h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">% brew search # 搜索包</span><br><span class="line">% brew install # 安装包</span><br><span class="line">% brew uninstall # 删除包</span><br><span class="line">% brew update # 更新包</span><br><span class="line">% brew upgrade # 升级包</span><br><span class="line">% brew cleanup # 清理旧包</span><br></pre></td></tr></table></figure>

<h3 id="MacOS-下的-brew-cask"><a href="#MacOS-下的-brew-cask" class="headerlink" title="MacOS 下的 brew cask"></a>MacOS 下的 brew cask</h3><p>用于安装有图像界面的 app 以及驱动<br><code>brew install brew-cask</code></p>
<p>如果遇到问题可以先执行如下命令：<br><code>git -C &quot;$(brew --repo homebrew/core)&quot; fetch --unshallow</code></p>
<h3 id="Homebrew-换源"><a href="#Homebrew-换源" class="headerlink" title="Homebrew 换源"></a>Homebrew 换源</h3><p><a href="https://mirrors.tuna.tsinghua.edu.cn/help/homebrew/">Homebrew | 镜像站使用帮助 | 清华大学开源软件镜像站 | Tsinghua Open Source Mirror</a></p>
<h3 id="Homebrew-换回官方源"><a href="#Homebrew-换回官方源" class="headerlink" title="Homebrew 换回官方源"></a>Homebrew 换回官方源</h3><ul>
<li>重置 brew.git    <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd &quot;$(brew --repo)&quot;</span><br><span class="line">git remote set-url origin https://github.com/Homebrew/brew.git</span><br></pre></td></tr></table></figure></li>
<li>重置 Homebrew-core：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd &quot;$(brew --repo)/Library/Taps/homebrew/homebrew-core&quot;</span><br><span class="line">git remote set-url origin https://github.com/Homebrew/homebrew-core.git</span><br></pre></td></tr></table></figure></li>
<li>源更新<br><code>brew update</code></li>
</ul>
]]></content>
      <categories>
        <category>信息技术</category>
      </categories>
      <tags>
        <tag>包管理</tag>
      </tags>
  </entry>
  <entry>
    <title>HTTP 代理与 Socks5 代理</title>
    <url>/proxy-http-socks5/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>本文通过实践经历基本的认识 HTTP 代理与 Socks5 代理的用法与理解其精髓。同时也解决 go get 库无法下载的问题。</p>
<span id="more"></span>
<h2 id="渐渐"><a href="#渐渐" class="headerlink" title="渐渐"></a>渐渐</h2><p>终端走代理我最初接触到的是 HTTP 代理，这篇文章可以见证(<a href="https://blog.xyang.xin/proxy-teach/index.html">代理服务器 | 韶 光</a>)。当然我的这些实践都是基于 shadowsocks 这款产品。随后我又接触了 Socks5 代理，因为简单其更快，又隐隐觉得其更底层，通过以下代码配置：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> .zshrc</span></span><br><span class="line">export ALL_PROXY=socks5://127.0.0.1:20808</span><br></pre></td></tr></table></figure>
<p>仍然要开 <em>全局模式</em> 终端才能走代理。</p>
<p>虽然没有使用 HTTP 代理，但是很长一段时间我都没有关闭 <em>启用 HTTP 代理</em> 这个按钮，直到一天我连接手机热点 shadowsocks 闪退，我才关闭将其关闭了。这更显 Socks5 代理的优秀。</p>
<h2 id="今天"><a href="#今天" class="headerlink" title="今天"></a>今天</h2><p>当我重新安装 <a href="https://github.com/fatih/vim-go">vim-go</a>,并执行 <code>:GoUpdateBinaries</code> 故事又开始了。<br>显示类似于如下的一系列报错：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vim-go: Updating guru. Reinstalling golang.org/x/tools/cmd/guru@master to folder /Users/sweeney/Documents/code/go/bin</span><br><span class="line">vim-go: Error installing golang.org/x/tools/cmd/guru@master: go get golang.org/x/tools/cmd/guru@master: golang.org/x/tools/cmd/guru@master: invalid version: Get &quot;https://proxy.golang.org/golang.org/x/tools/cmd/guru/@v/master.info&quot;: dial tcp 172.217.24.17:443: i/o</span><br><span class="line">timeout</span><br></pre></td></tr></table></figure>
<p>首先我对 socks5 是很相信的，天生的认为其是较为底层的代理，应该不存在 HTTP 能代理而 Socks5 不能代理的情况。</p>
<p>“应该” 呵呵，所以我就耗了近一个半小时在这里。</p>
<p>以上问题其实和直接执行 <code>go get golang.org/x/tools/cmd/guru</code>，然后输出如下错误是一个道理。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">unrecognized import path &quot;golang.org/x/tools/cmd/guru&quot;: https fetch: Get &quot;https://golang.org/x/tools/cmd/guru?go-get=1&quot;: dial tcp 216.239.37.1:443: i/o timeout</span><br></pre></td></tr></table></figure>
<p>都是 go get 无法从 golang.org 下载包。</p>
<p>虽然 <code>curl golang.org</code> 能够访问这个网站，但是还是无法下载包。</p>
<h2 id="Socks5-vs-HTTP"><a href="#Socks5-vs-HTTP" class="headerlink" title="Socks5 vs HTTP"></a>Socks5 vs HTTP</h2><table>
<thead>
<tr>
<th></th>
<th align="center">HTTP Proxy</th>
<th align="center">Socks5 Proxy</th>
</tr>
</thead>
<tbody><tr>
<td>功能</td>
<td align="center">http 代理对于使用浏览器上网的用户很重要。</td>
<td align="center">并不使用 http 协议，是更通用，更低级别的代理。</td>
</tr>
<tr>
<td>安全</td>
<td align="center">被传输的数据极可能被查看。</td>
<td align="center">由于SOCKS无法读取数据，因此查看数据的几率很小。</td>
</tr>
<tr>
<td>速度</td>
<td align="center">速度较慢。</td>
<td align="center">通用服务器速度快。</td>
</tr>
<tr>
<td>连接工具</td>
<td align="center">任何工具。</td>
<td align="center">有限制工具。</td>
</tr>
<tr>
<td>建议</td>
<td align="center">传输少量数据。</td>
<td align="center">传输大体积的速度。</td>
</tr>
</tbody></table>
<p>SOCKS 作用在 OSI 模型的第四层 —— 会话层上。SOCKS4 只能代理TCP协议，而 SOCKS5 什么协议都可以代理。HTTP工作在应用层上，Socks代理只是简单地传递数据包，而不必关心是何种应用协议(比如 FTP、HTTP 和 NNTP 请求)，所以Socks代理服务器比应用层代理服务器要快得多。<br><img data-src="http://images.xyang.xin/2020-03%2Fnetwork.png" alt="network.png"></p>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">export ALL_PROXY=socks5://127.0.0.1:20808</span><br><span class="line">export http_proxy=socks5://127.0.0.1:20808</span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">alias</span> go=<span class="string">&#x27;http_proxy=socks5://127.0.0.1:20808 go&#x27;</span></span></span><br></pre></td></tr></table></figure>

<h2 id="遗留问题"><a href="#遗留问题" class="headerlink" title="遗留问题"></a>遗留问题</h2><p>我还是不知道为什么 ALL_PROXY 没对 go get 生效，而 http_proxy 生效了。并且经过测试，不是大小写的问题。</p>
<hr>
<p>参考文献：</p>
<ul>
<li><a href="https://dzone.com/articles/breaking-down-complex-differences-of-socks-vs-http">Breaking Down Differences Between SOCKS vs HTTP Proxy - DZone Security</a></li>
<li><a href="https://colobu.com/2017/01/26/how-to-go-get-behind-GFW/">如何在长城后面go get一些库 | 鸟窝</a></li>
<li><a href="http://www.yunlianip.com/News-getinfo-id-61.html">SOCKS5代理和HTTP代理有什么区别？-云连代理</a></li>
<li><a href="https://stackoverflow.com/questions/10383299/how-do-i-configure-go-command-to-use-a-proxy">How do I configure go command to use a proxy? - Stack Overflow</a></li>
</ul>
]]></content>
      <categories>
        <category>信息技术</category>
      </categories>
      <tags>
        <tag>代理</tag>
      </tags>
  </entry>
  <entry>
    <title>代理服务器</title>
    <url>/proxy-teach/</url>
    <content><![CDATA[<p>主要包含：shadowsocks-libev、kuptun 的配置和优化。基于亚马逊云学生机。</p>
<span id="more"></span>
<p>Docker 部署以及 安装v2ray-plugin 插件，请跳到最后。</p>
<h2 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h2><p><a href="https://www.emptyus.com/download.php">Shadowsocks X - A secure socks5 proxy</a><br><a href="https://github.com/shadowsocks">shadowsocks</a></p>
<p><a href="https://github.com/shadowsocks/ShadowsocksX-NG">shadowsocks/ShadowsocksX-NG: Next Generation of ShadowsocksX</a></p>
<h2 id="终端走代理"><a href="#终端走代理" class="headerlink" title="终端走代理"></a>终端走代理</h2><p>命令开启和关闭终端走代理：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">export</span> ALL_PROXY=socks5://127.0.0.1:20808</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">export</span> HTTP_PROXY=socks5://127.0.0.1:20808</span></span><br></pre></td></tr></table></figure>
<p>检测代理结果（全局模式）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ curl myip.ipip.net</span><br></pre></td></tr></table></figure>

<h2 id="服务器端"><a href="#服务器端" class="headerlink" title="服务器端"></a>服务器端</h2><p><a href="https://github.com/teddysun/shadowsocks_install/tree/master">teddysun/shadowsocks_install at master</a></p>
<h3 id="安装命令"><a href="#安装命令" class="headerlink" title="安装命令"></a>安装命令</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget --no-check-certificate -O shadowsocks-libev.sh https://raw.githubusercontent.com/teddysun/shadowsocks_install/master/shadowsocks-libev.sh</span><br><span class="line">chmod +x shadowsocks-libev.sh</span><br><span class="line">./shadowsocks-libev.sh 2&gt;&amp;1 | tee shadowsocks-libev.log</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Tip：脚本目前不支持 Centos8，为什么选择 libev 版本，因为其它版本停止维护了。</p>
</blockquote>
<p>加密算法推荐使用 <code>aes-256-gcm</code>。安装好后就可以通过下面的命令使用了：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ./shadowsocks-libev.sh uninstall   <span class="comment"># 卸载 SS</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> /etc/init.d/shadowsocks start      <span class="comment"># 启动 SS</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> /etc/init.d/shadowsocks stop       <span class="comment"># 停止 SS</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> /etc/init.d/shadowsocks restart    <span class="comment"># 重启 SS</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> /etc/init.d/shadowsocks status     <span class="comment"># 状态 SS</span></span></span><br></pre></td></tr></table></figure>

<p>要开机自启还是得自己动手：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> vim /usr/lib/systemd/system/shadowsocks_libev.service</span></span><br></pre></td></tr></table></figure>
<p>加入如下配置：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description=shadowsocks_libev</span><br><span class="line">Wants=network.target</span><br><span class="line">After=syslog.target network-online.target</span><br><span class="line">[Service]</span><br><span class="line">Type=simple</span><br><span class="line">ExecStart=</span><br><span class="line">ExecStart=/usr/local/bin/ss-server -c /etc/shadowsocks-libev/config.json</span><br><span class="line">Restart=on-failure</span><br><span class="line">RestartSec=10</span><br><span class="line">KillMode=process</span><br><span class="line">LimitNOFILE=65536</span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure>
<p>运行命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo systemctl daemon-reload</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo systemctl <span class="built_in">enable</span> shadowsocks_libev</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo systemctl start shadowsocks_libev</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo systemctl restart shadowsocks_libev</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo systemctl status shadowsocks_libev -l</span></span><br></pre></td></tr></table></figure>

<p>配置文件在这里：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ vim /etc/shadowsocks-libev/config.json</span><br></pre></td></tr></table></figure>
<p>大多数来说脚本默认的配置就很好了，如果有异常的话就显式的运行程序来查看日志：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo /usr/<span class="built_in">local</span>/bin/ss-server</span></span><br></pre></td></tr></table></figure>
<h2 id="优化加速"><a href="#优化加速" class="headerlink" title="优化加速"></a>优化加速</h2><h3 id="服务器端加速"><a href="#服务器端加速" class="headerlink" title="服务器端加速"></a>服务器端加速</h3><p>从 4.9 开始，Linux 内核已经用上了该算法。通过以下命令检测主机是否开启 BBR：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">lsmod | grep bbr</span><br></pre></td></tr></table></figure>
<p>如果有返回值请跳过，如果没有，可通过以下步骤安装。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ sudo su</span><br><span class="line">$ wget --no-check-certificate https://github.com/teddysun/across/raw/master/bbr.sh &amp;&amp; chmod +x bbr.sh &amp;&amp; ./bbr.sh</span><br></pre></td></tr></table></figure>
<p>输入 <code>lsmod | grep bbr</code> ，出现 <code>tcp_bbr</code> 即说明 BBR 已经启动。</p>
<h3 id="双端加速"><a href="#双端加速" class="headerlink" title="双端加速"></a>双端加速</h3><p>服务器端安装：<br><a href="https://github.com/xtaci/kcptun">xtaci/kcptun</a><br>Kcptun 是一个非常简单和快速的，基于 KCP 协议的 UDP 隧道，它可以将 TCP 流转换为 KCP+UDP 流。它以比 TCP 浪费 10%-20% 的带宽的代价，和极少的资源占用，以达到降低多倍延迟的效果。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ sudo yum install golang -y</span><br><span class="line">$ git clone https://github.com/xtaci/kcptun.git</span><br><span class="line">$ cd kcptun</span><br><span class="line">$ ./build-release.sh</span><br><span class="line">$ cd build</span><br><span class="line">// 选择合适的版本</span><br><span class="line">$ sudo mv server_linux_amd64 /usr/local/bin/kcptun_server</span><br><span class="line">$ </span><br></pre></td></tr></table></figure>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">Wants=network.target</span><br></pre></td></tr></table></figure>

<p>建议在 <code>sysctl.conf</code> 中添加以下配置，优化 UDP 包的搬运速度：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo vim /etc/sysctl.conf</span></span><br></pre></td></tr></table></figure>
<p>写入以下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># KCP: for better handling of UDP packets</span><br><span class="line">net.core.rmem_max=26214400 // BDP - bandwidth delay product</span><br><span class="line">net.core.rmem_default=26214400</span><br><span class="line">net.core.wmem_max=26214400</span><br><span class="line">net.core.wmem_default=26214400</span><br><span class="line">net.core.netdev_max_backlog=2048 // proportional to -rcvwnd</span><br></pre></td></tr></table></figure>
<p>运行以下命令生成配置：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo sysctl --system</span></span><br></pre></td></tr></table></figure>

<p><a href="https://wiki.archlinux.org/index.php/Sysctl#Enable_BBR">更多性能优化配置</a><br>在用户目录 <code>~</code> 创建 <code>kcptun.json</code> 配置文件如下：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;listen&quot;</span>: <span class="string">&quot;:4000&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;target&quot;</span>: <span class="string">&quot;127.0.0.1:14376&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;mode&quot;</span>: <span class="string">&quot;fast3&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;dscp&quot;</span>: <span class="number">46</span>,</span><br><span class="line">  <span class="attr">&quot;crypt&quot;</span>: <span class="string">&quot;salsa20&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;key&quot;</span>: <span class="string">&quot;1q2w3e4r.&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;sockbuf&quot;</span>:<span class="number">16777217</span>,</span><br><span class="line">  <span class="attr">&quot;nocomp&quot;</span>:<span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> vim /usr/lib/systemd/system/kcptun_server.service</span></span><br></pre></td></tr></table></figure>
<p>添加配置如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description=kcptun</span><br><span class="line">Wants=network.target</span><br><span class="line">After=syslog.target network-online.target</span><br><span class="line">[Service]</span><br><span class="line">Type=simple</span><br><span class="line">Environment=GOGC=20</span><br><span class="line">ExecStart=</span><br><span class="line">ExecStart=/usr/local/bin/kcptun_server -c /home/ec2-user/kcptun.json</span><br><span class="line">Restart=on-failure</span><br><span class="line">RestartSec=10</span><br><span class="line">KillMode=process</span><br><span class="line">LimitNOFILE=65536</span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 设置开机自启</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo systemctl <span class="built_in">enable</span> kcptun_server</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 启动服务</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo systemctl restart kcptun_server</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看服务运行状态，测试是否配置成功</span></span><br><span class="line">sudo systemctl status kcptun_server  -l</span><br></pre></td></tr></table></figure>
<p>修改配置文件后，需要重新加载配置文件，然后重新启动相关服务</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ sudo systemctl daemon-reload</span><br><span class="line">$ sudo systemctl restart kcptun_server</span><br></pre></td></tr></table></figure>

<p>客户端 Kcptun 配置如图：<br><img data-src="http://images.xyang.xin/2020%2F06%2F03%2F1591188770.png" alt="1591188770.png"><br>Arguments:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-autoexpire 900 -sockbuf 16777217</span><br></pre></td></tr></table></figure>

<h2 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h2><p>通过上面的配置，目前而言使用效果不差。但是会不间断的出现“断流”，ssh 可以正常连接服务器，这是必然的。同样的情况出现在，相关业务商家都会提供不同地区的 N 多节点，但是同一时间可以正常使用的也就一两个。</p>
<p>我觉得最简单靠谱的就是，使用常用的端口如 443 或 80。</p>
<p>要开启 ipv6 的话，首先要保证服务器有 ipv6 的公网 ip，然后改一下 kcptun 和 ss 的配置：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"># config.json</span><br><span class="line"><span class="string">&quot;server&quot;</span>:<span class="string">&quot;::&quot;</span>,</span><br><span class="line"></span><br><span class="line"># kcptun.json</span><br><span class="line"><span class="string">&quot;listen&quot;</span>: <span class="string">&quot;[::]:4000&quot;</span>,</span><br><span class="line"><span class="string">&quot;target&quot;</span>: <span class="string">&quot;[::]:443&quot;</span></span><br></pre></td></tr></table></figure>
<h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ lsmod | grep bbr                   # 状态 BBR</span><br><span class="line">$ sudo systemctl daemon-reload       # 重新加载 systemctl 配置文件</span><br><span class="line"></span><br><span class="line">$ ./shadowsocks-libev.sh uninstall   # 卸载 SS</span><br><span class="line">$ /etc/init.d/shadowsocks start      # 启动 SS</span><br><span class="line">$ /etc/init.d/shadowsocks stop       # 停止 SS</span><br><span class="line">$ /etc/init.d/shadowsocks restart    # 重启 SS</span><br><span class="line">$ /etc/init.d/shadowsocks status     # 状态 SS</span><br><span class="line"></span><br><span class="line">$ sudo systemctl restart shadowsocks_libev</span><br><span class="line">$ sudo systemctl status shadowsocks_libev -l</span><br><span class="line"></span><br><span class="line">$ sudo systemctl restart kcptun_server # 启动 kcptun</span><br><span class="line">$ sudo systemctl status kcptun_server  -l # 查看 systemctl 服务运行状态</span><br></pre></td></tr></table></figure>

<h2 id="更多"><a href="#更多" class="headerlink" title="更多"></a>更多</h2><p>编辑 limits.conf 配置文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vim /etc/security/limits.conf</span><br></pre></td></tr></table></figure>
<p>添加下列两行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">* soft nofile 51200</span><br><span class="line">* hard nofile 51200</span><br></pre></td></tr></table></figure>

<p>如果服务在root权限下运行，添加下列两行:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">root soft nofile 51200</span><br><span class="line">root hard nofile 51200</span><br></pre></td></tr></table></figure>

<p>在 bash 或 zsh 配置文件（例如：.zshrc）加入：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ulimit -n 51200</span><br></pre></td></tr></table></figure>

<h3 id="sysctl-conf"><a href="#sysctl-conf" class="headerlink" title="sysctl.conf"></a>sysctl.conf</h3><p>配置路径：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo vim /etc/sysctl.conf</span></span><br></pre></td></tr></table></figure>
<p>添加配置：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fs.file-max = 51200</span><br><span class="line"></span><br><span class="line">net.core.default_qdisc = fq</span><br><span class="line">net.ipv4.tcp_congestion_control = bbr</span><br><span class="line"></span><br><span class="line"># KCP: for better handling of UDP packets</span><br><span class="line">net.core.rmem_max=26214400 // BDP - bandwidth delay product</span><br><span class="line">net.core.rmem_default=26214400</span><br><span class="line">net.core.wmem_max=26214400</span><br><span class="line">net.core.wmem_default=26214400</span><br><span class="line">net.core.netdev_max_backlog=2048 // proportional to -rcvwnd</span><br><span class="line">net.core.somaxconn = 65535</span><br><span class="line"></span><br><span class="line">net.ipv4.tcp_keepalive_time = 60</span><br><span class="line">net.ipv4.tcp_keepalive_intvl = 10</span><br><span class="line">net.ipv4.tcp_keepalive_probes = 6</span><br><span class="line">net.ipv4.tcp_mtu_probing = 1</span><br><span class="line">net.ipv4.tcp_timestamps = 0</span><br><span class="line">net.ipv4.tcp_fastopen = 3</span><br><span class="line">net.ipv4.tcp_syncookies = 1</span><br><span class="line">net.ipv4.tcp_fin_timeout = 30</span><br><span class="line">net.ipv4.tcp_mem = 25600 51200 102400</span><br><span class="line">net.ipv4.tcp_rmem = 4096 87380 67108864</span><br><span class="line">net.ipv4.tcp_wmem = 4096 65536 67108864</span><br><span class="line">net.ipv4.tcp_tw_reuse = 0</span><br><span class="line">net.ipv4.tcp_tw_recycle = 0</span><br><span class="line">net.ipv4.tcp_fin_timeout = 30</span><br></pre></td></tr></table></figure>
<p>加载配置：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo sysctl --system</span></span><br></pre></td></tr></table></figure>

<p>使用 iperf 测试服务器的直接网速：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 服务端</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> iperf -s</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 客户端</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> iperf -c <span class="variable">$yourhost</span> -i 2 -t 30</span></span><br></pre></td></tr></table></figure>
<p>测速来平均服务器的网速有：<br>17.1 Mbits/sec</p>
<p>使用 fast.com 测试平均结果显示：<br>10 Mbits/sec</p>
<p>以下配置方案可能会更好：<br><a href="https://teddysun.com/569.html">使用 Docker 快速部署 Shadowsocks-libev + v2ray-plugin</a></p>
<p>技术无罪，谨守初心。</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul>
<li><a href="https://www.ruanyifeng.com/blog/2016/03/systemd-tutorial-part-two.html">Systemd 入门教程：实战篇 - 阮一峰的网络日志</a></li>
<li><a href="https://shadowsocks.org/en/config/advanced.html">Shadowsocks - Advanced</a></li>
<li><a href="https://bitsflow.org/network/tuning-tcp-performance/">优化TCP服务端</a></li>
</ul>
]]></content>
      <categories>
        <category>信息技术</category>
      </categories>
      <tags>
        <tag>代理</tag>
      </tags>
  </entry>
  <entry>
    <title>程序中的 “脚手架”</title>
    <url>/scaffold/</url>
    <content><![CDATA[<blockquote>
<p>百度百科: 脚手架是为了保证各施工过程顺利进行而搭设的工作平台。</p>
</blockquote>
<h2 id="脚手架概念"><a href="#脚手架概念" class="headerlink" title="脚手架概念"></a>脚手架概念</h2><p>编程领域中的“脚手架（Scaffolding）”指的是能够快速搭建项目“骨架”的一类工具。在新建项目时，你不得不手动创建固定的文件目录，繁琐而累赘。脚手架的作用就是帮助你完成这些重复性的工作，包括一键生成主要的目录结构、安装依赖等等。</p>
<span id="more"></span>

<h2 id="React-脚手架"><a href="#React-脚手架" class="headerlink" title="React 脚手架"></a>React 脚手架</h2><ul>
<li><a href="https://github.com/facebook/create-react-app">facebook/create-react-app</a></li>
<li>go 语言框架 beego 的脚手架 bee（go get github.com/beego/bee）</li>
</ul>
]]></content>
      <categories>
        <category>信息技术</category>
      </categories>
      <tags>
        <tag>信息技术</tag>
      </tags>
  </entry>
  <entry>
    <title>搜索引擎使用技巧</title>
    <url>/se-operators/</url>
    <content><![CDATA[<p><img data-src="http://images.xyang.xin/2020%2F05%2F29%2F1590724982.png?x-oss-process=style/title_800" alt="1590724982.png"></p>
<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>生活离不开搜索引擎了，我曾尝试在思考，是不是未来的开卷考试，会允许使用某个特定的搜索引擎。<span id="more"></span></p>
<p>什么是搜索引擎呢？搜索引擎就像一本不断更新的通讯录，它日夜不停的到处网罗手机号码及个人资料，也有一些”推销员“主动的向其提供自己的联系方式。人们通过这本通讯录可以快速的找到自己感兴趣的内容。</p>
<h2 id="常用的搜索方式"><a href="#常用的搜索方式" class="headerlink" title="常用的搜索方式"></a>常用的搜索方式</h2><p>如何使用搜索引擎？那和使用手机上的通讯录相差无几，通过姓名可以找到这个人的名片，包含手机号、地址、其他手机号；通过手机号，也可以找到这个人得名片，如果通讯录中有的话。</p>
<p>想要了解鱼香肉丝的做法，就输入 <code>鱼香肉丝</code>，我想要麻辣口味的鱼香肉丝呢，就输入 <code>鱼香肉丝 麻辣</code>。</p>
<p>通过以上方式——简单的关键字查询，对于大部分情况足矣。</p>
<p>在 Google 搜索引擎输入框输入：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">the world will be better 鱼香肉丝</span><br></pre></td></tr></table></figure>
<p>Then 回车：<br><img data-src="http://images.xyang.xin/2020%2F05%2F31%2F1590917944.png?x-oss-process=style/title_800" alt="1590917944.png"></p>
<p>点击红色框框里面的 <code>world</code>，输入框里的 <code>world</code> 机会被加上引号，代表搜索结果中必须包含 <code>world</code>（must include）。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">the &quot;world&quot; will be better 鱼香肉丝</span><br></pre></td></tr></table></figure>

<p>对，我也是一个“推销员”，所以我把我的联系方式提交给了通讯录，那我怎么知道通讯录里面有没有我呢？<code>site:blog.xyang.xin</code>。</p>
<p>这些就是我日常所使用到的搜索方法了。</p>
<h2 id="搜索优化"><a href="#搜索优化" class="headerlink" title="搜索优化"></a>搜索优化</h2><p>今天在 <a href="http://www.ruanyifeng.com/blog/2020/05/weekly-issue-109.html">新一期的科技爱好者周刊</a> 中看到：“<a href="https://quickref.dev/">Quickref</a> 一个针对程序员的搜索引擎，只搜索编程相关的网站。”出于好奇去看了一下：<br><img data-src="http://images.xyang.xin/2020%2F05%2F31%2F15909154253728.jpg?x-oss-process=style/title_800" alt="15909154253728.jpg"></p>
<p>首页有点不一样，多了一些内容：</p>
<ul>
<li>默认逐字搜索（搜索结果必须同时包含输入的所有关键字）；</li>
<li><code>~</code> 用于将关键字设置为可选（也就是搜索结果不必一定包含该关键字）；</li>
<li><code>-</code> 减号，排除该关键字（搜索结果不包含该关键字）；</li>
<li><code>site:</code> 仅针对某个特定网址进行搜索；</li>
<li><code>intitle:</code> 搜索结果仅显示网站标题包含关键字的内容；</li>
<li><code>*</code> 通配符；</li>
<li><code>!gh</code> 重定向到 Github 搜索；</li>
<li><code>!mdn</code> 重定向到 Mozilla MDN 搜索。</li>
</ul>
<p>为什么 Google、百度等搜索引擎都没有在首页给出类似的操作符 (Operators) 提示列表，或者显示一个链接到帮助文档？</p>
<p>我认为有如下原因：</p>
<ol>
<li>大多数情况下最基本的搜索方式就足够用了，不需要花费很多时间去进行额外的学习，我至今就仅仅使用了前文所阐述的几种搜索方法；</li>
<li>百度、Google 等搜索引擎作为通用软件，将 KISS(Keep it simple, stupid) 原则运用到极致，软件就是要用起来越简单越好。</li>
</ol>
<p>搜索引擎的核心价值无疑是拼尽全力把你最感兴趣的内容送到你的眼前，但是要懂一个人的心，在能读取你想法的机器研发出来之前，简直太难。所以为了让搜索引擎更懂我们，我认为进一步学习一些搜索引擎操作符是有必要的。Google 是我最常用的搜索引擎，百度有时也用，但下面介绍的操作符仅在 Google 上测试有效。</p>
<ul>
<li><code>@</code> 搜索社交媒体：<code>@twitter</code>；</li>
<li><code>-</code> 搜索结果不包含该关键字；</li>
<li><code>&quot;&quot;</code> 引号中的内容在搜索结果中必须完全匹配；</li>
<li><code>..</code> 在一定范围内搜索：<code>$50..$100</code>；</li>
<li><code>OR</code> 合并搜索，将两个搜索语句搜索到的内容合并起来显示：<code>site:nytimes.com OR @twitter</code>，搜索结果将同时显示 <code>site:nytimes.com</code> 搜索到的内容和 <code>@twitter</code> 搜索到的内容。需要 <code>AND</code> 吗？空格其实相当于 <code>AND</code>，需要 <code>NOT</code> 吗？<code>-</code> 相当于 <code>NOT</code>；</li>
<li><code>site:</code>,<code>site:youtube.com</code> 或者 <code>site:.gov</code>、<code>site:.edu</code>；</li>
<li><code>related:</code>，<code>related:google.com</code> 搜索结果就有 Yahoo、Bing、DuckDuckGo 等搜索引擎，可能因为其独特算法的原因，目前百度、Yandex 都没有，这个不好用，可能对美国本土网站支持比较好；</li>
<li><code>intext:</code> 搜索主体部分包含关键字的网页，<code>intext:&quot;仰望星空 埋头工作&quot;</code></li>
<li><code>allintext:</code> 搜索主体部分包含所有关键词的网页。<code>allintext: 鱼香肉丝 鳗鱼饭 威士忌 </code>；<br><img data-src="http://images.xyang.xin/2020%2F06%2F01%2F1591012218.png?x-oss-process=style/title_800?x-oss-process=style/title_800" alt="1591012218.png"></li>
<li><code>intitle</code> 搜索标题包含关键词的网页，<code>intitle:&quot;world peace&quot;</code>；</li>
<li><code>allintitle</code> 搜索标题包含所有关键词的网页；</li>
<li><code>inurl</code> 搜索 URL 包含关键词的网页，<code>inurl:plant</code>；</li>
<li><code>allinurl</code> 搜索 URL 中包含所有关键词的网页，<code>allinurl:plant growing</code>；</li>
<li><code>intext:</code> 搜索主体部分包含关键词的网页，<code>intext:grow</code>；</li>
<li><code>allintext:</code> 搜索主体部分包含所有关键词的网页，<code>allintext:pant growing</code>；</li>
<li><code>filetype:</code> 针对文件类型进行搜索，<code>filetype:doc</code><a href="https://support.google.com/webmasters/answer/35287?hl=en">Google 可索引的文件类型</a></li>
<li><code>imagesize:</code> 搜索指定尺寸的图片，<code>imagesize:500x400</code>，<a href="https://www.google.com/advanced_image_search">Google 高级图片搜索</a>；</li>
<li><code>inanchor:</code> 搜索 anchor 包含关键词的网页，什么是 anchor？<code>&lt;a src=&quot;https://blog.xyang.xin&quot;&gt;world peace&lt;/a&gt;</code>，这里的 <code>world peace</code> 就是 <code>anchor</code>，一个链接除开其既定的功能，例如可以点击进行跳转，还有就是其内容 <code>src</code> 里的 URL，以及 <code>&lt;a&gt;&lt;/a&gt;</code> 标签所包含 <code>anchor</code>；<br><img data-src="http://images.xyang.xin/2020%2F06%2F03%2F1591161153.png?x-oss-process=style/title_800" alt="1591161153.png"></li>
<li><code>allinanchor:</code> 搜索 anchor 包含所有关键词的网页，<code>allinanchor:world peace</code>；</li>
<li><code>cache:</code> 查看 Google 对相应网站的缓存情况，<code>cache:www.wikipedia.org</code>；</li>
<li><code>define:</code> 该操作符将展示一个关键词简明定义的信息卡，在信息卡下面是字典和其它在线参考的链接。<code>define:&quot;world peace&quot;</code> 和 <code>define: world peace</code> 搜索结果几乎一样；<br><img data-src="http://images.xyang.xin/2020%2F06%2F03%2F1591173332.png?x-oss-process=style/title_800" alt="1591173332.png"></li>
<li><code>stocks:</code>stocks（股市），搜索结果将显示与金融相关的内容，<code>stocks:dell</code> 与 <code>dell</code> 将得到不同的搜索结果；</li>
<li><code>wheather:</code> 查看特定地点的天气，<code>weather:beijing</code>；</li>
<li><code>map:</code> 查看特定地点的地图，<code>map: 北京 </code>；</li>
<li><code>in</code> 单位转换，常用的单位都有 <code>$329 in CNY</code>，<code>100cm in m</code>；</li>
<li><code>()</code> 对搜索语句进行分组。</li>
</ul>
<blockquote>
<p>Tip：</p>
<ol>
<li><p>Google 搜索通常会忽略不属于操作符的标点符号，英文大小写不影响搜索结果。不管加不加 <code>&quot;&quot;</code> 引号，标点符号和英文大小写都不影响搜索结果。</p>
</li>
<li><p>不要在操作符与搜索关键字之间留空格。<code>site:nytimes.com</code>，而不是 <code>site：nytimes.com</code>。</p>
</li>
<li><p>上述的关键词都包含关键词和关键句，简单理解不管词还是句都是字符串。<code>&quot;&quot;</code> 引号包含的内容为什么是完全匹配，因为搜索引擎将其整体视为一个字符串，并且它的另一层含义是必须包含。所以说 <code>intitle</code>、<code>intext</code> 如果搜索的内容是一个语句里面有空格的话，就必须用 <code>&quot;&quot;</code> 扩起来。</p>
</li>
<li><p>有些操作符可能因为更新而不可用，并且很难找到官方的更新说明，但是那些基本的应该不会被改变。</p>
</li>
</ol>
</blockquote>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul>
<li><a href="https://support.google.com/websearch/answer/2466433?hl=en">Refine web searches - Google Search Help</a></li>
<li><a href="https://builtmighty.com/blog/search-sites-google-site-search/">How to Search Any Website Using a Google Site Search | Built Mighty</a></li>
<li><a href="https://ahrefs.com/blog/google-advanced-search-operators/">Google Search Operators: The Complete List (42 Advanced Operators)</a></li>
<li>Stephan Spencer.《Google Power Search: The Essential Guide to Finding Anything Online With Google》.Second Edition.2017</li>
</ul>
]]></content>
      <categories>
        <category>信息技术</category>
      </categories>
      <tags>
        <tag>SE</tag>
        <tag>搜索引擎</tag>
        <tag>Google</tag>
      </tags>
  </entry>
  <entry>
    <title>Vim 自动补全之 YCM</title>
    <url>/shell-java/</url>
    <content><![CDATA[<p>IDEA 打开得太慢了，我需要一款轻量级的 IDE，不想装其他乱七八糟的编译器咋办？搞事情！</p>
<span id="more"></span>
<h2 id="sublime"><a href="#sublime" class="headerlink" title="sublime"></a>sublime</h2><p>sublime 通过简单的配置后可以实现 java 代码的高亮提示和编译功能，并且大多编译错误也能基本上精确到行。<br>然而 sublime 内置的终端无法输入，虽然在日常的算法中输入操作很少涉及，, 但还是很不爽。</p>
<h2 id="Vim"><a href="#Vim" class="headerlink" title="Vim"></a>Vim</h2><p>这里需要一定的 Vim 基础，新手请执行 <code>vimtutor</code> 查看 Vim 官方教程，再继续往后看。<br>在终端通过 java 命令即可实现 java 代码的编译与运行。<br>vim 不过起到的是编辑器的作用。<br>对于编辑器我们不仅有高亮的基本要求，同样也需要基本的代码补全功能, Vim 的 YCM 插件能较好的实现代码补全功能。<br>下面介绍通过 vim 的 vim-plug 插件管理器 来安装 YCM 。</p>
<h2 id="预备工作"><a href="#预备工作" class="headerlink" title="预备工作"></a>预备工作</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">xcode-select --install</span><br><span class="line">brew install cmake vim</span><br></pre></td></tr></table></figure>

<h2 id="vim-plug-安装"><a href="#vim-plug-安装" class="headerlink" title="vim-plug 安装"></a>vim-plug 安装</h2><p><a href="https://github.com/junegunn/vim-plug">junegunn/vim-plug</a></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl -fLo ~/.vim/autoload/plug.vim --create-dirs \</span><br><span class="line">    https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim</span><br></pre></td></tr></table></figure>
<h2 id="安装-YCM"><a href="#安装-YCM" class="headerlink" title="安装 YCM"></a>安装 YCM</h2><p><a href="https://github.com/Valloric/YouCompleteMe">YCM Github</a></p>
<h3 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h3><p>YCM 可通过 vim-plug 下载，而安装使用则需要进一步的编译。</p>
<p>在 .vimrc 文件中添加 <code>Plug &#39;Valloric/YouCompleteMe&#39; </code> 再执行 :PluginInstall 即可。</p>
<h3 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h3><p>YCM 基于 cmake 进行编译的，所以在安装之前如下命令先通过 brew 安装 cmake。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd ~/.vim/plugged/YouCompleteMe</span><br><span class="line">python3 ./install.py --java-completer</span><br></pre></td></tr></table></figure>
<p>请使用 python3 。</p>
<p>安装好之后，由于我的 python3 缺乏很多依赖性，通过以下命令检验 python 所缺乏的依赖。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd ~/.vim/plugged/YouCompleteMe/third_party/ycmd</span><br><span class="line">cp ycmd/default_settings.json . &amp; python3 ycmd --options_file default_settings.json</span><br></pre></td></tr></table></figure>
<p>如果输出如下，是 python 环境的问题考虑重启然后重装：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[1]    8629 segmentation fault  python3 ycmd --options_file default_settings.json</span><br></pre></td></tr></table></figure>
<p>若有如下报错：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ModuleNotFoundError: No module named &#x27;bottle&#x27;</span><br><span class="line">ModuleNotFoundError: No module named &#x27;waitress&#x27;</span><br></pre></td></tr></table></figure>
<p>逐句执行 <code>pip3 install bottle</code> <code>pip3 install waitress</code>即可解决。<br>如果显示是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">No module named &#x27;ycm_core&#x27;</span><br></pre></td></tr></table></figure>
<p>是没有问题的</p>
<h2 id="YCM-安装-C-family-的自动补全"><a href="#YCM-安装-C-family-的自动补全" class="headerlink" title="YCM 安装 C-family 的自动补全"></a>YCM 安装 C-family 的自动补全</h2><h3 id="编译安装"><a href="#编译安装" class="headerlink" title="编译安装"></a>编译安装</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd ~/.vim/plugged/YouCompleteMe</span><br><span class="line">python3 ./install.py --clang-completer</span><br></pre></td></tr></table></figure>
<h3 id="安装-ycm-gennerator"><a href="#安装-ycm-gennerator" class="headerlink" title="安装 ycm-gennerator"></a>安装 ycm-gennerator</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Plugin &#x27;rdnetto/YCM-Generator&#x27;</span><br></pre></td></tr></table></figure>
<h3 id="生成-ycm-extra-conf-py-文件到-YCM-中"><a href="#生成-ycm-extra-conf-py-文件到-YCM-中" class="headerlink" title="生成 .ycm_extra_conf.py 文件到 YCM 中"></a>生成 .ycm_extra_conf.py 文件到 YCM 中</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">python3 .ycm_extra_conf.py ~/.vim/plugged/YouCompleteMe/third_party/ycmd</span><br></pre></td></tr></table></figure>
<h3 id="在-vimrc-中添加"><a href="#在-vimrc-中添加" class="headerlink" title="在 ~/.vimrc 中添加"></a>在 ~/.vimrc 中添加</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let g:ycm_global_ycm_extra_conf = &#x27;～/.vim/plugged/YouCompleteMe/third_party/ycmd/.ycm_extra_conf.py&#x27;</span><br></pre></td></tr></table></figure>

<h2 id="go-语言"><a href="#go-语言" class="headerlink" title="go 语言"></a>go 语言</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd ~/.vim/plugged/YouCompleteMe</span><br><span class="line">python3 ./install.py --go-completer</span><br></pre></td></tr></table></figure>

<h2 id="其他语言参数"><a href="#其他语言参数" class="headerlink" title="其他语言参数"></a>其他语言参数</h2><ul>
<li>C family support: <code>python3 ./install.py --clang-completer</code></li>
<li>C# support: <code>python3 ./install.py --cs-completer </code>（install Mono with Homebrew or by downloading the <a href="http://www.mono-project.com/docs/getting-started/install/mac/">Mono macOS package</a> ）</li>
<li>Go support: <code>python3 ./install.py --go-completer</code> </li>
<li>JavaScript and TypeScript support: <code>python3 ./install.py --ts-completer</code> </li>
<li>Rust support: <code>python3 ./install.py --rust-completer</code></li>
<li>Java support: <code>python3 ./install.py --java-completer</code></li>
</ul>
<h2 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">:PlugUpdate</span><br></pre></td></tr></table></figure>
<p>或</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd ~/.vim/plugged/YouCompleteMe</span><br><span class="line">git clean -f</span><br><span class="line">git pull</span><br><span class="line">git submodule update --recursive --init</span><br><span class="line">./install.py --go-completer</span><br></pre></td></tr></table></figure>

<h2 id="错误解决"><a href="#错误解决" class="headerlink" title="错误解决"></a>错误解决</h2><p>升级 catalina 后 brew 安装的 python3 执行异常，解决方案如下：<br><a href="https://forums.developer.apple.com/thread/119429">My application crashed with invalid load of lib… |Apple Developer Forums</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/bin/zsh</span><br><span class="line">brew update &amp; brew upgrade &amp; brew install openssl</span><br><span class="line">cd /usr/local/Cellar/openssl/1.0.2t/lib</span><br><span class="line">sudo cp libssl.1.0.0.dylib libcrypto.1.0.0.dylib /usr/local/lib/</span><br><span class="line">cd /usr/local/lib</span><br><span class="line">mv libssl.dylib libssl_bak.dylib</span><br><span class="line">mv libcrypto.dylib libcrypto_bak.dylib</span><br><span class="line">sudo ln -s libssl.1.0.0.dylib libssl.dylib</span><br><span class="line">sudo ln -s libcrypto.1.0.0.dylib libcrypto.dylib</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>信息技术</category>
      </categories>
      <tags>
        <tag>开发工具</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 剪贴板小技巧</title>
    <url>/ssh-clipboard-iterm2/</url>
    <content><![CDATA[<h2 id="初步识-vim-剪贴板"><a href="#初步识-vim-剪贴板" class="headerlink" title="初步识 vim 剪贴板"></a>初步识 vim 剪贴板</h2><p>对于文本的复制粘贴，系统会提供剪贴板，剪贴板在 vim 中被称为寄存器，并且 vim 有很多寄存器，寄存器使用的语法：<code>&quot;&#123;register&#125;</code>，当然了寄存器指令不会单独使用，后面都会跟代表复制的 <code>y</code> 或代表粘贴的 <code>p</code>，执行 <code>&quot;ay</code> 就将选中的内容复制到了 <code>a</code> 寄存器，<span id="more"></span>寄存器都是有自己的名字的，感兴趣的同学，欲知详细内容请参见帮助文档：<code>:help registers</code>。</p>
<p>那咱们平时执行 <code>yy</code> 或者选中 <code>y</code> 使用的寄存器叫什么名字呢？它叫匿名寄存器 (<code>&quot;&quot;</code>)。<code>y</code> 就等于 <code>&quot;&quot;y</code>。</p>
<p>比较重要的是，系统剪贴板寄存器 <code>&quot;*</code>。通过 <code>&quot;*p</code> 就可以把系统剪贴板上的内容粘贴到 vim 文件内了。</p>
<p><code>*p</code> 从系统剪贴板粘贴容易，而要从 vim 复制到系统剪贴板，首先选中文本，然后执行 <code>&quot;*y</code>，这多麻烦，所以我选择：</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="comment">&quot; .vimrc</span></span><br><span class="line"><span class="keyword">set</span> clipboard=unnamed</span><br></pre></td></tr></table></figure>
<p>这样就让系统剪贴板 (<code>&quot;*</code>) 和匿名剪贴板 (<code>&quot;&quot;</code>) 内容保持同步了。<code>y</code> 就同时等效于 <code>&quot;&quot;y</code> 、 <code>&quot;*y</code> ，而 <code>p</code> 等价于 <code>&quot;&quot;p</code>、<code>&quot;*p</code> 以及 <code>command+v</code> 或者 Windows 的 <code>ctrl+v</code>。</p>
<h2 id="远程剪贴板操作"><a href="#远程剪贴板操作" class="headerlink" title="远程剪贴板操作"></a>远程剪贴板操作</h2><p>通过 SSH 连接到了一台远程 Linux 服务器，这时候该任何复制粘贴呢？</p>
<p>Someone said at once: “Stupid! Mac 上当然是鼠标选中然后 <code>command+c</code>、<code>command+v</code> 了，Windows 上是 <code>ctrl+c</code>、<code>ctrl+v</code>，虽然 <code>ctrl+v</code> 会和 vim 切换成可视模式冲突，但是我用 <code>ctrl+shift+v</code> 就解决了。”</p>
<p>这方法很便捷，并且我也经常使用，但是在使用过程中主要遇到以下两个问题：</p>
<ol>
<li>如果你的 vim 开启了行号，鼠标选中多行的时候，会选中行号，复制下来的内容也会也行号。我的 vim 是默认开启行号的。</li>
<li>只能复制一个窗口大小的内容。</li>
</ol>
<p>其实还有一个问题，就是不能完全脱离鼠标，我是三分之二键盘党，所以我认为这不是主要问题。</p>
<p>这些问题不是都已经解决了吗？如果设置了 <code>set clipboard=unnamed</code>，直接选中（注意不是鼠标选中，而是 vim 中的选中 <code>shift+v</code> 上下键）然后 <code>y</code>，然后 <code>p</code>。那你试试 <code>command+v</code> 或 <code>ctrl+v</code> 呢？保证不是你刚刚复制的内容。</p>
<p>短路了吧？重新认识一下，你现在同时使用了两个系统，一个是本地，一个是远程服务器，<code>y</code> 复制的内容在远程服务器上呢，还在你公司，在杭州，在北京，还是在海外呢？</p>
<p>那我不用 <code>command+v</code> 可好，有 <code>p</code>，还少按一个键。</p>
<p>漂亮！你已经找到答案了。</p>
<h3 id="剪贴板远程传送"><a href="#剪贴板远程传送" class="headerlink" title="剪贴板远程传送"></a>剪贴板远程传送</h3><p>那如果我想将远程服务器的一段字符传送到本地呢？有人说 <strong>scp</strong>，但在实际操作中，通过 <strong>scp</strong> 或者 <strong>ftp</strong>，传送文件还 ok，传送一段文本的即时性就太差了。</p>
<p>找到两种比较好的办法，但是针对的客户端是 Mac 或者 Linux，据了解 Windows 自带有 Linux 子系统，可以开启试试。</p>
<p>方法一：</p>
<blockquote>
<p>该方法使用了一个叫 <strong>clipper</strong> 的 <strong>go</strong> 语言程序，以及 <strong>vim-clipper</strong> 插件，两个项目的链接都在下面。但是我没有用过这种方式，一方面配置较多，而且要在本地跑额外的程序，可能功能比较强大但是我用不了这么多，另一方面就是有第二种比较适合我的方式。</p>
</blockquote>
<ul>
<li><a href="https://github.com/wincent/clipper">wincent/clipper: ✂️ Clipboard access for local and remote tmux sessions</a></li>
<li><a href="https://github.com/wincent/vim-clipper">wincent/vim-clipper: Clipper integration for Vim</a></li>
</ul>
<p>For Mac User:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> brew install clipper</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> brew services start clipper</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ssh -R localhost:8377:localhost:8377 user@host.example.org</span></span><br></pre></td></tr></table></figure>

<p>For Linux User:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> yum install golang</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">clone</span> git://git.wincent.com/clipper.git</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> clipper</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> go build</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo cp clipper /usr/<span class="built_in">local</span>/bin</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> cp contrib/linux/systemd-service/clipper.service ~/.config/systemd/user</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> systemctl --user daemon-reload</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> systemctl --user <span class="built_in">enable</span> clipper.service</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> systemctl --user start clipper.service</span></span><br></pre></td></tr></table></figure>

<p>方法二：<br>该方式，仅适合使用 <strong>Mac</strong> 及 <strong>iTerm.app</strong> 的用户。</p>
<p><code>iTerm-&gt;Perferences-&gt; Selection-&gt;Application in terminal may access clipboard</code>（选择开启），可能版本更新这个功能的位置会有所变动。</p>
<p>在远程服务器执行如下命令(如果使用的是<strong>bash</strong>将<strong>zsh</strong>改为<strong>bash</strong>即可)：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ cd</span><br><span class="line">$ curl -L https://iterm2.com/shell_integration/install_shell_integration_and_utilities.sh | zsh</span><br></pre></td></tr></table></figure>
<p>命令下载<code>.iterm2_shell_integration.zsh</code>脚本到用户根目录，还有一些小程序到<code>~/.iterm2</code>目录下，<br>并在<code>.zshrc</code>末尾生成<code>test -e &quot;$&#123;HOME&#125;/.iterm2_shell_integration.zsh&quot; &amp;&amp; source &quot;$&#123;HOME&#125;/.iterm2_shell_integration.zsh&quot; </code><br>卸载的时候也只需要将这三个部分删除掉即可。</p>
<p>在vim配置文件<code>.vimrc</code>下添加如下代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if !empty(&#x27;~/.iterm2/it2copy&#x27;)</span><br><span class="line">  vmap &lt;silent&gt; &lt;Leader&gt;y :&#x27;&lt;,&#x27;&gt;:w !~/.iterm2/it2copy&lt;CR&gt;&lt;CR&gt;</span><br><span class="line">endif</span><br></pre></td></tr></table></figure>

<p>此时<code>shift+v</code>选中文本，执行 <code>&lt;leader&gt;y</code>，文本就到你本地的剪贴板啦。不信你就<code>command+v</code>。</p>
]]></content>
      <categories>
        <category>信息技术</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>剪贴板</tag>
        <tag>Vim</tag>
      </tags>
  </entry>
  <entry>
    <title>SSM 错误集锦</title>
    <url>/ssm-Error/</url>
    <content><![CDATA[<ol>
<li>class path resource [spring/] cannot be resolved to URL because it does not exist</li>
</ol>
<ul>
<li>条件：这是非编译情况下利用mvn的插件war:war生成war包，运行后所报的错误。</li>
<li>原因：未将resources下的配置文件引入war包中。</li>
<li>解决方法：先执行代码，再生成war包。<span id="more"></span></li>
</ul>
<ol start="2">
<li>check the manual that corresponds to your MySQL server version for the right syntax to use near … , The error may involve .insert-Inline</li>
</ol>
<ul>
<li>原因：mysql 向数据库插入数据时错误， 可能触及到mysql的保留字，例如 key。</li>
<li>解决办法： 插入语句不能起别名，该方式不可取。加键盘左上角的撇号，例<code>key</code>。</li>
</ul>
<ol start="3">
<li><p>java.lang.Double cannot be cast to java.lang.String<br>list中查出来个别数据是 double，转换为 String。<br>String periodTime = String.valueOf(list.get(0));</p>
</li>
<li><p>Error running ‘tomcat’: Can’t find catalina.jar</p>
</li>
</ol>
<ul>
<li>原因：tomcat 升级导致路径改变</li>
<li>解决办法：Idea 在 Edit Configuration 中修改 tomcat 路径至 libexec</li>
</ul>
]]></content>
      <categories>
        <category>信息技术</category>
      </categories>
      <tags>
        <tag>ssm</tag>
      </tags>
  </entry>
  <entry>
    <title>SSM 问题集锦</title>
    <url>/ssm-question/</url>
    <content><![CDATA[<h1 id="SSM-问题集锦"><a href="#SSM-问题集锦" class="headerlink" title="SSM 问题集锦"></a>SSM 问题集锦</h1><h2 id="SSM-基础的搭建过程"><a href="#SSM-基础的搭建过程" class="headerlink" title="SSM 基础的搭建过程"></a>SSM 基础的搭建过程</h2><p><a href="https://blog.csdn.net/yangxinyujy/article/details/80656771">IntelliJ IDEA 创建 Maven 管理下的 SSM 项目基础全过程</a><br><a href="https://github.com/yangxinyujy/ssmdemo">yangxinyujy/ssmdemo: ssm 基础框架</a></p>
<span id="more"></span>

<h2 id="Tomcat-部署时-war-和-war-exploded-区别"><a href="#Tomcat-部署时-war-和-war-exploded-区别" class="headerlink" title="Tomcat 部署时 war 和 war exploded 区别"></a>Tomcat 部署时 war 和 war exploded 区别</h2><p>war 模式：将WEB工程以包的形式上传到服务器，可以称之为是发布模式，这是先打成 war 包，再发布；<br>war exploded模式：将 WEB 工程以当前文件夹的位置关系上传到服务器，通过直接把文件夹、jsp 页面 、classes 等,移到 Tomcat 部署文件夹里面的方式，进行加载部署。因此这种方式支持热部署，一般在开发的时候也是用这种方式。</p>
]]></content>
      <categories>
        <category>信息技术</category>
      </categories>
      <tags>
        <tag>ssm</tag>
      </tags>
  </entry>
  <entry>
    <title>Vim8 操作简记</title>
    <url>/vim-manipulate/</url>
    <content><![CDATA[<p>Normal 模式是 Vim 默认打开状态。我们可以通过 Normal 模式，任何其它模式，我们可以在 Normal 模式下对文本进行浏览、排版、修改。Normal 模式在 Vim 中具有举足轻重的作用。</p>
<p>在 Normal 模式下，除了基本的移动指令 (j、k、h、l)、插入指令 (i、a)、撤销指令 (u、U) 等。Vim 通过 “操作符 + 运作命令 = 操作”（出自《Vim 实用技巧 第 2 版》） 扩展出了大量的操作指令。</p>
<span id="more"></span>
<p>指令、操作、操作指令都是，由人向计算机输入指令，计算机就会返回程序预设的结果。不过操作给我的感觉更像动词，所以后面我用指令来代替他。如上述等式所言指令由两部分组成，即 operator 和 motion，用前者指定行为，后者指定作用范围。还有一些只能在 Visual 模式或 operator 后面使用的叫：text object selection，文本对象选择器。</p>
<p>有一条额外的规则，即当一个操作符命令被连续调用两次时候，它会作用于当前行。如：<code>dd</code> 删除当前行；<code>yy</code> 复制当前行；<code>&gt;&gt;</code> 缩进当前行；<code>gUgU</code> 将当前行转换为大写，可以简写为 <code>gUU</code>。</p>
<h2 id="常用指令"><a href="#常用指令" class="headerlink" title="常用指令"></a>常用指令</h2><h3 id="Characterwise-motions"><a href="#Characterwise-motions" class="headerlink" title="Characterwise motions"></a>Characterwise motions</h3><ul>
<li>dl 向右删除一个字符<ul>
<li>d (delete)</li>
<li>l ( 右移一个字符，和 left 没有关系，键位好按）</li>
<li>一般用 x 代替</li>
</ul>
</li>
<li>dh 向左删除一个字符<ul>
<li>h ( 左移一个字符）</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li>dw 向右删除至下一个单词的开头<ul>
<li>w (words forward)</li>
<li>W 大写表示只使用空格作为分隔</li>
</ul>
</li>
<li>de 向左删除至单词的末尾，如果本身处于单词末尾，那么删除至下一个单词末尾<ul>
<li>e (Forward to the end of word)</li>
<li>E 大写表示只使用空格作为分隔</li>
</ul>
</li>
<li>dge 向左删除至上一个单词的末尾<ul>
<li>ge (Backward to the end of word)</li>
<li>gE 大写表示只使用空格作为分隔</li>
</ul>
</li>
<li>db 向右删除至单词的开头，如果本身处于单词开头，那么删除至上一个单词的开头<ul>
<li>b (words backward)</li>
<li>B 大写表示只使用空格作为分隔</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li>dd 删除当前行</li>
<li>d^ 删除光标之前的内容至空白字符处 (non-blank character)</li>
<li>d0 删除光标之前的内容</li>
<li><del>dg_ 删除光标之后的内容至空白字符处</del></li>
<li>d$ 删除光标及光标之后的内容</li>
</ul>
<h3 id="Linewise-motions"><a href="#Linewise-motions" class="headerlink" title="Linewise motions"></a>Linewise motions</h3><ul>
<li>dj 删除本行及下一行</li>
<li>dk 删除本行及上一行 </li>
<li>dG 删除至文章末尾<ul>
<li>G (Goto line，默认最后一行）</li>
</ul>
</li>
<li>dgg 删除至文章开头<ul>
<li>gg（Goto line，默认最后一行）</li>
</ul>
</li>
<li>ggdG (删除整篇文章内容)<br>使用 <code>gg*G</code> 对整篇文章进行操作比较麻烦，安装插件可以更加便捷：<br><a href="https://github.com/kana/vim-textobj-entire">kana/vim-textobj-entire</a><br>执行 <code>dae</code> 就可以达到和执行 <code>ggdG</code> 一样的效果。</li>
</ul>
<h3 id="Text-object-selection"><a href="#Text-object-selection" class="headerlink" title="Text object selection"></a>Text object selection</h3><ul>
<li>daw 删除一个单词<ul>
<li>aw (a word)</li>
<li>2daw 或 d2aw 将忽略空格，删除两个单词</li>
<li>aW</li>
</ul>
</li>
<li>diw 删除一个单词<ul>
<li>iw (inner word)</li>
<li>2diw 或 d2iw 包含空格，即删除一个单词和空格</li>
<li>iW</li>
</ul>
</li>
<li>das 删除一个句子及后面的空白（没对中文句子进行支持）</li>
<li><del>dis 删除一个句子</del></li>
<li>dap 删除一个段落<ul>
<li>ap（a paragraph）</li>
</ul>
</li>
<li><del>dip 删除一个段落</del></li>
<li>da]、da[ 删除 [] 块内容，包含 []</li>
<li>di]、di[ 删除 [] 块内容，不含 []</li>
<li>da)、da(、dab</li>
<li>di)、di(、dib</li>
<li>da&gt;、da&lt;</li>
<li>di&gt;、di&lt;</li>
<li>dat 删除标签块，例如<aa></aa>，包含<aa></aa></li>
<li>dit</li>
<li>da}、da{、daB</li>
<li>di}、di{、diB</li>
<li>da”</li>
<li>di”</li>
<li>da’</li>
<li>di’</li>
<li>da`</li>
<li>di`</li>
</ul>
<h3 id="Operators"><a href="#Operators" class="headerlink" title="Operators"></a>Operators</h3><ul>
<li>c change</li>
<li>d delete</li>
<li>y 复制到寄存器</li>
<li>g~ 反转文本大小写）</li>
<li>gU 转换为大写</li>
<li>gu 转换为小写</li>
</ul>
<blockquote>
<p>Tips:<br>我们可以发现 Operator 操作符是不能单独使用的。</p>
<p>在 motions 或者组合指令前面加 n，可以达到执行 n 次的效果，例如：<code>2daw</code>，将删除两个单词，然后使用 <code>u</code> 可以一次性撤销。也可以在执行 <code>daw</code> 后使用 <code>.</code> 操作符，达到一样的效果，这需要执行 <code>u</code> 两次才能完全撤销。 </p>
<p>word 和 WORD 的区别在于，word 可以由：<code>spaces</code>,<code>tabs</code>,<code>&lt;EOL&gt;</code> 分隔，而 WORD 仅使用 spaces 作为分隔。相同之处在于：它们都是由字母、数字和下划线或其他非空字符序列组成。而在中文中的表现却有所不同：将连续的纯汉字视为一个“单词”。</p>
<p>文本对象选择器中的 i 和 a 的区别在于：i 选择没有 space 的文本对象，而 a 包含 space。</p>
<p>对中文句子不那么友好的情况，因此 <code>. </code> 英文句号加空格来判断一个句子的结尾，</p>
<p>我在感觉没啥用的部分加了删除线。</p>
</blockquote>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul>
<li><a href="https://vimhelp.org/">Vim: help.txt</a></li>
<li>《Vim 实用技巧 (第 2 版)》</li>
</ul>
]]></content>
      <categories>
        <category>信息技术</category>
      </categories>
      <tags>
        <tag>Vim</tag>
      </tags>
  </entry>
  <entry>
    <title>vim 多文件类型自动补全方案</title>
    <url>/vim-multiple-filetype-deoplete/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>多文件类型也可以叫混合文件类型(multiple filetype), 比如 HTML 里面写 CSS, JS 代码，虽然不提倡，但偶尔也有这个需求。</p>
<p>根据常识，我们知道，往往针对不同的文本类型，vim 或其插件，会出发不同的事件，例如特定的语法高亮、特定的语法检测、特定的自动补全方案等。<br>几乎每个 vim user 的 vimrc 中都会有如下配置：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">filetype plugin indent on</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<p>其中的 filetype on 表示：</p>
<blockquote>
<p>每次一个新的或者已经存在的文件被编辑时，Vim 会试图识别文件的类型，并设置’filetype’ 选项。同时，也触发 FileType 事件。该事件可以设置语法高亮，特定选项，等等。———— 出自 《vim 参考手册》，译者: Willis、tocer</p>
</blockquote>
<p>那么是否能直接通过修改文件的 filetype 值实现多文件类型的自动补全呢？ 答案是否定的，因为这将引起语法检测，语法高亮等一系列的变化，这是我们所不能接受的。</p>
<p>github 上已经有人大致实现了这个功能，主要通过 <code>deoplete.nvim</code> 和 <code>context_filetype.vim</code>两个插件。都是一个作者写的，前者提供一个可扩展的 vim 自动补全框架，后者支持前者实现多文件类型自动补全。</p>
<h2 id="实际操作"><a href="#实际操作" class="headerlink" title="实际操作"></a>实际操作</h2><p>修改 <code>.vimrc</code> 文件如下：<br>（下面提供的插件安装方式都是基于 <code>vim-plug</code> 的。不要再用 <code>vundle</code> 了，因为它目前不支持多线程，下载插件很慢。）</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="built_in">has</span>(<span class="string">&#x27;nvim&#x27;</span>)</span><br><span class="line">  Plug <span class="string">&#x27;Shougo/deoplete.nvim&#x27;</span>, &#123; <span class="string">&#x27;do&#x27;</span>: <span class="string">&#x27;:UpdateRemotePlugins&#x27;</span> &#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  Plug <span class="string">&#x27;Shougo/deoplete.nvim&#x27;</span></span><br><span class="line">  Plug <span class="string">&#x27;roxma/nvim-yarp&#x27;</span></span><br><span class="line">  Plug <span class="string">&#x27;roxma/vim-hug-neovim-rpc&#x27;</span></span><br><span class="line"><span class="keyword">endif</span></span><br><span class="line"></span><br><span class="line">Plug <span class="string">&#x27;Shougo/context_filetype.vim&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&quot; context_filetype.vim 插件的配置</span></span><br><span class="line"><span class="keyword">if</span> !exists(<span class="string">&#x27;g:context_filetype#same_filetypes&#x27;</span>)</span><br><span class="line">  <span class="keyword">let</span> <span class="variable">g:context_filetype</span>#filetypes = &#123;&#125;</span><br><span class="line"><span class="keyword">endif</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:context_filetype</span>#filetypes.svelte = [</span><br><span class="line">\ &#123;<span class="string">&#x27;filetype&#x27;</span> :<span class="string">&#x27;javascript&#x27;</span>, <span class="string">&#x27;start&#x27;</span>: <span class="string">&#x27;&lt;script&gt;&#x27;</span>, <span class="string">&#x27;end&#x27;</span>: <span class="string">&#x27;&lt;/script&gt;&#x27;</span>&#125;,</span><br><span class="line">\ &#123;<span class="string">&#x27;filetype&#x27;</span> :<span class="string">&#x27;css&#x27;</span>, <span class="string">&#x27;start&#x27;</span>: <span class="string">&#x27;&lt;style&gt;&#x27;</span>, <span class="string">&#x27;end&#x27;</span>: <span class="string">&#x27;&lt;/style&gt;&#x27;</span>&#125;,</span><br><span class="line">\ ]</span><br><span class="line"></span><br><span class="line"><span class="comment">&quot; deoplete.nvim 插件的配置</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:deoplete</span>#enable_at_startup = <span class="number">1</span></span><br><span class="line"><span class="keyword">autocmd</span> InsertLeave,CompleteDone * <span class="keyword">if</span> <span class="built_in">pumvisible</span>() == <span class="number">0</span> | <span class="keyword">pclose</span> | <span class="keyword">endif</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">call</span> deoplete#custom#var(<span class="string">&#x27;omni&#x27;</span>, <span class="string">&#x27;functions&#x27;</span>, &#123;</span><br><span class="line">\ <span class="string">&#x27;css&#x27;</span>: [<span class="string">&#x27;csscomplete#CompleteCSS&#x27;</span>],</span><br><span class="line">\ <span class="string">&#x27;javascript&#x27;</span>: [<span class="string">&#x27;javascriptcomplete#CompleteJS&#x27;</span>],</span><br><span class="line">\ <span class="string">&#x27;html&#x27;</span>: [<span class="string">&#x27;htmlcomplete#CompleteTags&#x27;</span>],</span><br><span class="line">\&#125;)</span><br><span class="line"><span class="keyword">call</span> deoplete#custom#var(<span class="string">&#x27;omni&#x27;</span>, <span class="string">&#x27;input_patterns&#x27;</span>, &#123;</span><br><span class="line">\ <span class="string">&#x27;javascript&#x27;</span>: <span class="string">&#x27;[^. *\t]\.\w*&#x27;</span>,</span><br><span class="line">\ &#125;)</span><br><span class="line"><span class="comment">&quot; 支持 &lt;tab&gt;</span></span><br><span class="line"><span class="keyword">inoremap</span> <span class="symbol">&lt;silent&gt;</span><span class="symbol">&lt;expr&gt;</span> <span class="symbol">&lt;TAB&gt;</span> <span class="built_in">pumvisible</span>() ? <span class="string">&quot;\&lt;C-n&gt;&quot;</span> :</span><br><span class="line">\ <span class="symbol">&lt;SID&gt;</span>check_back_space() ? <span class="string">&quot;\&lt;TAB&gt;&quot;</span> :</span><br><span class="line">\ deoplete#mappings#manual_complete()</span><br><span class="line"><span class="function"><span class="keyword">function</span>! <span class="title">s</span>:<span class="title">check_back_space</span><span class="params">()</span> <span class="title">abort</span> &quot;&#123;&#123;&#123;</span></span><br><span class="line">  <span class="keyword">let</span> <span class="keyword">col</span> = <span class="keyword">col</span>(<span class="string">&#x27;.&#x27;</span>) - <span class="number">1</span></span><br><span class="line">  <span class="keyword">return</span> !col || <span class="built_in">getline</span>(<span class="string">&#x27;.&#x27;</span>)[<span class="keyword">col</span> - <span class="number">1</span>]  =~ <span class="string">&#x27;\s&#x27;</span></span><br><span class="line"><span class="keyword">endfunction</span><span class="comment">&quot;&#125;&#125;&#125;</span></span><br></pre></td></tr></table></figure>
<p>执行 :PlugInstall</p>
<h2 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h2><p>作为一个 <code>vimscript</code> 还没入门的新手，看了大半天代码，了解如下：</p>
<p><code>context_filetype.vim</code> 插件，通过 <code>context_filetype#get()</code> 入口函数在光标处于<code>&lt;style&gt; &lt;/style&gt;</code>范围内时，返回如下格式的字典：</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">&#123;<span class="string">&#x27;range&#x27;</span>: [[<span class="number">9</span>, <span class="number">1</span>], [<span class="number">12</span>, <span class="number">4</span>]], <span class="string">&#x27;filetype&#x27;</span>: <span class="string">&#x27;css&#x27;</span>&#125;</span><br></pre></td></tr></table></figure>
<p>该字典含义为 {范围：[ 标签起始位置，标签结束位置 ]，文件类型 }</p>
<p>但是我没有明白 <code>deoplete.nvim</code> 是如何使用这个接口的。</p>
<p>作者让我看 <a href="https://github.com/Shougo/deoplete.nvim/blob/master/rplugin/python3/deoplete/context.py">context.py</a> 这段代码，我只能弱弱的回复一个”Thanks”。</p>
]]></content>
      <categories>
        <category>信息技术</category>
      </categories>
      <tags>
        <tag>vim</tag>
        <tag>multiple filetype</tag>
      </tags>
  </entry>
  <entry>
    <title>vim-gitgutter ——【一天一个 vim 插件】</title>
    <url>/vim-plugin-everday-1/</url>
    <content><![CDATA[<p><img data-src="https://images.xyang.xin/2020%2F06%2F28%2Fscreenshot.png?x-oss-process=style/title_800" alt="screenshot.png"><br>在此截图你可以看见：</p>
<ul>
<li>183-184 行是新建的；</li>
<li>186-187 行有所变动；</li>
<li>在底部的预览区中显示改动情况（<leader>hp）。<br>(<a href="https://github.com/airblade/vim-gitgutter">出处</a>)<br><a href="https://github.com/airblade/vim-gitgutter">airblade/vim-gitgutter</a> </li>
</ul>
<p>在 vim 标志栏（sign column，行号左边的一列，通常为隐藏状态）中显示 git diff（git 差异）</p>
<span id="more"></span>

<p>这个系列主要以记住各类有用的 vim 插件的功能与使用方法为目的。</p>
<h2 id="安装配置"><a href="#安装配置" class="headerlink" title="安装配置"></a>安装配置</h2><p>安装插件的方法，一般分为常规安装与插件管理器安装。常规安装将插件整个放入目录：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">~/.vim/pack/vendor/start</span><br></pre></td></tr></table></figure>
<p>而插件管理器安装有相似的语法，却各不相同。插件管理器安装有一定的性能亏损，但是如果有大量插件存在的情况下，没有插件管理器，将难以管理。</p>
<p>系列目前选择 <a href="https://github.com/junegunn/vim-plug">junegunn/vim-plug</a> 插件管理器作为插件的安装方式。全程使用<code>xterm-256color</code>，没有使用<code>gui</code>。</p>
<p>在 <code>.vimrc</code> 中写入并保存：</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="built_in">empty</span>(<span class="built_in">glob</span>(<span class="string">&#x27;~/.vim/autoload/plug.vim&#x27;</span>))</span><br><span class="line">    <span class="keyword">silent</span> !curl -fLo ~/.<span class="keyword">vim</span>/autoload/plug.<span class="keyword">vim</span> --create-dirs</span><br><span class="line">                \ http<span class="variable">s:</span>//raw.githubusercontent.<span class="keyword">com</span>/junegunn/<span class="keyword">vim</span>-plug/master/plug.<span class="keyword">vim</span></span><br><span class="line">    <span class="keyword">au</span> VimEnter * PlugInstall --<span class="keyword">sync</span> | <span class="keyword">source</span> $MYVIMRC</span><br><span class="line"><span class="keyword">endif</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">call</span> plug#begin(<span class="string">&#x27;~/.vim/plugged&#x27;</span>)</span><br><span class="line">Plug <span class="string">&#x27;airblade/vim-gitgutter&#x27;</span></span><br><span class="line"><span class="keyword">call</span> plug#end()</span><br></pre></td></tr></table></figure>
<p>重新用 Vim 打开一个文件，执行命令：<code>:PlugInstall</code>，好了 <code>vim-plug</code> 插件管理器 和 <code>vim-gitgutter</code> 插件都安装好了。</p>
<p>标志栏背景颜色显示很丑的话，我的默认显示灰色，添加如下设置以改善：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">highlight SignColumn ctermbg=NONE</span><br></pre></td></tr></table></figure>

<p>当修改文件后，标志栏会自动刷新，而刷新的延迟决定于vim的updatetime，默认的是4000ms，建议修改如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">updatetime=100</span><br></pre></td></tr></table></figure>
<h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><p>通过 <code>[c</code> 和 <code>]c</code> 在有所变动的区块间跳转。<br><leader>hp，显示预览，hunk preview<br><leader>hs，暂存代码块，hunk stage<br><leader>hu，撤销更改，hunk undo</p>
<p>以上是默认的映射，可以自行修改如下：</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="keyword">nmap</span> ]h <span class="symbol">&lt;Plug&gt;</span>(GitGutterNextHunk)</span><br><span class="line"><span class="keyword">nmap</span> [h <span class="symbol">&lt;Plug&gt;</span>(GitGutterPrevHunk)</span><br><span class="line"><span class="keyword">nmap</span> <span class="symbol">&lt;leader&gt;</span>hp <span class="symbol">&lt;Plug&gt;</span>(GitGutterPreviewHunk)</span><br><span class="line"><span class="keyword">nmap</span> <span class="symbol">&lt;leader&gt;</span>hs <span class="symbol">&lt;Plug&gt;</span>(GitGutterStageHunk)</span><br><span class="line"><span class="keyword">nmap</span> <span class="symbol">&lt;leader&gt;</span>hu <span class="symbol">&lt;Plug&gt;</span>(GitGutterUndoHunk)</span><br></pre></td></tr></table></figure>

<p>You can explicitly turn vim-gitgutter off and on (defaults to on):</p>
<p>如果在某个git项目下，不想看见这个标志栏的提示，可以使用下面的命令：</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">:GitGutterDisable</span><br><span class="line">:GitGutterEnable</span><br><span class="line"></span><br><span class="line">:GitGutterBufferDisable</span><br><span class="line">:GitGutterBufferEnable</span><br></pre></td></tr></table></figure>
<p>绑定快捷键，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nmap &lt;leader&gt;hd :GitGutterDisable&lt;CR&gt;</span><br><span class="line">nmap &lt;leader&gt;he :GitGutterEnable&lt;CR&gt;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>信息技术</category>
      </categories>
      <tags>
        <tag>vim</tag>
        <tag>一天一个 vim 插件</tag>
      </tags>
  </entry>
  <entry>
    <title>vim-fugitive ——【一天一个 vim 插件】</title>
    <url>/vim-plugin-everday-2/</url>
    <content><![CDATA[<p>作为一个 10k+ star 的 vim 插件，<a href="https://github.com/tpope/vim-fugitive">tpope/vim-fugitive</a> 自称为 Git 的第一 Vim 插件并不为过。Fugitive 让你在当前 buffer 缓冲区通过<code>:Git</code>或<code>:G</code>，可以直接使用 git 命令。可以看作是<code>!git XX</code> 命令的改进和优化，除了使用 silent，静默模式外，你不会看到 “Press ENTER or type command to continue”，还对一些命令进行了优化。</p>
<span id="more"></span>

<h2 id="温故"><a href="#温故" class="headerlink" title="温故"></a>温故</h2><p>回顾一下上一个插件 vim-gitgutter 的使用方法：</p>
<ul>
<li><code>[c</code> 和 <code>]c</code> 在有所变动的区块间跳转。</li>
<li><leader>hp，显示预览，hunk preview</li>
<li><leader>hs，暂存代码块，hunk stage</li>
<li><leader>hu，撤销更改，hunk undo</li>
<li><leader>hd，禁用 gitgutter</li>
<li><leader>he，启用 gitgutter</li>
</ul>
<h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><ul>
<li>所有命令都以<code>:G</code>或<code>:Git</code>打头，两种写法等价。</li>
<li><code>:G -p &#123;args&#125;</code><ul>
<li>运行任意 git 命令都可以加上，-p，这样将捕获输出到一个临时文件，并且对临时文件执行<code>:split</code>水平分割。如果使用<code>:0G -p &#123;args&#125;</code>，将用<code>:edit</code>代替。通常用于 diff 和 log 这个指令。</li>
<li>例：<code>:G -p diff</code>,<code>:G --paginate diff</code></li>
</ul>
</li>
<li><code>G</code><ul>
<li>不带参数，会打开一个类似于 git-status 的简要窗口，在窗口中，使用 <code>g?</code> 将打开 fugitive-maps 快捷键映射帮助。</li>
</ul>
</li>
<li><code>G push</code><ul>
<li>执行 <code>git push</code></li>
</ul>
</li>
<li><code>GBrowse</code></li>
</ul>
<hr>
<p>待续：<br>由于我的很多 git 知识还不够完善，后面补充了再续写。<br>更多内容参见<code>:help fugitive</code></p>
]]></content>
      <categories>
        <category>信息技术</category>
      </categories>
      <tags>
        <tag>vim</tag>
        <tag>一天一个 vim 插件</tag>
      </tags>
  </entry>
  <entry>
    <title>React-Vim 开发环境</title>
    <url>/vim-react/</url>
    <content><![CDATA[<h2 id="实现功能"><a href="#实现功能" class="headerlink" title="实现功能"></a>实现功能</h2><ol>
<li>react 代码高亮、自动补全。</li>
<li>执行<code>./node_modules/.bin/eslint --fix src/App.js</code> 即可对App.js 进行代码错误检测和格式化。</li>
<li>变更代码自动对代码进行格式化。<span id="more"></span>

</li>
</ol>
<h2 id="换源"><a href="#换源" class="headerlink" title="换源"></a>换源</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm config set registry=http://registry.npmjs.org</span><br><span class="line">npm config set disturl https://npm.taobao.org/dist</span><br></pre></td></tr></table></figure>

<h2 id="插件安装"><a href="#插件安装" class="headerlink" title="插件安装"></a>插件安装</h2><p>建议使用 vim-plug 包管理器（<a href="https://blog.xyang.xin/shell-java/#sublime">安装方式</a>）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vim ~./vimrc</span><br></pre></td></tr></table></figure>

<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span> nu!               <span class="comment">&quot; 显示行号</span></span><br><span class="line"><span class="keyword">set</span> hls               <span class="comment">&quot; 寻找时匹配高亮显示</span></span><br><span class="line"><span class="keyword">syntax</span> <span class="keyword">on</span>             <span class="comment">&quot; 语法高亮</span></span><br><span class="line"><span class="keyword">set</span> background=dark</span><br><span class="line"><span class="keyword">colorscheme</span> solarized</span><br><span class="line"><span class="keyword">set</span> <span class="built_in">shiftwidth</span>=<span class="number">2</span>      <span class="comment">&quot; 设置格式化时代码缩进为2个空格</span></span><br><span class="line"><span class="keyword">set</span> tabstop=<span class="number">2</span>         <span class="comment">&quot; tab键缩进为4格子</span></span><br><span class="line"><span class="keyword">set</span> expandtab         <span class="comment">&quot; tab键转换为空格</span></span><br><span class="line"><span class="keyword">set</span> incsearch         <span class="comment">&quot; 很聪明的查找,输入一个字符马上自动匹配,而不是输入完再查找</span></span><br><span class="line"><span class="keyword">set</span> ignorecase        <span class="comment">&quot; 搜索时大小写不敏感</span></span><br><span class="line"><span class="keyword">set</span> wildmenu          <span class="comment">&quot; vim 自身命令行模式智能补全</span></span><br><span class="line"><span class="keyword">set</span> <span class="keyword">ts</span>=<span class="number">4</span>              <span class="comment">&quot; 设置 tab 键为四个空格</span></span><br><span class="line"><span class="keyword">set</span> <span class="built_in">cindent</span>           <span class="comment">&quot; 设置自动缩近</span></span><br><span class="line"><span class="keyword">set</span> <span class="built_in">shiftwidth</span>=<span class="number">4</span>      <span class="comment">&quot; 设置每一级缩进长度为4</span></span><br><span class="line"><span class="keyword">set</span> nocompatible      <span class="comment">&quot; 自动补全</span></span><br><span class="line"><span class="keyword">set</span> backspace=<span class="number">2</span>       <span class="comment">&quot; 解决不能删除的问题</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">call</span> plug#begin(<span class="string">&#x27;~/.vim/plugged&#x27;</span>)</span><br><span class="line"><span class="comment">&quot; react 插件</span></span><br><span class="line">Plug <span class="string">&#x27;pangloss/vim-javascript&#x27;</span></span><br><span class="line">Plug <span class="string">&#x27;mxw/vim-jsx&#x27;</span></span><br><span class="line">Plug <span class="string">&#x27;mattn/emmet-vim&#x27;</span></span><br><span class="line">Plug <span class="string">&#x27;w0rp/ale&#x27;</span></span><br><span class="line">Plug <span class="string">&#x27;skywind3000/asyncrun.vim&#x27;</span></span><br><span class="line"><span class="keyword">call</span> plug#end()</span><br><span class="line"></span><br><span class="line"> <span class="comment">&quot; emmet-vim</span></span><br><span class="line"> <span class="keyword">let</span> <span class="variable">g:user_emmet_leader_key</span>=<span class="string">&#x27;&lt;C-e&gt;&#x27;</span></span><br><span class="line"> <span class="keyword">let</span> <span class="variable">g:user_emmet_jsx</span> = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&quot; react 自动格式化</span></span><br><span class="line"><span class="keyword">autocmd</span> BufWritePost *.js AsyncRun -post=<span class="keyword">checktime</span> ./node_modules/.bin/eslint --<span class="keyword">fix</span> %</span><br></pre></td></tr></table></figure>

<h2 id="依赖安装"><a href="#依赖安装" class="headerlink" title="依赖安装"></a>依赖安装</h2><p>以 create-react-app 为例</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npx create-react-app create-react-app</span><br><span class="line">cd create-react-app</span><br><span class="line">./node_modules/.bin/eslint --init</span><br><span class="line"><span class="meta">#</span><span class="bash"> Use a popular style guide ——&gt; Airbnb ——&gt; y ——&gt; JavaScript ——&gt; n</span></span><br><span class="line">npm install --save--dev eslint-config-airbnb</span><br><span class="line">或：</span><br><span class="line">yarn add --dev eslint-config-airbnb</span><br></pre></td></tr></table></figure>

<h2 id="修改-eslintrc-js-配置"><a href="#修改-eslintrc-js-配置" class="headerlink" title="修改 .eslintrc.js 配置"></a>修改 .eslintrc.js 配置</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vim .eslintrc.js</span><br></pre></td></tr></table></figure>

<p>覆盖原文本如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    <span class="string">&quot;root&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="string">&quot;parserOptions&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;parser&quot;</span>: <span class="string">&#x27;babel-eslint&#x27;</span>,</span><br><span class="line">         <span class="string">&quot;sourceType&quot;</span>: <span class="string">&#x27;module&#x27;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">&quot;extends&quot;</span>: [</span><br><span class="line">        <span class="string">&quot;eslint:recommended&quot;</span>,</span><br><span class="line">        <span class="string">&quot;plugin:react/recommended&quot;</span>,</span><br><span class="line">        <span class="string">&quot;eslint-config-airbnb&quot;</span>,</span><br><span class="line">    ],</span><br><span class="line">    <span class="string">&quot;plugins&quot;</span>: [</span><br><span class="line">        <span class="string">&quot;react&quot;</span>,</span><br><span class="line">    ],</span><br><span class="line">    <span class="string">&quot;rules&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;react/jsx-filename-extension&quot;</span>: [<span class="number">1</span>, &#123; <span class="string">&quot;extensions&quot;</span>: [<span class="string">&quot;.js&quot;</span>, <span class="string">&quot;.jsx&quot;</span>] &#125;],</span><br><span class="line">        <span class="string">&quot;react/prefer-stateless-function&quot;</span>: <span class="string">&quot;off&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h2><p><a href="https://drivy.engineering/setting-up-vim-for-react/">Setting up Vim for React development | Drivy Engineering</a><br><a href="https://blog.xcatliu.com/2017/08/25/eslint-config-alloy/">我花了两个月时间，定制出了心目中「完美」的 ESLint 规则，我用四个空格缩进 - 流浪小猫的博客</a></p>
]]></content>
      <categories>
        <category>信息技术</category>
      </categories>
      <tags>
        <tag>vim</tag>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title>Hubot 官方文档（译）</title>
    <url>/hubot-document/</url>
    <content><![CDATA[<h1 id="Hubot-官方文档"><a href="#Hubot-官方文档" class="headerlink" title="Hubot 官方文档"></a>Hubot 官方文档</h1><p><a href="https://hubot.github.com/docs/">原文链接🔗</a><br><img data-src="https://images.xyang.xin/2021%2F09%2F01%2Fhubot-avatar.png" alt="hubot-avatar.png"></p>
<h2 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h2><h3 id="Hubot-起步"><a href="#Hubot-起步" class="headerlink" title="Hubot 起步"></a>Hubot 起步</h3><p>您需要<a href="https://docs.npmjs.com/getting-started/installing-node">node.js和npm</a>。安装它们后，我们就可以安装 hubot 生成器：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> npm install -g yo generator-hubot</span></span><br></pre></td></tr></table></figure>

<p>这条命令将给我们带来hubot <a href="http://yeoman.io/">yeoman</a>生成器。现在我们就可以先创建一个的文件夹，然后在里面生成一个新的hubot实例。例如，如果我们想制造一个叫 myhubot的机器人：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> mkdir myhubot</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> myhubot</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> yo hubot</span></span><br></pre></td></tr></table></figure>
<span id="more"></span>
<p>执行命令后，您将被问到一些关于谁在创建机器人和您将使用哪个适配器的问题。适配器是hubot与不同聊天提供商集成的方式。</p>
<p>如果您希望在没有交互提示配置的情况下自动化您的 hubot 构建，您可以将以下选项添加到 <code>yo hubot</code> 命令中：</p>
<table>
<thead>
<tr>
<th>Option</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td>--owner=”Bot Wrangler <a href="mailto:&#98;&#x77;&#64;&#x65;&#120;&#x61;&#109;&#x70;&#108;&#101;&#x2e;&#99;&#111;&#109;">&#98;&#x77;&#64;&#x65;&#120;&#x61;&#109;&#x70;&#108;&#101;&#x2e;&#99;&#111;&#109;</a>“</td>
<td>Bot owner, e.g. “Bot Wrangler <a href="mailto:bw@example.com">bw@example.com</a>”</td>
</tr>
<tr>
<td>--name=”Hubot”</td>
<td>bot 名, e.g. “Hubot”</td>
</tr>
<tr>
<td>--description=”Delightfully aware robutt”</td>
<td>bot 描述, e.g. “Delightfully aware robutt”</td>
</tr>
<tr>
<td>--adapter=campfire</td>
<td>bot 适配器, e.g. “campfire”</td>
</tr>
<tr>
<td>--defaults</td>
<td>所有声明都设置为默认值且无需提示</td>
</tr>
</tbody></table>
<p>您现在就拥有了自己的一个多功能的 hubot！为方便起见，有一个<code>bin/hubot</code>命令，用于处理安装 npm 依赖项、加载脚本，然后启动您的 hubot。</p>
<p>Hubot 需要 Redis 来持久化数据，因此在您可以在自己的计算机上启动 hubot 之前，您应该在本地主机上安装 Redis。如果只是想在没有 Redis 的情况下测试 Hubot，那么您可以从 <code>external-scripts.json</code> 中删除 <code>hubot-redis-brain</code>。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> bin/hubot</span></span><br><span class="line"><span class="meta">Hubot&gt;</span></span><br></pre></td></tr></table></figure>

<p>这将使用 <a href="https://hubot.github.com/docs/adapters/shell/">shell 适配器</a>启动 hubot，这对开发非常有用。记下 <code>Hubot&gt;</code>，这是您的 hubot 将用命令响应的名称。例如，列出可用命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> bin/hubot</span></span><br><span class="line"><span class="meta">hubot&gt;</span><span class="bash"> hubot <span class="built_in">help</span></span></span><br><span class="line">hubot adapter - Reply with the adapter</span><br><span class="line">hubot animate me &lt;query&gt; - The same thing as `image me`, except adds a few parameters to try to return an animated GIF instead.</span><br><span class="line">hubot echo &lt;text&gt; - Reply back with &lt;text&gt;</span><br><span class="line">hubot help - Displays all of the help commands that hubot knows about.</span><br><span class="line">hubot help &lt;query&gt; - Displays all help commands that match &lt;query&gt;.</span><br><span class="line">hubot image me &lt;query&gt; - The Original. Queries Google Images for &lt;query&gt; and returns a random top result.</span><br><span class="line">hubot map me &lt;query&gt; - Returns a map view of the area returned by `query`.</span><br><span class="line">hubot mustache me &lt;query&gt; - Searches Google Images for the specified query and mustaches it.</span><br><span class="line">hubot mustache me &lt;url&gt; - Adds a mustache to the specified URL.</span><br><span class="line">hubot ping - Reply with pong</span><br><span class="line">hubot pronounce &lt;phrase&gt; in &lt;language&gt; - Provides pronunciation of &lt;phrase&gt; (&lt;language&gt; is optional)</span><br><span class="line">hubot pug bomb N - get N pugs</span><br><span class="line">hubot pug me - Receive a pug</span><br><span class="line">hubot the rules - Make sure hubot still knows the rules.</span><br><span class="line">hubot time - Reply with current time</span><br><span class="line">hubot translate me &lt;phrase&gt; - Searches for a translation for the &lt;phrase&gt; and then prints that bad boy out.</span><br><span class="line">hubot translate me from &lt;source&gt; into &lt;target&gt; &lt;phrase&gt; - Translates &lt;phrase&gt; from &lt;source&gt; into &lt;target&gt;. Both &lt;source&gt; and &lt;target&gt; are optional</span><br><span class="line">hubot youtube me &lt;query&gt; - Searches YouTube for the query and returns the video embed link.</span><br><span class="line">ship it - Display a motivation squirrel</span><br></pre></td></tr></table></figure>

<p>您基本上都会想要改变您的 hubot 的名字来添加角色。 bin/hubot 需要一个 <code>--name</code>：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">%</span><span class="bash"> bin/hubot --name myhubot</span></span><br><span class="line"><span class="meta">myhubot&gt;</span></span><br></pre></td></tr></table></figure>
<p>您的 hubot 现在将响应 <code>myhubot</code> 。这是不区分大小写的，可以以 <code>@</code> 为前缀或以 <code>:</code>为后缀。这些是等效的：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">MYHUBOT help</span><br><span class="line">myhubot help</span><br><span class="line">@myhubot help</span><br><span class="line">myhubot: help</span><br></pre></td></tr></table></figure>

<h3 id="脚本"><a href="#脚本" class="headerlink" title="脚本"></a>脚本</h3><p>Hubot 的力量来自于脚本。社区编写和维护着几百个脚本。通过使用 <code>hubot-scripts &lt;your-search-term&gt;</code> 查找 <a href="https://www.npmjs.com/browse/keyword/hubot-scripts">NPM registry</a> 找到它们。例如：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> npm search hubot-scripts github</span></span><br><span class="line">NAME                  DESCRIPTION</span><br><span class="line">hubot-deployer        Giving Hubot the ability to deploy GitHub repos to PaaS providers hubot hubot-scripts hubot-gith</span><br><span class="line">hubot-gh-release-pr   A hubot script to create GitHub&#x27;s PR for release</span><br><span class="line">hubot-github          Giving Hubot the ability to be a vital member of your github organization</span><br><span class="line">…</span><br></pre></td></tr></table></figure>
<p>要使用 NPM 包中的脚本：</p>
<ol>
<li>运行<code>npm install --save &lt;package-name&gt;</code>去添加该包作为依赖并安装它。</li>
<li>添加该包到<code>external-scripts.json</code>。</li>
<li>运行<code>npm home &lt;package-name&gt;</code>以打开脚本主页的浏览器窗口，您可以在其中找到有关配置和安装脚本的更多信息。</li>
</ol>
<p>您也可以将您自己的脚本放在<code>scripts/</code>目录下。放在这里的所有脚本都将被 hubot 自动加载和使用。阅读有关通过<a href="https://hubot.github.com/docs/scripting/">编写自己的脚本</a>自定义 hubot 的更多信息。</p>
<h3 id="适配器"><a href="#适配器" class="headerlink" title="适配器"></a>适配器</h3><p>Hubot 使用适配器模式来支持多个聊天后端。这是<a href="https://hubot.github.com/docs/adapters/">可用适配器的列表</a>，以及如何配置它们的详细信息。</p>
<h3 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h3><p>您可以将 hubot 部署到 Heroku，这是官方支持的方法。此外，您还可以将 hubot 部署到类似 UNIX 的系统或 Windows 中。请注意，部署到 Windows 的支持尚未得到官方支持。</p>
<ul>
<li><a href="https://hubot.github.com/docs/deploying/heroku/">部署 hubot 到 Heroku</a></li>
<li><a href="https://hubot.github.com/docs/deploying/unix/">部署 hubot 到 UNIX</a></li>
<li><a href="https://hubot.github.com/docs/deploying/windows/">部署 hubot 到 Windows</a></li>
</ul>
<h3 id="模式"><a href="#模式" class="headerlink" title="模式"></a>模式</h3><p>使用自定义脚本，您可以快速自定义 hubot，使他（她）成为最具生命力的机器人。当您教您的 hubot 新的技能，阅读<a href="https://hubot.github.com/docs/patterns/">docs/patterns.md</a> 里的一些漂亮的技巧，可能会派上用场。</p>
<h2 id="脚本-1"><a href="#脚本-1" class="headerlink" title="脚本"></a>脚本</h2><p>开箱即用的 hubot 不会做太多， 但它是一个可扩展的，可编脚本的机器人朋友。有<a href="https://hubot.github.com/docs/#scripts">数以百计的脚本由社区编写和维护</a>，并且自己写起来也很容易。您可以在hubot的<code>scripts</code>目录中创建自定义脚本，或<a href="https://hubot.github.com/docs/scripting/#creating-a-script-package">创建一个脚本包</a>，以便与社区共享！</p>
<h3 id="脚本剖析"><a href="#脚本剖析" class="headerlink" title="脚本剖析"></a>脚本剖析</h3><p>当您创建 hubot 时，生成器还创建了<code>scripts</code>目录。如果您看了一下那里，您会看到一些脚本的例子。脚本要成为脚本，它需要：</p>
<ul>
<li>在 hubot 脚本加载的目录里（默认为<code>src/scripts</code>和<code>scripts</code>）</li>
<li>是一个<code>.coffee</code>或者<code>.js</code>文件</li>
<li>导出一个函数</li>
</ul>
<p>导出一个函数，我们的意思是：</p>
<figure class="highlight coffee"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.<span class="built_in">exports</span> = <span class="function"><span class="params">(robot)</span> -&gt;</span></span><br><span class="line">  <span class="comment"># your code here</span></span><br></pre></td></tr></table></figure>

<p>机器人参数是您的机器人朋友的实例。在这一点上，我们可以开始编写一些很棒的脚本。</p>
<h3 id="聆听和响应"><a href="#聆听和响应" class="headerlink" title="聆听和响应"></a>聆听和响应</h3><p>由于这是一个聊天机器人，最常见的交互是基于消息。Hubot 可以<code>hear</code>在房间里说的消息，或直接<code>response</code>专门传达给它的消息。这两种方法都以一个正则表达式和一个回调函数作为参数。例如：</p>
<figure class="highlight coffee"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.<span class="built_in">exports</span> = <span class="function"><span class="params">(robot)</span> -&gt;</span></span><br><span class="line">  robot.hear <span class="regexp">/badger/i</span>, <span class="function"><span class="params">(res)</span> -&gt;</span></span><br><span class="line">    <span class="comment"># your code here</span></span><br><span class="line"></span><br><span class="line">  robot.respond <span class="regexp">/open the pod bay doors/i</span>, <span class="function"><span class="params">(res)</span> -&gt;</span></span><br><span class="line">    <span class="comment"># your code here</span></span><br></pre></td></tr></table></figure>

<p>每当一个消息的文本匹配时，<code>robot.hear /badger/</code>的回调就会被调用。例如：</p>
<ul>
<li>Stop badgering the witness</li>
<li>badger me</li>
<li>what exactly is a badger anyways</li>
</ul>
<p><code>robot.respond /open the pod bay doors/i</code> 的回调仅当消息紧跟着机器人的名字或者别名被调用。如果机器人的名称是 HAL，别名是 /，则此回调将被以下触发：</p>
<ul>
<li>hal open the pod bay doors</li>
<li>HAL: open the pod bay doors</li>
<li>@HAL open the pod bay doors</li>
<li>/open the pod bay doors</li>
</ul>
<p>它不会被调用：</p>
<ul>
<li>HAL: please open the pod bay doors<ul>
<li>因为它的响应与机器人名称后紧接着的文本绑定</li>
</ul>
</li>
<li>has anyone ever mentioned how lovely you are when you open the pod bay doors?<ul>
<li>因为它确少机器人的名字</li>
</ul>
</li>
</ul>
<h3 id="发送和回复"><a href="#发送和回复" class="headerlink" title="发送和回复"></a>发送和回复</h3><p><code>res</code>参数是<code>Response</code>的实例（在历史上，这个参数是 <code>msg</code>，您可能会看到其他脚本使用它）。有了它，您可以将消息<code>send</code>回 <code>res</code>来的房间，<code>emote</code>一个消息到一个房间（如果给定的适配器支持它），或<code>reply</code>发送消息的人。例如：</p>
<figure class="highlight coffee"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.<span class="built_in">exports</span> = <span class="function"><span class="params">(robot)</span> -&gt;</span></span><br><span class="line">  robot.hear <span class="regexp">/badger/i</span>, <span class="function"><span class="params">(res)</span> -&gt;</span></span><br><span class="line">    res.send <span class="string">&quot;Badgers? BADGERS? WE DON&#x27;T NEED NO STINKIN BADGERS&quot;</span></span><br><span class="line"></span><br><span class="line">  robot.respond <span class="regexp">/open the pod bay doors/i</span>, <span class="function"><span class="params">(res)</span> -&gt;</span></span><br><span class="line">    res.reply <span class="string">&quot;I&#x27;m afraid I can&#x27;t let you do that.&quot;</span></span><br><span class="line"></span><br><span class="line">  robot.hear <span class="regexp">/I like pie/i</span>, <span class="function"><span class="params">(res)</span> -&gt;</span></span><br><span class="line">    res.emote <span class="string">&quot;makes a freshly baked pie&quot;</span></span><br></pre></td></tr></table></figure>

<p><code>robot.hear /badgers/</code>的回调发送指定的消息，而不管向谁说： “Badgers? BADGERS? WE DON’T NEED NO STINKIN BADGERS”。</p>
<p>如果一个用户 Dave 说 “HAL: open the pod bay doors”， <code>robot.respond /open the pod bay doors/i</code> 的回调发送一个消息<code>Dave: I’m afraid I can’t let you do that.</code></p>
<h3 id="给房间或用户的消息"><a href="#给房间或用户的消息" class="headerlink" title="给房间或用户的消息"></a>给房间或用户的消息</h3><p>消息可以使用 <code>messageRoom</code> 功能发送给指定的房间或用户。</p>
<figure class="highlight coffee"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.<span class="built_in">exports</span> = <span class="function"><span class="params">(robot)</span> -&gt;</span></span><br><span class="line"></span><br><span class="line">  robot.hear <span class="regexp">/green eggs/i</span>, <span class="function"><span class="params">(res)</span> -&gt;</span></span><br><span class="line">    room = <span class="string">&quot;mytestroom&quot;</span></span><br><span class="line">    robot.messageRoom room, <span class="string">&quot;I do not like green eggs and ham.  I do not like them sam-I-am.&quot;</span></span><br></pre></td></tr></table></figure>

<p>如果需要，可以明确指定用户名，或使用响应对象，可以向原始发件人发送私人消息。</p>
<figure class="highlight coffee"><table><tr><td class="code"><pre><span class="line">robot.respond <span class="regexp">/I don&#x27;t like Sam-I-am/i</span>, <span class="function"><span class="params">(res)</span> -&gt;</span></span><br><span class="line">  room =  <span class="string">&#x27;joemanager&#x27;</span></span><br><span class="line">  robot.messageRoom room, <span class="string">&quot;Someone does not like Dr. Seus&quot;</span></span><br><span class="line">  res.reply  <span class="string">&quot;That Sam-I-am\nThat Sam-I-am\nI do not like\nthat Sam-I-am&quot;</span></span><br><span class="line"></span><br><span class="line">robot.hear <span class="regexp">/Sam-I-am/i</span>, <span class="function"><span class="params">(res)</span> -&gt;</span></span><br><span class="line">  room =  res.envelope.user.name</span><br><span class="line">  robot.messageRoom room, <span class="string">&quot;That Sam-I-am\nThat Sam-I-am\nI do not like\nthat Sam-I-am&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="捕获数据"><a href="#捕获数据" class="headerlink" title="捕获数据"></a>捕获数据</h3><p>到目前为止，我们的脚本已经有静态响应，这虽然有趣，在功能方面却很薄弱。<code>res.match</code>的结果是将传入的消息与正则表达进行匹配。这只是一个 <a href="http://www.w3schools.com/jsref/jsref_match.asp">JavaScript thing</a>， 它最终是一个数组， 索引0是与表达式匹配的全文。如果包括捕获组，这些组将填充 <code>res.match</code>。例如，如果我们更新脚本：</p>
<figure class="highlight coffee"><table><tr><td class="code"><pre><span class="line">robot.respond <span class="regexp">/open the (.*) doors/i</span>, <span class="function"><span class="params">(res)</span> -&gt;</span></span><br><span class="line">    <span class="comment"># your code here</span></span><br></pre></td></tr></table></figure>
<p>如果Dave说“HAL: open the pod bay doors”，<code>res.match[0]</code>就成了<code>open the pod bay doors</code>，<code>res.match[1]</code>则为<code>pod bay</code>。现在我们可以开始做更多动态的东西了：</p>
<figure class="highlight coffee"><table><tr><td class="code"><pre><span class="line">robot.respond <span class="regexp">/open the (.*) doors/i</span>, <span class="function"><span class="params">(res)</span> -&gt;</span></span><br><span class="line">  doorType = res.match[<span class="number">1</span>]</span><br><span class="line">  <span class="keyword">if</span> doorType <span class="keyword">is</span> <span class="string">&quot;pod bay&quot;</span></span><br><span class="line">    res.reply <span class="string">&quot;I&#x27;m afraid I can&#x27;t let you do that.&quot;</span></span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    res.reply <span class="string">&quot;Opening <span class="subst">#&#123;doorType&#125;</span> doors&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="调用-HTTP"><a href="#调用-HTTP" class="headerlink" title="调用 HTTP"></a>调用 HTTP</h3><p>Hubot 可以为您进行 HTTP 请求，以集成和整合第三方 API 。这能够通过一个在<code>robot.http</code>的<a href="https://github.com/technoweenie/node-scoped-http-client">node-scoped-http-client</a>实例进行。最简单的例子如：</p>
<figure class="highlight coffee"><table><tr><td class="code"><pre><span class="line">robot.http(<span class="string">&quot;https://midnight-train&quot;</span>)</span><br><span class="line">    .get() (err, res, body) -&gt;</span><br><span class="line">      <span class="comment"># your code here</span></span><br></pre></td></tr></table></figure>

<p>post 请求例如：</p>
<figure class="highlight coffee"><table><tr><td class="code"><pre><span class="line">data = <span class="built_in">JSON</span>.stringify(&#123;</span><br><span class="line">  foo: <span class="string">&#x27;bar&#x27;</span></span><br><span class="line">&#125;)</span><br><span class="line">robot.http(<span class="string">&quot;https://midnight-train&quot;</span>)</span><br><span class="line">  .header(<span class="string">&#x27;Content-Type&#x27;</span>, <span class="string">&#x27;application/json&#x27;</span>)</span><br><span class="line">  .post(data) (err, res, body) -&gt;</span><br><span class="line">    <span class="comment"># your code here</span></span><br></pre></td></tr></table></figure>
<p>如果遇到错误，<code>err</code> 就是您所遇到的错误。您通常会想要检查这一点，并相应地处理：</p>
<figure class="highlight coffee"><table><tr><td class="code"><pre><span class="line">robot.http(<span class="string">&quot;https://midnight-train&quot;</span>)</span><br><span class="line">  .get() (err, res, body) -&gt;</span><br><span class="line">    <span class="keyword">if</span> err</span><br><span class="line">      res.send <span class="string">&quot;Encountered an error :( <span class="subst">#&#123;err&#125;</span>&quot;</span></span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    <span class="comment"># your code here, knowing it was successful</span></span><br></pre></td></tr></table></figure>
<p><code>res</code>是node的<a href="http://nodejs.org/api/http.html#http_class_http_serverresponse">http.ServerResponse</a>的一个实例。使用node-scoped-http-client的时候大多数方法不是特别关键， 但是有意思的是<code>statusCode</code>和<code>getHeader</code>。使用<code>statusCode</code>去检查HTTP的状态码，当不是200状态码的时候意味着糟糕的事情发生了。使用<code>getHeader</code>查看header，例如去检查服务限流（<code>X-RateLimit-Limit:1 //每秒1次请求</code>）：</p>
<figure class="highlight coffee"><table><tr><td class="code"><pre><span class="line">robot.http(<span class="string">&quot;https://midnight-train&quot;</span>)</span><br><span class="line">  .get() (err, res, body) -&gt;</span><br><span class="line">    <span class="comment"># pretend there&#x27;s error checking code here</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> res.statusCode <span class="keyword">isnt</span> <span class="number">200</span></span><br><span class="line">      res.send <span class="string">&quot;Request didn&#x27;t come back HTTP 200 :(&quot;</span></span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    rateLimitRemaining = <span class="built_in">parseInt</span> res.getHeader(<span class="string">&#x27;X-RateLimit-Limit&#x27;</span>) <span class="keyword">if</span> res.getHeader(<span class="string">&#x27;X-RateLimit-Limit&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> rateLimitRemaining <span class="keyword">and</span> rateLimitRemaining &lt; <span class="number">1</span></span><br><span class="line">      res.send <span class="string">&quot;Rate Limit hit, stop believing for awhile&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># rest of your code</span></span><br></pre></td></tr></table></figure>

<p><code>body</code> 是响应体字符串，应该是您最关心的东西。</p>
<figure class="highlight coffee"><table><tr><td class="code"><pre><span class="line">robot.http(<span class="string">&quot;https://midnight-train&quot;</span>)</span><br><span class="line">  .get() (err, res, body) -&gt;</span><br><span class="line">    <span class="comment"># error checking code here</span></span><br><span class="line"></span><br><span class="line">    res.send <span class="string">&quot;Got back <span class="subst">#&#123;body&#125;</span>&quot;</span></span><br></pre></td></tr></table></figure>

<h4 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h4><p>与 API 交流，最简单的方法是 JSON，因为它不需要任何额外的依赖。当使用<code>robot.http</code>请求，您通常应该设置<code>Accept</code>头去给API一个希望得到什么的线索。一旦您得到了返回的<code>body</code>，您就可以使用 <code>JSON.parse</code>：</p>
<figure class="highlight coffee"><table><tr><td class="code"><pre><span class="line">robot.http(<span class="string">&quot;https://midnight-train&quot;</span>)</span><br><span class="line">  .header(<span class="string">&#x27;Accept&#x27;</span>, <span class="string">&#x27;application/json&#x27;</span>)</span><br><span class="line">  .get() (err, res, body) -&gt;</span><br><span class="line">    <span class="comment"># error checking code here</span></span><br><span class="line"></span><br><span class="line">    data = <span class="built_in">JSON</span>.parse body</span><br><span class="line">    res.send <span class="string">&quot;<span class="subst">#&#123;data.passenger&#125;</span> taking midnight train going <span class="subst">#&#123;data.destination&#125;</span>&quot;</span></span><br></pre></td></tr></table></figure>

<p>得到的返回也可能不是JSON，就像如果这API遇到一个错误并且它试图渲染一个正常的 HTML 错误，而不是 JSON。为了安全起见，您应该检查内容类型，并在解析时发现任何错误。</p>
<figure class="highlight coffee"><table><tr><td class="code"><pre><span class="line">robot.http(<span class="string">&quot;https://midnight-train&quot;</span>)</span><br><span class="line">  .header(<span class="string">&#x27;Accept&#x27;</span>, <span class="string">&#x27;application/json&#x27;</span>)</span><br><span class="line">  .get() (err, res, body) -&gt;</span><br><span class="line">    <span class="comment"># err &amp; response status checking code here</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> response.getHeader(<span class="string">&#x27;Content-Type&#x27;</span>) <span class="keyword">isnt</span> <span class="string">&#x27;application/json&#x27;</span></span><br><span class="line">      res.send <span class="string">&quot;Didn&#x27;t get back JSON :(&quot;</span></span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    data = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">      data = <span class="built_in">JSON</span>.parse body</span><br><span class="line">    <span class="keyword">catch</span> error</span><br><span class="line">     res.send <span class="string">&quot;Ran into an error parsing JSON :(&quot;</span></span><br><span class="line">     <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># your code here</span></span><br></pre></td></tr></table></figure>

<h4 id="XML"><a href="#XML" class="headerlink" title="XML"></a>XML</h4><p>XML API 比较难，因为没有捆绑的 XML 解析库。详细介绍此文档的范围超出了此范围，但下面有一些可以查看的库：</p>
<ul>
<li><a href="https://github.com/buglabs/node-xml2json">xml2json</a> (simplest to use, but has some limitations)</li>
<li><a href="https://github.com/tmpvar/jsdom">jsdom</a> (JavaScript implementation of the W3C DOM)</li>
<li><a href="https://github.com/Leonidas-from-XIV/node-xml2js">xml2js</a></li>
</ul>
<h4 id="萤幕抓取"><a href="#萤幕抓取" class="headerlink" title="萤幕抓取"></a>萤幕抓取</h4><p>对于没有 API 的时代，总有可能进行萤幕抓取。详细介绍此文档的范围超出了此范围，但下面是一些可以查看的库：</p>
<ul>
<li><a href="https://github.com/MatthewMueller/cheerio">cheerio</a> (familiar syntax and API to jQuery)</li>
<li><a href="https://github.com/tmpvar/jsdom">jsdom</a> (JavaScript implementation of the W3C DOM)</li>
</ul>
<h4 id="高级-HTTP-和-HTTPS-设置"><a href="#高级-HTTP-和-HTTPS-设置" class="headerlink" title="高级 HTTP 和 HTTPS 设置"></a>高级 HTTP 和 HTTPS 设置</h4><p>前面提到，hubot 使用<a href="https://github.com/technoweenie/node-scoped-http-client">node-scoped-http-client</a>来提供一个简单的接口去发起HTTP和HTTPS请求。它封装了node的<a href="http://nodejs.org/api/http.html">http</a>和<a href="http://nodejs.org/api/https.html">https</a>库，但为常见的交互类型提供了一个简单的DSL（Domain Specific Language 领域专用语言）。</p>
<p>如果您需要直接控制http和https的选项，您传第二个参数给<code>robot.http</code>，它将通过 node-scoped-http-client 传递给 http 或者 https：</p>
<figure class="highlight coffee"><table><tr><td class="code"><pre><span class="line">options =</span><br><span class="line">  <span class="comment"># don&#x27;t verify server certificate against a CA, SCARY!</span></span><br><span class="line">  rejectUnauthorized: <span class="literal">false</span></span><br><span class="line">robot.http(<span class="string">&quot;https://midnight-train&quot;</span>, options)</span><br></pre></td></tr></table></figure>

<p>另外，如果node-scoped-http-client并不适合您，您可以直接使用<a href="http://nodejs.org/api/http.html">http</a>和<a href="http://nodejs.org/api/https.html">https</a>，或者其它的node库，例如：<a href="https://github.com/request/request">request</a></p>
<h3 id="随机"><a href="#随机" class="headerlink" title="随机"></a>随机</h3><p>一种常见的模式是聆听或响应命令，并发送随机有趣的图像或文本从一个包含可能性的数组。直接使用JavaScript和CoffeeScript来实现比较麻烦， 所以 hubot 包括一个方便的方法：</p>
<figure class="highlight coffee"><table><tr><td class="code"><pre><span class="line">lulz = [<span class="string">&#x27;lol&#x27;</span>, <span class="string">&#x27;rofl&#x27;</span>, <span class="string">&#x27;lmao&#x27;</span>]</span><br><span class="line"></span><br><span class="line">res.send res.random lulz</span><br></pre></td></tr></table></figure>

<h3 id="主题"><a href="#主题" class="headerlink" title="主题"></a>主题</h3><p>Hubot 可以响应一个房间的主题变化，假设适配器支持它：</p>
<figure class="highlight coffee"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.<span class="built_in">exports</span> = <span class="function"><span class="params">(robot)</span> -&gt;</span></span><br><span class="line">  robot.topic (res) -&gt;</span><br><span class="line">    res.send <span class="string">&quot;<span class="subst">#&#123;res.message.text&#125;</span>? That&#x27;s a Paddlin&#x27;&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="加入和离开"><a href="#加入和离开" class="headerlink" title="加入和离开"></a>加入和离开</h3><p>Hubot 能够观察用户的加入和离开，假设适配器支持它。</p>
<figure class="highlight coffee"><table><tr><td class="code"><pre><span class="line">enterReplies = [<span class="string">&#x27;Hi&#x27;</span>, <span class="string">&#x27;Target Acquired&#x27;</span>, <span class="string">&#x27;Firing&#x27;</span>, <span class="string">&#x27;Hello friend.&#x27;</span>, <span class="string">&#x27;Gotcha&#x27;</span>, <span class="string">&#x27;I see you&#x27;</span>]</span><br><span class="line">leaveReplies = [<span class="string">&#x27;Are you still there?&#x27;</span>, <span class="string">&#x27;Target lost&#x27;</span>, <span class="string">&#x27;Searching&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.<span class="built_in">exports</span> = <span class="function"><span class="params">(robot)</span> -&gt;</span></span><br><span class="line">  robot.enter (res) -&gt;</span><br><span class="line">    res.send res.random enterReplies</span><br><span class="line">  robot.leave (res) -&gt;</span><br><span class="line">    res.send res.random leaveReplies</span><br></pre></td></tr></table></figure>

<h3 id="自定义监听器"><a href="#自定义监听器" class="headerlink" title="自定义监听器"></a>自定义监听器</h3><p>虽然上面的 helpers 涵盖了普通用户需要的大部分功能（聆听、响应、加入、离开、主题），有时您想为监听器赋予特定的匹配逻辑。如果是这样，您可以使用<code>listen</code>来指定自定义匹配函数来替代正则表达。</p>
<p>如果监听器回调要被执行，匹配函数必须返回真实值。然后将匹配函数的真实返回值用<code>response.match</code>传递给回调。</p>
<figure class="highlight coffee"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.<span class="built_in">exports</span> = <span class="function"><span class="params">(robot)</span> -&gt;</span></span><br><span class="line">  robot.listen(</span><br><span class="line">    <span class="function"><span class="params">(message)</span> -&gt;</span> <span class="comment"># Match function</span></span><br><span class="line">      <span class="comment"># Occassionally respond to things that Steve says</span></span><br><span class="line">      message.user.name <span class="keyword">is</span> <span class="string">&quot;Steve&quot;</span> <span class="keyword">and</span> <span class="built_in">Math</span>.random() &gt; <span class="number">0.8</span></span><br><span class="line">    (response) -&gt; <span class="comment"># Standard listener callback</span></span><br><span class="line">      <span class="comment"># Let Steve know how happy you are that he exists</span></span><br><span class="line">      response.reply <span class="string">&quot;HI STEVE! YOU&#x27;RE MY BEST FRIEND! (but only like <span class="subst">#&#123;response.match * <span class="number">100</span>&#125;</span>% of the time)&quot;</span></span><br><span class="line">  )</span><br></pre></td></tr></table></figure>
<p>有关复杂的匹配器示例，请参阅<a href="https://hubot.github.com/docs/patterns/">设计模式文档</a>。</p>
<h3 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h3><p>Hubot 可以使用<a href="http://nodejs.org/api/process.html#process_process_env">process.env</a>访问他运行的环境，就像任何其他node程序一样。这可用于配置脚本的运行方式，约定使用<code>HUBOT_</code>前缀。</p>
<figure class="highlight coffee"><table><tr><td class="code"><pre><span class="line">answer = process.env.HUBOT_ANSWER_TO_THE_ULTIMATE_QUESTION_OF_LIFE_THE_UNIVERSE_AND_EVERYTHING</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.<span class="built_in">exports</span> = <span class="function"><span class="params">(robot)</span> -&gt;</span></span><br><span class="line">  robot.respond <span class="regexp">/what is the answer to the ultimate question of life/</span>, <span class="function"><span class="params">(res)</span> -&gt;</span></span><br><span class="line">    res.send <span class="string">&quot;<span class="subst">#&#123;answer&#125;</span>, but what is the question?&quot;</span></span><br></pre></td></tr></table></figure>
<p>小心的去确保环境变量没有定义时脚本可以加载，给 hubot 开发者去定义该环境变量的提示，或者默认的一些东西。由脚本编写者来决定这是否应该是一个致命的错误（e.g. hubot 退出），也可以制作任何依赖于它的脚本，去表明它需要配置。在尽可能和有意义时，脚本运作不需要任何其它的配置更好。</p>
<p>在这里，我们可以默认的东西：</p>
<figure class="highlight coffee"><table><tr><td class="code"><pre><span class="line">answer = process.env.HUBOT_ANSWER_TO_THE_ULTIMATE_QUESTION_OF_LIFE_THE_UNIVERSE_AND_EVERYTHING <span class="keyword">or</span> <span class="number">42</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.<span class="built_in">exports</span> = <span class="function"><span class="params">(robot)</span> -&gt;</span></span><br><span class="line">  robot.respond <span class="regexp">/what is the answer to the ultimate question of life/</span>, <span class="function"><span class="params">(res)</span> -&gt;</span></span><br><span class="line">    res.send <span class="string">&quot;<span class="subst">#&#123;answer&#125;</span>, but what is the question?&quot;</span></span><br></pre></td></tr></table></figure>

<p>如果环境变量没有定义，在这里我们退出：</p>
<figure class="highlight coffee"><table><tr><td class="code"><pre><span class="line">answer = process.env.HUBOT_ANSWER_TO_THE_ULTIMATE_QUESTION_OF_LIFE_THE_UNIVERSE_AND_EVERYTHING</span><br><span class="line"><span class="keyword">unless</span> answer?</span><br><span class="line">  <span class="built_in">console</span>.log <span class="string">&quot;Missing HUBOT_ANSWER_TO_THE_ULTIMATE_QUESTION_OF_LIFE_THE_UNIVERSE_AND_EVERYTHING in environment: please set and try again&quot;</span></span><br><span class="line">  process.exit(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.<span class="built_in">exports</span> = <span class="function"><span class="params">(robot)</span> -&gt;</span></span><br><span class="line">  robot.respond <span class="regexp">/what is the answer to the ultimate question of life/</span>, <span class="function"><span class="params">(res)</span> -&gt;</span></span><br><span class="line">    res.send <span class="string">&quot;<span class="subst">#&#123;answer&#125;</span>, but what is the question?&quot;</span></span><br></pre></td></tr></table></figure>

<p>最后， 我们更新<code>robot.repond</code>去检查它：</p>
<figure class="highlight coffee"><table><tr><td class="code"><pre><span class="line">answer = process.env.HUBOT_ANSWER_TO_THE_ULTIMATE_QUESTION_OF_LIFE_THE_UNIVERSE_AND_EVERYTHING</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.<span class="built_in">exports</span> = <span class="function"><span class="params">(robot)</span> -&gt;</span></span><br><span class="line">  robot.respond <span class="regexp">/what is the answer to the ultimate question of life/</span>, <span class="function"><span class="params">(res)</span> -&gt;</span></span><br><span class="line">    <span class="keyword">unless</span> answer?</span><br><span class="line">      res.send <span class="string">&quot;Missing HUBOT_ANSWER_TO_THE_ULTIMATE_QUESTION_OF_LIFE_THE_UNIVERSE_AND_EVERYTHING in environment: please set and try again&quot;</span></span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    res.send <span class="string">&quot;<span class="subst">#&#123;answer&#125;</span>, but what is the question?&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h3><p>Hubot 使用<a href="https://github.com/isaacs/npm">npm</a>去管理它的依赖。要去添加额外的包，添加它们到<code>package.json</code>文件的<code>dependencies</code>中。例如，添加<code>lolimadeupthispackage 1.2.3</code>，如：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;dependencies&quot;</span>: &#123;</span><br><span class="line">  <span class="attr">&quot;hubot&quot;</span>:         <span class="string">&quot;2.5.5&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;lolimadeupthispackage&quot;</span>: <span class="string">&quot;1.2.3&quot;</span></span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
<p>如果您使用 hubot-scripts 中的脚本，记下要添加的脚本中的<code>Dependencies</code>文档。它们以可以复制粘贴进<code>package.json</code>的格式列出，只需确保根据需要添加逗号使其成为有效 JSON即可。</p>
<h3 id="超时和间隔"><a href="#超时和间隔" class="headerlink" title="超时和间隔"></a>超时和间隔</h3><blockquote>
<p>译者注：这里普及JavaScript的<code>setTimeout</code>和<code>setInterval</code>语法。</p>
</blockquote>
<p>Hubot可以使用JavaScript内置的<a href="http://nodejs.org/api/timers.html#timers_settimeout_callback_delay_arg">setTimeout</a>来延迟运行代码。</p>
<figure class="highlight coffee"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.<span class="built_in">exports</span> = <span class="function"><span class="params">(robot)</span> -&gt;</span></span><br><span class="line">  robot.respond <span class="regexp">/you are a little slow/</span>, <span class="function"><span class="params">(res)</span> -&gt;</span></span><br><span class="line">    <span class="built_in">setTimeout</span> () -&gt;</span><br><span class="line">      res.send <span class="string">&quot;Who you calling &#x27;slow&#x27;?&quot;</span></span><br><span class="line">    , <span class="number">60</span> * <span class="number">1000</span></span><br></pre></td></tr></table></figure>
<p>另外，hubot可以用<a href="http://nodejs.org/api/timers.html#timers_setinterval_callback_delay_arg">setInterval</a>来间隔运行代码。它需要回调方法，以及调用之间的等待时间：</p>
<figure class="highlight coffee"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.<span class="built_in">exports</span> = <span class="function"><span class="params">(robot)</span> -&gt;</span></span><br><span class="line">  robot.respond <span class="regexp">/annoy me/</span>, <span class="function"><span class="params">(res)</span> -&gt;</span></span><br><span class="line">    res.send <span class="string">&quot;Hey, want to hear the most annoying sound in the world?&quot;</span></span><br><span class="line">    <span class="built_in">setInterval</span> () -&gt;</span><br><span class="line">      res.send <span class="string">&quot;AAAAAAAAAAAEEEEEEEEEEEEEEEEEEEEEEEEIIIIIIIIHHHHHHHHHH&quot;</span></span><br><span class="line">    , <span class="number">1000</span></span><br></pre></td></tr></table></figure>

<p><code>setTimeout</code>和<code>setInterval</code>创建时，都返回超时或间隔的ID。这可用于<code>clearTimeout</code>和<code>clearInterval</code>。</p>
<figure class="highlight coffee"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.<span class="built_in">exports</span> = <span class="function"><span class="params">(robot)</span> -&gt;</span></span><br><span class="line">  annoyIntervalId = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">  robot.respond <span class="regexp">/annoy me/</span>, <span class="function"><span class="params">(res)</span> -&gt;</span></span><br><span class="line">    <span class="keyword">if</span> annoyIntervalId</span><br><span class="line">      res.send <span class="string">&quot;AAAAAAAAAAAEEEEEEEEEEEEEEEEEEEEEEEEIIIIIIIIHHHHHHHHHH&quot;</span></span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    res.send <span class="string">&quot;Hey, want to hear the most annoying sound in the world?&quot;</span></span><br><span class="line">    annoyIntervalId = <span class="built_in">setInterval</span> () -&gt;</span><br><span class="line">      res.send <span class="string">&quot;AAAAAAAAAAAEEEEEEEEEEEEEEEEEEEEEEEEIIIIIIIIHHHHHHHHHH&quot;</span></span><br><span class="line">    , <span class="number">1000</span></span><br><span class="line"></span><br><span class="line">  robot.respond <span class="regexp">/unannoy me/</span>, <span class="function"><span class="params">(res)</span> -&gt;</span></span><br><span class="line">    <span class="keyword">if</span> annoyIntervalId</span><br><span class="line">      res.send <span class="string">&quot;GUYS, GUYS, GUYS!&quot;</span></span><br><span class="line">      <span class="built_in">clearInterval</span>(annoyIntervalId)</span><br><span class="line">      annoyIntervalId = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      res.send <span class="string">&quot;Not annoying you right now, am I?&quot;</span></span><br></pre></td></tr></table></figure>
<h3 id="HTTP-监听器"><a href="#HTTP-监听器" class="headerlink" title="HTTP 监听器"></a>HTTP 监听器</h3><p>Hubot 包括支持<a href="http://expressjs.com/">express</a>网络框架以满足HTTP请求。它监听<code>EXPRESS_PORT</code>或<code>PORT</code>环境变量指定的端口（按该顺序首选），默认值设置为8080。一个express应用的实例可在<code>robot.router</code>中。可以通过指定<code>EXPRESS_USER</code>和<code>EXPRESS_PASSWORD</code>来保护用户名和密码。通过设置<code>EXPRESS_STATIC</code>它可以自动为静态文件服务。</p>
<p>最常见的用途是为带有webhooks的服务提供HTTP端点去推送，并让这些出现在聊天中。</p>
<figure class="highlight coffee"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.<span class="built_in">exports</span> = <span class="function"><span class="params">(robot)</span> -&gt;</span></span><br><span class="line">  <span class="comment"># the expected value of :room is going to vary by adapter, it might be a numeric id, name, token, or some other value</span></span><br><span class="line">  robot.router.post <span class="string">&#x27;/hubot/chatsecrets/:room&#x27;</span>, <span class="function"><span class="params">(req, res)</span> -&gt;</span></span><br><span class="line">    room   = req.params.room</span><br><span class="line">    data   = <span class="keyword">if</span> req.body.payload? <span class="keyword">then</span> <span class="built_in">JSON</span>.parse req.body.payload <span class="keyword">else</span> req.body</span><br><span class="line">    secret = data.secret</span><br><span class="line"></span><br><span class="line">    robot.messageRoom room, <span class="string">&quot;I have a secret: <span class="subst">#&#123;secret&#125;</span>&quot;</span></span><br><span class="line"></span><br><span class="line">    res.send <span class="string">&#x27;OK&#x27;</span></span><br></pre></td></tr></table></figure>

<p>用curl测试它；另请参阅下面关于<a href="https://hubot.github.com/docs/scripting/#error-handling">error handling</a>的部分。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// raw json, must specify Content-Type: application/json</span><br><span class="line">curl -X POST -H &quot;Content-Type: application/json&quot; -d &#x27;&#123;&quot;secret&quot;:&quot;C-TECH Astronomy&quot;&#125;&#x27; http://127.0.0.1:8080/hubot/chatsecrets/general</span><br><span class="line"></span><br><span class="line">// defaults Content-Type: application/x-www-form-urlencoded, must st payload=...</span><br><span class="line">curl -d &#x27;payload=%7B%22secret%22%3A%22C-TECH+Astronomy%22%7D&#x27; http://127.0.0.1:8080/hubot/chatsecrets/general</span><br></pre></td></tr></table></figure>

<p>所有的端点URLs应该以<code>/hubot</code>起头（无论您的机器人及叫什么名字）。这种一致性使得设置webhooks（可复制粘贴的URL）更加容易，并且保证URLs是有效的（并不是所有的bot命名都是URL安全的）。</p>
<h3 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h3><p>Hubot 还可以响应可用于在脚本之间传递数据的事件。这是通过使用<code>robot.emit</code>和<code>robot.on</code>封装node.js的<a href="http://nodejs.org/api/events.html#events_class_events_eventemitter">EventEmitter</a>实现的。</p>
<p>其中一个用例是，有一个脚本用于处理与服务的交互，然后在事件出现时发送。例如，我们有一个脚本从 GitHub <code>post-commit</code> 钩子接收数据，当 commits 来时发送 commits 事件，然后对这些提交进行另一个脚本行为。</p>
<figure class="highlight coffee"><table><tr><td class="code"><pre><span class="line"><span class="comment"># src/scripts/github-commits.coffee</span></span><br><span class="line"><span class="built_in">module</span>.<span class="built_in">exports</span> = <span class="function"><span class="params">(robot)</span> -&gt;</span></span><br><span class="line">  robot.router.post <span class="string">&quot;/hubot/gh-commits&quot;</span>, <span class="function"><span class="params">(req, res)</span> -&gt;</span></span><br><span class="line">    robot.emit <span class="string">&quot;commit&quot;</span>, &#123;</span><br><span class="line">        user    : &#123;&#125;, <span class="comment">#hubot user object</span></span><br><span class="line">        repo    : <span class="string">&#x27;https://github.com/github/hubot&#x27;</span>,</span><br><span class="line">        hash  : <span class="string">&#x27;2e1951c089bd865839328592ff673d2f08153643&#x27;</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight coffee"><table><tr><td class="code"><pre><span class="line"><span class="comment"># src/scripts/heroku.coffee</span></span><br><span class="line"><span class="built_in">module</span>.<span class="built_in">exports</span> = <span class="function"><span class="params">(robot)</span> -&gt;</span></span><br><span class="line">  robot.<span class="literal">on</span> <span class="string">&quot;commit&quot;</span>, <span class="function"><span class="params">(commit)</span> -&gt;</span></span><br><span class="line">    robot.send commit.user, <span class="string">&quot;Will now deploy <span class="subst">#&#123;commit.hash&#125;</span> from <span class="subst">#&#123;commit.repo&#125;</span>!&quot;</span></span><br><span class="line">    <span class="comment">#deploy code goes here</span></span><br></pre></td></tr></table></figure>
<p>如果您提供一个事件，强烈建议在其数据中包括 hubot user或room对象。这将允许hubot 在聊天中通知用户或房间。</p>
<h3 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h3><p>没有完美的代码，并且错误和意外是意料之中的。以前，一个未捕获的异常会是您的hubot实例崩溃。Hubot现在包含了一个<code>uncaughtException</code>处理程序，它为脚本提供钩子以此来进行错误处理。</p>
<figure class="highlight coffee"><table><tr><td class="code"><pre><span class="line"><span class="comment"># src/scripts/does-not-compute.coffee</span></span><br><span class="line"><span class="built_in">module</span>.<span class="built_in">exports</span> = <span class="function"><span class="params">(robot)</span> -&gt;</span></span><br><span class="line">  robot.error (err, res) -&gt;</span><br><span class="line">    robot.logger.error <span class="string">&quot;DOES NOT COMPUTE&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> res?</span><br><span class="line">      res.reply <span class="string">&quot;DOES NOT COMPUTE&quot;</span></span><br></pre></td></tr></table></figure>
<p>您可以在这里做任何您想做的事，但您会想采取额外的预防措施来拯救和记录错误，特别是异步代码。否则，您可能会发现自己有递归的错误，却不知道发生了什么事情。</p>
<p>在头巾之下，‘error’事件发射出来，伴随着的是错误处理程序消费那个事件。<code>uncaughtException</code>处理程序，<a href="http://nodejs.org/api/process.html#process_event_uncaughtexception">从技术上讲， 使过程处于未知状态。</a>。因此，无论何时您应该尽可能的拯救您自己的异常，并且自己发出它们。第一个参数是发出的错误，第二个参数是生成错误的可选消息。<br>使用前面的例子：</p>
<figure class="highlight coffee"><table><tr><td class="code"><pre><span class="line">robot.router.post <span class="string">&#x27;/hubot/chatsecrets/:room&#x27;</span>, <span class="function"><span class="params">(req, res)</span> -&gt;</span></span><br><span class="line">  room = req.params.room</span><br><span class="line">  data = <span class="literal">null</span></span><br><span class="line">  <span class="keyword">try</span></span><br><span class="line">    data = <span class="built_in">JSON</span>.parse req.body.payload</span><br><span class="line">  <span class="keyword">catch</span> err</span><br><span class="line">    robot.emit <span class="string">&#x27;error&#x27;</span>, err</span><br><span class="line"></span><br><span class="line">  <span class="comment"># rest of the code here</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">robot.hear <span class="regexp">/midnight train/i</span>, <span class="function"><span class="params">(res)</span> -&gt;</span></span><br><span class="line">  robot.http(<span class="string">&quot;https://midnight-train&quot;</span>)</span><br><span class="line">    .get() (err, res, body) -&gt;</span><br><span class="line">      <span class="keyword">if</span> err</span><br><span class="line">        res.reply <span class="string">&quot;Had problems taking the midnight train&quot;</span></span><br><span class="line">        robot.emit <span class="string">&#x27;error&#x27;</span>, err, res</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">      <span class="comment"># rest of code here</span></span><br></pre></td></tr></table></figure>
<p>对于第二个例子，值得思考的是用户会看到哪些消息。如果您有回复用户的错误处理程序，您可能不需要添加自定义消息，并且可以发回提供给get()请求的错误消息，当然这取决于您想多么的公开您的错误报告。</p>
<h3 id="脚本文档"><a href="#脚本文档" class="headerlink" title="脚本文档"></a>脚本文档</h3><p>Hubot 脚本可以用在其文件顶部的注释编写文档，例如：</p>
<figure class="highlight coffee"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Description:</span></span><br><span class="line"><span class="comment">#   &lt;description of the scripts functionality&gt;</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Dependencies:</span></span><br><span class="line"><span class="comment">#   &quot;&lt;module name&gt;&quot;: &quot;&lt;module version&gt;&quot;</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Configuration:</span></span><br><span class="line"><span class="comment">#   LIST_OF_ENV_VARS_TO_SET</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Commands:</span></span><br><span class="line"><span class="comment">#   hubot &lt;trigger&gt; - &lt;what the respond trigger does&gt;</span></span><br><span class="line"><span class="comment">#   &lt;trigger&gt; - &lt;what the hear trigger does&gt;</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Notes:</span></span><br><span class="line"><span class="comment">#   &lt;optional notes required for the script&gt;</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Author:</span></span><br><span class="line"><span class="comment">#   &lt;github username of the original script author&gt;</span></span><br></pre></td></tr></table></figure>
<p>这最重要的和用户面向的是<code>Commands</code>。在加载时间，Hubot 查看每个脚本的命令部分，并建立所有命令的列表。包含的<code>help.coffee</code>允许用户在所有命令或搜索中寻求帮助。因此，为这些命令制作文档使用户更容易发现这些命令。</p>
<p>为命令制作文档的时候，这里有一些最佳实践：</p>
<ul>
<li>保持在一行。帮助命令会被排序，因此第二行可能会被插到一个出乎意料的的地方，使得它没有意义。</li>
<li>将 Hubot 命名为 hubot，即使您的 hubot 被命名为其它。它将被自动替换为正确的名字。这使得无需更新文档即可轻松共享脚本。</li>
<li>对于<code>robot.respond</code>文档，总是以<code>hubot</code>作为前缀。Hubot将自动用您的机器人名字或者机器人的别名替换。</li>
<li>查看 man 手册文档是怎样制作自己的文档的。特别是，括号表示可选项，”…”表示任意数量的参数，等。</li>
</ul>
<p>文档的其它部分与bot的开发人员更相关，尤其是依赖、配置变量和说明。对<a href="https://github.com/github/hubot-scripts">hubot-scripts</a>的所有贡献应包含与脚本启动和运行相关的所有这些部分。</p>
<h3 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h3><p>Hubot暴露<code>robot.brain</code>内存键值存储，可用于通过脚本存储和检索数据。</p>
<figure class="highlight coffee"><table><tr><td class="code"><pre><span class="line">robot.respond <span class="regexp">/have a soda/i</span>, <span class="function"><span class="params">(res)</span> -&gt;</span></span><br><span class="line">  <span class="comment"># Get number of sodas had (coerced to a number).</span></span><br><span class="line">  sodasHad = robot.brain.get(<span class="string">&#x27;totalSodas&#x27;</span>) * <span class="number">1</span> <span class="keyword">or</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> sodasHad &gt; <span class="number">4</span></span><br><span class="line">    res.reply <span class="string">&quot;I&#x27;m too fizzy..&quot;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    res.reply <span class="string">&#x27;Sure!&#x27;</span></span><br><span class="line"></span><br><span class="line">    robot.brain.set <span class="string">&#x27;totalSodas&#x27;</span>, sodasHad+<span class="number">1</span></span><br><span class="line">robot.respond <span class="regexp">/sleep it off/i</span>, <span class="function"><span class="params">(res)</span> -&gt;</span></span><br><span class="line">  robot.brain.set <span class="string">&#x27;totalSodas&#x27;</span>, <span class="number">0</span></span><br><span class="line">  msg.reply <span class="string">&#x27;zzzzz&#x27;</span></span><br></pre></td></tr></table></figure>

<p>如果脚本需要检索用户数据，<code>robot.brain</code>上有些方法通过id，name，或者name的模糊匹配：<code>userForName</code>, <code>userForId</code>, <code>userForFuzzyName</code>和<code>usersForFuzzyName</code>去查找一个或者多个用户。</p>
<figure class="highlight coffee"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.<span class="built_in">exports</span> = <span class="function"><span class="params">(robot)</span> -&gt;</span></span><br><span class="line"></span><br><span class="line">  robot.respond <span class="regexp">/who is @?([\w .\-]+)\?*$/i</span>, <span class="function"><span class="params">(res)</span> -&gt;</span></span><br><span class="line">    name = res.match[<span class="number">1</span>].trim()</span><br><span class="line"></span><br><span class="line">    users = robot.brain.usersForFuzzyName(name)</span><br><span class="line">    <span class="keyword">if</span> users.length <span class="keyword">is</span> <span class="number">1</span></span><br><span class="line">      user = users[<span class="number">0</span>]</span><br><span class="line">      <span class="comment"># Do something interesting here..</span></span><br><span class="line"></span><br><span class="line">      res.send <span class="string">&quot;<span class="subst">#&#123;name&#125;</span> is user - <span class="subst">#&#123;user&#125;</span>&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="脚本加载"><a href="#脚本加载" class="headerlink" title="脚本加载"></a>脚本加载</h3><p>加载脚本有三个主要来源：</p>
<ul>
<li><code>scripts/</code>目录下的所有脚本都与您的 hubot 绑定。</li>
<li><code>hubot-scripts.json</code>中指定的社区脚本，并发布在 <code>hubot-scripts</code> npm 包。</li>
<li>脚本从外部 npm 包加载， 并在 <code>external-scripts.json</code> 中指定。</li>
</ul>
<p>从<code>scripts/</code>目录中加载的脚本按字母顺序加载，因此您可以预期脚本的一致加载顺序。例如：</p>
<ul>
<li><code>scripts/1-first.coffee</code></li>
<li><code>scripts/_second.coffee</code></li>
<li><code>scripts/third.coffee</code></li>
</ul>
<h3 id="分享脚本"><a href="#分享脚本" class="headerlink" title="分享脚本"></a>分享脚本</h3><p>一旦您构建了一些新的脚本，以扩大您的机器人朋友的能力，您应该考虑与世界分享他们！至少，您需要打包脚本并将其提交到 <code>Node.js 程序包仓库</code>。您还应查看以下共享脚本的最佳实践。</p>
<h4 id="查看脚本是否已存在"><a href="#查看脚本是否已存在" class="headerlink" title="查看脚本是否已存在"></a>查看脚本是否已存在</h4><p>首先<a href="https://hubot.github.com/docs/#scripts">检查像您这样的脚本的 NPM 包是否已经存在</a>。如果您没有看到可以贡献的现有包，则可以轻松地开始使用 hubot 脚本 <a href="http://yeoman.io/">yeoman</a> 生成器。</p>
<h4 id="创建一个脚本程序包"><a href="#创建一个脚本程序包" class="headerlink" title="创建一个脚本程序包"></a>创建一个脚本程序包</h4><p>为 hubot 创建脚本包非常简单。首先安装<a href="http://yeoman.io/">yeoman</a>生成器：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> npm install -g yo generator-hubot</span></span><br></pre></td></tr></table></figure>

<p>安装hubot生成器后，创建hubot脚本类似于创建一个新的hubot。您为您的hubot脚本创建目录，并在其中生成一个新的<code>hubot:script</code>。例如，如果我们想创建一个 hubot 脚本叫“my-awesome-script”:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> mkdir hubot-my-awesome-script</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> hubot-my-awesome-script</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> yo hubot:script</span></span><br></pre></td></tr></table></figure>

<p>此时，您会被问到一些有关脚本作者的问题，脚本的名字（由目录名猜测），一个简短的描述，和去查找它的关键字（我们建议至少有<code>hubot</code>，<code>hubot-scripts</code>）。</p>
<p>如果您使用的是 git，生成的目录包含一个 <code>.gitignore</code>，因此您可以初始化并添加所有内容：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git init</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git add .</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git commit -m <span class="string">&quot;Initial commit&quot;</span></span></span><br></pre></td></tr></table></figure>

<p>您现在有一个准备好去启动的hubot脚本库。轻松打开预创建的<code>src/awesome-script.coffee</code>文件，并开始构建您的脚本！准备好后，您可以<a href="https://docs.npmjs.com/getting-started/publishing-npm-packages">按照他们的文档</a>将其发布到 <a href="http://npmjs.org/">npmjs</a>！</p>
<p>您可能需要为新脚本编写一些单元测试。测试脚本样例写在<code>test/awesome-script-test.coffee</code>，您可以用<code>grunt</code>运行。有关测试的更多信息，请参阅<a href="https://hubot.github.com/docs/scripting/#testing-hubot-scripts">测试Hubot脚本</a>部分。</p>
<h3 id="监听器元数据"><a href="#监听器元数据" class="headerlink" title="监听器元数据"></a>监听器元数据</h3><p>除了正则表达和回调，<code>hear</code>和<code>respond</code>函数还接受一个可选的选项对象，它可以被用于附加任意元数据到生成的监听器对象。此元数据允许在不修改脚本包的情况下轻松扩展脚本的行为。</p>
<p>最重要和最常用的元数据键是<code>id</code>。每个监听器应该被赋予一个唯一的名字（options.id，默认是<code>null</code>）。名称应按模块划分（e.g. ‘my-module.my-listener’）。这些名称允许其他脚本直接针对单个监听器，并扩展它们的其他功能，如授权和速率限制。</p>
<p>其他扩展可以定义和处理其他元数据键。更多信息，请参阅<a href="https://hubot.github.com/docs/scripting/#listener-middleware">Listener Middleware section</a>部分。</p>
<p>回到到较早的示例：</p>
<figure class="highlight coffee"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.<span class="built_in">exports</span> = <span class="function"><span class="params">(robot)</span> -&gt;</span></span><br><span class="line">  robot.respond <span class="regexp">/annoy me/</span>, id:<span class="string">&#x27;annoyance.start&#x27;</span>, (msg)</span><br><span class="line">    <span class="comment"># code to annoy someone</span></span><br><span class="line"></span><br><span class="line">  robot.respond <span class="regexp">/unannoy me/</span>, id:<span class="string">&#x27;annoyance.stop&#x27;</span>, (msg)</span><br><span class="line">    <span class="comment"># code to stop annoying someone</span></span><br></pre></td></tr></table></figure>
<p>这些范围标识符允许您外部指定新行为，如：</p>
<ul>
<li>授权政策： “允许<code>annoyers</code>组中的每个人执行<code>annoyance.*</code>命令”</li>
<li>限速：“只允许30分钟执行一次<code>annoyance.start</code>”</li>
</ul>
<h3 id="中间件"><a href="#中间件" class="headerlink" title="中间件"></a>中间件</h3><p>有三种中间件： Receive, Listener and Response。</p>
<p>在监听器被查看之前，Receive 中间件执行一次。Listener 中间件在监听器匹配到信息后执行。Response 中间件在每次响应一个消息时运行。</p>
<h4 id="执行过程和-API"><a href="#执行过程和-API" class="headerlink" title="执行过程和 API"></a>执行过程和 API</h4><p>类似于<a href="http://expressjs.com/api.html#middleware">Express middleware</a>，hubot 按定义顺序执行中间件。每个中间件可以继续链（通过调用<code>next</code>）或中断链（通过调用<code>done</code>）。如果所有中间件继续，监听器回调被执行，并且<code>done</code>会被调用。中间件可以包装<code>done</code>的回调，以便在过程的后半部分执行代码（在执行了监听器回调或更深的中间件中断之后）。</p>
<p>中间件被调用：</p>
<ul>
<li><code>context</code><ul>
<li>查看每个中间件类型的 API，查看上下文暴露的内容。</li>
</ul>
</li>
<li><code>next</code><ul>
<li>一个没有额外的属性的函数，它应该被调用从而继续到下一块中间件/执行监听器的回调</li>
<li><code>next</code>应该用一个单独的、可选的参数调用：要么提供<code>done</code>函数，要么一个最终调用的时候叫<code>done</code>的新函数。如果参数没有指定，那么将假定为<code>done</code>。</li>
</ul>
</li>
<li><code>done</code><ul>
<li>一个没有附加属性的函数，用于在中断中间件执行时调用，并开始执行完成功能的链。</li>
<li><code>done</code>在调用时无需任何参数。</li>
</ul>
</li>
</ul>
<p>每个中间件接收相同的<code>context</code>、<code>next</code>和<code>done</code>的API签名。不同种类的中间件在<code>context</code>对象中可能接收到不同的信息。详细信息，请参阅每种类型的中间件的 API。</p>
<h4 id="错误处理-1"><a href="#错误处理-1" class="headerlink" title="错误处理"></a>错误处理</h4><p>对于同步中间件（从不产生事件循环），hubot 会自动捕获错误并发出<code>error</code>事件，就像标准的监听器一样。Hubot 还将自动调用最近<code>done</code>的回调以解除中间件堆栈。异步中间件应补捕获自己的异常，发出<code>error</code>事件，并调用<code>done</code>。任何未捕获的异常都会中断所有中间件完成回调的执行。</p>
<h3 id="Listener-中间件"><a href="#Listener-中间件" class="headerlink" title="Listener 中间件"></a>Listener 中间件</h3><p>Listener 中间件在匹配消息的监听器和监听器执行之间插入逻辑。这允许您创建为每个匹配脚本运行的扩展。示例包括集中授权策略、限速、记录和指标。中间件像其他 hubot 脚本一样实现：中间件不是使用<code>hear</code>和<code>respond</code>方法，而是通过<code>listenerMiddleware</code>注册。</p>
<h4 id="Listener-中间件示例"><a href="#Listener-中间件示例" class="headerlink" title="Listener 中间件示例"></a>Listener 中间件示例</h4><p>在<a href="https://github.com/michaelansel/hubot-rate-limit/blob/master/src/rate-limit.coffee">hubot-rate-limit</a>中可以找到一个功能齐全的例子。</p>
<p>一个中间件logging命令执行的简单示例：</p>
<figure class="highlight coffee"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.<span class="built_in">exports</span> = <span class="function"><span class="params">(robot)</span> -&gt;</span></span><br><span class="line">  robot.listenerMiddleware (context, next, done) -&gt;</span><br><span class="line">    <span class="comment"># Log commands</span></span><br><span class="line">    robot.logger.info <span class="string">&quot;<span class="subst">#&#123;context.response.message.user.name&#125;</span> asked me to <span class="subst">#&#123;context.response.message.text&#125;</span>&quot;</span></span><br><span class="line">    <span class="comment"># Continue executing middleware</span></span><br><span class="line">    next()</span><br></pre></td></tr></table></figure>

<p>在此示例，将为与监听器匹配的每个聊天消息写入日志消息。</p>
<p>做出限速决策的更复杂示例：</p>
<figure class="highlight coffee"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.<span class="built_in">exports</span> = <span class="function"><span class="params">(robot)</span> -&gt;</span></span><br><span class="line">  <span class="comment"># Map of listener ID to last time it was executed</span></span><br><span class="line">  lastExecutedTime = &#123;&#125;</span><br><span class="line"></span><br><span class="line">  robot.listenerMiddleware (context, next, done) -&gt;</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">      <span class="comment"># Default to 1s unless listener provides a different minimum period</span></span><br><span class="line">      minPeriodMs = context.listener.options?.rateLimits?.minPeriodMs? <span class="keyword">or</span> <span class="number">1000</span></span><br><span class="line"></span><br><span class="line">      <span class="comment"># See if command has been executed recently</span></span><br><span class="line">      <span class="keyword">if</span> lastExecutedTime.hasOwnProperty(context.listener.options.id) <span class="keyword">and</span></span><br><span class="line">         lastExecutedTime[context.listener.options.id] &gt; <span class="built_in">Date</span>.now() - minPeriodMs</span><br><span class="line">        <span class="comment"># Command is being executed too quickly!</span></span><br><span class="line">        done()</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        next -&gt;</span><br><span class="line">          lastExecutedTime[context.listener.options.id] = <span class="built_in">Date</span>.now()</span><br><span class="line">          done()</span><br><span class="line">    <span class="keyword">catch</span> err</span><br><span class="line">      robot.emit(<span class="string">&#x27;error&#x27;</span>, err, context.response)</span><br></pre></td></tr></table></figure>

<p>在这个例子中，中间件检查监听器是否在过去1000ms中执行过。如果有，中间件立马调用<code>done</code>，防止监听器回调被调用。如果监听器允许被执行，中间件附加一个<code>done</code>处理器，以便它可以记录监听器完成执行的时间。</p>
<p>此示例还显示了如何利用特定于监听器的元数据创建非常强大的扩展：脚本开发人员只需添加中间件并设置监听器选项，即可使用速率限制中间件去以不同速率轻松率限制命令。</p>
<figure class="highlight coffee"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.<span class="built_in">exports</span> = <span class="function"><span class="params">(robot)</span> -&gt;</span></span><br><span class="line">  robot.hear <span class="regexp">/hello/</span>, id: <span class="string">&#x27;my-hello&#x27;</span>, rateLimits: &#123;minPeriodMs: <span class="number">10000</span>&#125;, <span class="function"><span class="params">(msg)</span> -&gt;</span></span><br><span class="line">    <span class="comment"># This will execute no faster than once every ten seconds</span></span><br><span class="line">    msg.reply <span class="string">&#x27;Why, hello there!&#x27;</span></span><br></pre></td></tr></table></figure>

<h4 id="Listener-中间件-API"><a href="#Listener-中间件-API" class="headerlink" title="Listener 中间件 API"></a>Listener 中间件 API</h4><p>Listener 中间件回调接收三个参数，<code>context</code>、<code>next</code>、<code>done</code>。有关<code>next</code>和<code>done</code>的描述，查看<a href="https://hubot.github.com/docs/scripting/#execution-process-and-api">中间件API</a>。Listener 中间件上下文包含这些字段：</p>
<ul>
<li><code>listener</code><ul>
<li><code>options</code>：定义监听器时设置的一个简单的包含选项的对象。查看<a href="https://hubot.github.com/docs/scripting/#listener-metadata">监听器元数据</a>。</li>
<li>所有其他属性应视为内部属性。</li>
</ul>
</li>
<li><code>response</code><ul>
<li>标准response API 的所有部分都包含在中间件 API 中。查看<a href="https://hubot.github.com/docs/scripting/#send--reply">发送和回复</a>。</li>
<li>中间件可以用其他信息装饰（但不修改）响应对象（e.g. 例如将携带用户的 LDAP 组的属性添加到<code>response.message.user</code>）</li>
<li>注意：文本消息（<code>response.message.text</code>）在监听器中间件中应该被认为是不可变的。</li>
</ul>
</li>
</ul>
<h3 id="Receive-中间件"><a href="#Receive-中间件" class="headerlink" title="Receive 中间件"></a>Receive 中间件</h3><p>在任何监听器之行之前 Receive 中间件运行。它适用于尚未更新的黑名单命令以添加 ID、指标等。</p>
<h4 id="Receive-中间件示例"><a href="#Receive-中间件示例" class="headerlink" title="Receive 中间件示例"></a>Receive 中间件示例</h4><p>这个简单的中间件禁止特定用户使用 hubot，包括<code>hear</code>监听器。如果用户尝试明确地运行命令，它将返回错误消息。</p>
<figure class="highlight coffee"><table><tr><td class="code"><pre><span class="line">BLACKLISTED_USERS = [</span><br><span class="line">  <span class="string">&#x27;12345&#x27;</span> <span class="comment"># Restrict access for a user ID for a contractor</span></span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">robot.receiveMiddleware (context, next, done) -&gt;</span><br><span class="line">  <span class="keyword">if</span> context.response.message.user.id <span class="keyword">in</span> BLACKLISTED_USERS</span><br><span class="line">    <span class="comment"># Don&#x27;t process this message further.</span></span><br><span class="line">    context.response.message.finish()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># If the message starts with &#x27;hubot&#x27; or the alias pattern, this user was</span></span><br><span class="line">    <span class="comment"># explicitly trying to run a command, so respond with an error message.</span></span><br><span class="line">    <span class="keyword">if</span> context.response.message.text?.match(robot.respondPattern(<span class="string">&#x27;&#x27;</span>))</span><br><span class="line">      context.response.reply <span class="string">&quot;I&#x27;m sorry @<span class="subst">#&#123;context.response.message.user.name&#125;</span>, but I&#x27;m configured to ignore your commands.&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Don&#x27;t process further middleware.</span></span><br><span class="line">    done()</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    next(done)</span><br></pre></td></tr></table></figure>

<h4 id="Receive-中间件-API"><a href="#Receive-中间件-API" class="headerlink" title="Receive 中间件 API"></a>Receive 中间件 API</h4><p>Receive 中间件回调接收三个参数，<code>context</code>、<code>next</code>、<code>done</code>。有关<code>next</code>和<code>done</code>的描述，请参阅<a href="https://hubot.github.com/docs/scripting/#execution-process-and-api">中间件 API</a>。Receive 中间件上下文包括这些字段：</p>
<ul>
<li><code>response</code><ul>
<li>response 对象没有<code>match</code>对象，因为还没有监听器运行。</li>
<li>中间件可能通过附加信息（e.g. 添加一个携带用户的LDAP组的属性到<code>response.message.user </code>）来修饰response 对象。</li>
<li>中间件可能修改<code>response.message</code>对象。</li>
</ul>
</li>
</ul>
<h3 id="Response-中间件"><a href="#Response-中间件" class="headerlink" title="Response 中间件"></a>Response 中间件</h3><p>Response 中间件与 hubot 发送到聊天室的每个消息背道而驰。它有助于消息格式化、防止密码泄露、度量等。</p>
<h4 id="Response-中间件示例"><a href="#Response-中间件示例" class="headerlink" title="Response 中间件示例"></a>Response 中间件示例</h4><p>此简单示例将发送到聊天室的链接格式从markdown链接（如<a href="https://example.com/">示例</a>）更改为 <a href="https://slack.com/">Slack</a> 支持的格式，<a href="https://example.com|示例./">https://example.com|示例。</a></p>
<figure class="highlight coffee"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.<span class="built_in">exports</span> = <span class="function"><span class="params">(robot)</span> -&gt;</span></span><br><span class="line">  robot.responseMiddleware (context, next, done) -&gt;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">unless</span> context.plaintext?</span><br><span class="line">    context.strings = (string.replace(<span class="regexp">/\[([^\[\]]*?)\]\((https?:\/\/.*?)\)/</span>, <span class="string">&quot;&lt;$2|$1&gt;&quot;</span>) <span class="keyword">for</span> string <span class="keyword">in</span> context.strings)</span><br><span class="line">    next()</span><br></pre></td></tr></table></figure>

<h4 id="Response-中间件-API"><a href="#Response-中间件-API" class="headerlink" title="Response 中间件 API"></a>Response 中间件 API</h4><p>Response 中间件回调接收三个参数，<code>context</code>、<code>next</code>、<code>done</code>。请参阅中间件 API 以了解<code>next</code>和<code>done</code>。Receive 中间件的上下文包括这些字段：</p>
<ul>
<li><code>response</code><ul>
<li>此响应对象可用于从中间件发送新消息。在这些新响应中，将调用中间件。小心不要创建无限循环。</li>
</ul>
</li>
<li><code>strings</code><ul>
<li>一个字符串数组被发送到聊天室适配器。您可以编辑这些，或者使用<code>context.strings = [&quot;new strings&quot;]</code>去替代它们。</li>
</ul>
</li>
<li><code>method</code><ul>
<li>表示监听器发送的响应消息类型的字符串，例如<code>send</code>、<code>reply</code>、<code>emot</code>或者<code>topic</code>。</li>
</ul>
</li>
<li><code>plaintext</code><ul>
<li><code>true</code>或者<code>undefined</code>。这将被设置为<code>true</code>，如果消息是正常的纯文本类型，例如<code>send</code>和<code>reply</code>。此属性应被视为仅读。</li>
</ul>
</li>
</ul>
<h3 id="测试-hubot-脚本"><a href="#测试-hubot-脚本" class="headerlink" title="测试 hubot 脚本"></a>测试 hubot 脚本</h3><p><a href="https://github.com/mtsmfm/hubot-test-helper">hubot-test-helper</a>是一个用来单元测试hubot脚本的好框架。（请注意，为了使用 <code>hubot-test-helper,</code>，您需要一个支持Promises的最近Node版本。）</p>
<p>在 Hubot 实例中安装包：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ npm install hubot-test-helper --save-dev</span><br></pre></td></tr></table></figure>

<p>您还需要安装：</p>
<ul>
<li>一个JavaScript测试框架，例如<em>Mocha</em></li>
<li>一个断言库，例如<em>chai</em>或者<em>expect.js</em></li>
</ul>
<p>您或许还想安装：</p>
<ul>
<li><em>coffee-script</em>（如果您用CoffeeScript写您的测试而不是JavaScript）</li>
<li>一个mocking库例如<em>Sinon.js</em>（如果您的脚本执行网络请求或其他异步操作）</li>
</ul>
<p>下面是一个示例脚本，测试 <a href="https://github.com/github/generator-hubot/blob/master/generators/app/templates/scripts/example.coffee">Hubot 示例脚本</a>中的前几个命令。这个脚本使用<em>Mocha</em>、<em>chai</em>、<em>coffeescript</em>，当然还有<em>hubot-test-helper</em>。</p>
<p><strong>test/example-test.coffee</strong></p>
<figure class="highlight coffee"><table><tr><td class="code"><pre><span class="line">Helper = <span class="built_in">require</span>(<span class="string">&#x27;hubot-test-helper&#x27;</span>)</span><br><span class="line">chai = <span class="built_in">require</span> <span class="string">&#x27;chai&#x27;</span></span><br><span class="line"></span><br><span class="line">expect = chai.expect</span><br><span class="line"></span><br><span class="line">helper = <span class="keyword">new</span> Helper(<span class="string">&#x27;../scripts/example.coffee&#x27;</span>)</span><br><span class="line"></span><br><span class="line">describe <span class="string">&#x27;example script&#x27;</span>, <span class="function">-&gt;</span></span><br><span class="line">  beforeEach -&gt;</span><br><span class="line">    @room = helper.createRoom()</span><br><span class="line"></span><br><span class="line">  afterEach -&gt;</span><br><span class="line">    @room.destroy()</span><br><span class="line"></span><br><span class="line">  it <span class="string">&#x27;doesn\&#x27;t need badgers&#x27;</span>, <span class="function">-&gt;</span></span><br><span class="line">    @room.user.say(<span class="string">&#x27;alice&#x27;</span>, <span class="string">&#x27;did someone call for a badger?&#x27;</span>).<span class="keyword">then</span> =&gt;</span><br><span class="line">      expect(@room.messages).to.eql [</span><br><span class="line">        [<span class="string">&#x27;alice&#x27;</span>, <span class="string">&#x27;did someone call for a badger?&#x27;</span>]</span><br><span class="line">        [<span class="string">&#x27;hubot&#x27;</span>, <span class="string">&#x27;Badgers? BADGERS? WE DON\&#x27;T NEED NO STINKIN BADGERS&#x27;</span>]</span><br><span class="line">      ]</span><br><span class="line"></span><br><span class="line">  it <span class="string">&#x27;won\&#x27;t open the pod bay doors&#x27;</span>, <span class="function">-&gt;</span></span><br><span class="line">    @room.user.say(<span class="string">&#x27;bob&#x27;</span>, <span class="string">&#x27;@hubot open the pod bay doors&#x27;</span>).<span class="keyword">then</span> =&gt;</span><br><span class="line">      expect(@room.messages).to.eql [</span><br><span class="line">        [<span class="string">&#x27;bob&#x27;</span>, <span class="string">&#x27;@hubot open the pod bay doors&#x27;</span>]</span><br><span class="line">        [<span class="string">&#x27;hubot&#x27;</span>, <span class="string">&#x27;@bob I\&#x27;m afraid I can\&#x27;t let you do that.&#x27;</span>]</span><br><span class="line">      ]</span><br><span class="line"></span><br><span class="line">  it <span class="string">&#x27;will open the dutch doors&#x27;</span>, <span class="function">-&gt;</span></span><br><span class="line">    @room.user.say(<span class="string">&#x27;bob&#x27;</span>, <span class="string">&#x27;@hubot open the dutch doors&#x27;</span>).<span class="keyword">then</span> =&gt;</span><br><span class="line">      expect(@room.messages).to.eql [</span><br><span class="line">        [<span class="string">&#x27;bob&#x27;</span>, <span class="string">&#x27;@hubot open the dutch doors&#x27;</span>]</span><br><span class="line">        [<span class="string">&#x27;hubot&#x27;</span>, <span class="string">&#x27;@bob Opening dutch doors&#x27;</span>]</span><br><span class="line">      ]</span><br></pre></td></tr></table></figure>

<p><strong>输出示例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ mocha --compilers &quot;coffee:coffee-script/register&quot; test/*.coffee</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  example script</span><br><span class="line">    ✓ doesn&#x27;t need badgers</span><br><span class="line">    ✓ won&#x27;t open the pod bay doors</span><br><span class="line">    ✓ will open the dutch doors</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  3 passing (212ms)</span><br></pre></td></tr></table></figure>

<h2 id="模式-1"><a href="#模式-1" class="headerlink" title="模式"></a>模式</h2><p>用共享模式处理常见hubot场景。</p>
<h3 id="重命名hubot实例"><a href="#重命名hubot实例" class="headerlink" title="重命名hubot实例"></a>重命名hubot实例</h3><p>当您重命名hubot时，他将不再回应他以前的名字。为了训练用户使用新名称，您可以选择在用户尝试说出旧名称时添加弃用通知。这里的模式逻辑是：</p>
<ul>
<li>收听所有以旧名称开头的消息</li>
<li>回复用户，让他们知道新名称</li>
</ul>
<p>设置这个非常简单：</p>
<ol>
<li>在您的 hubot 实例的<code>scripts/</code>目录下创建一个<a href="https://hubot.github.com/docs/scripting/">捆绑脚本</a>，叫<code>rename-hubot.coffee</code></li>
<li>添加以下代码，根据您的需要修改：</li>
</ol>
<figure class="highlight coffee"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Description:</span></span><br><span class="line"><span class="comment">#   Tell people hubot&#x27;s new name if they use the old one</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Commands:</span></span><br><span class="line"><span class="comment">#   None</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="built_in">module</span>.<span class="built_in">exports</span> = <span class="function"><span class="params">(robot)</span> -&gt;</span></span><br><span class="line">  robot.hear <span class="regexp">/^hubot:? (.+)/i</span>, <span class="function"><span class="params">(res)</span> -&gt;</span></span><br><span class="line">    response = <span class="string">&quot;Sorry, I&#x27;m a diva and only respond to <span class="subst">#&#123;robot.name&#125;</span>&quot;</span></span><br><span class="line">    response += <span class="string">&quot; or <span class="subst">#&#123;robot.alias&#125;</span>&quot;</span> <span class="keyword">if</span> robot.alias</span><br><span class="line">    res.reply response</span><br><span class="line">    <span class="keyword">return</span></span><br></pre></td></tr></table></figure>

<p>在上述模式中，修改 hubot 监听器和响应消息以满足您的需求。</p>
<p>此外，请务必注意，监听器应该基于 hubot 实际听到的内容，而不是在 hubot 适配器处理之前键入到聊天程序中的内容。例如，<a href="https://github.com/hipchat/hubot-hipchat">HipChat Adapter</a>转换<code>@hubot</code>为<code>hubot:</code>在传递给hubot之前。</p>
<h3 id="弃用或重命名监听器"><a href="#弃用或重命名监听器" class="headerlink" title="弃用或重命名监听器"></a>弃用或重命名监听器</h3><p>如果您删除脚本或更改了脚本的命令，让用户知道更改可能会有用。一种方式是在聊天中告诉他们，或者让他们通过尝试使用不再存在的命令来发现变化。另一种方式是使 Hubot 让人们知道他们何时使用了不再工作的命令。</p>
<p>此模式类似于上述重命名 Hubot 实例模式：</p>
<ul>
<li>收听与旧命令匹配的所有消息</li>
<li>回复用户，让他们知道，它已被弃用</li>
</ul>
<p>设置如下：</p>
<ol>
<li>在hubot实例的<code>scripts/</code>目录下创建一个叫<code>deprecations.coffee</code>的<a href="https://hubot.github.com/docs/scripting/">捆绑脚本</a></li>
<li>复制一切旧的命令监听器，并将其添加到该文件中。例如，如果您出于某种糊涂的原因重新命名帮助命令：<figure class="highlight coffee"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Description:</span></span><br><span class="line"><span class="comment">#   Tell users when they have used commands that are deprecated or renamed</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Commands:</span></span><br><span class="line"><span class="comment">#   None</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="built_in">module</span>.<span class="built_in">exports</span> = <span class="function"><span class="params">(robot)</span> -&gt;</span></span><br><span class="line">  robot.respond <span class="regexp">/help\s*(.*)?$/i</span>, <span class="function"><span class="params">(res)</span> -&gt;</span></span><br><span class="line">    res.reply <span class="string">&quot;That means nothing to me anymore. Perhaps you meant `docs` instead?&quot;</span></span><br><span class="line">    <span class="keyword">return</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="通过代理转发所有-HTTP-请求"><a href="#通过代理转发所有-HTTP-请求" class="headerlink" title="通过代理转发所有 HTTP 请求"></a>通过代理转发所有 HTTP 请求</h3><p>在许多企业环境中，访问互联网和（或）受保护的资源需要网络代理。对于一次性的控制，可以指定一个<a href="https://nodejs.org/api/http.html">Agent</a>与<code>robot.http</code>一起使用。但是，这需要修改您的机器人用于指向代理的每个脚本。相反，您可以在全局层次指定代理，并默认使所有 HTTP 请求使用代理。</p>
<p>由于 node.js 处理 HTTP 和 HTTPS 请求的方式，您需要为每一种协议指定一个不同的 Agent。ScopedHTTPClient 将自动的选择正确的 ProxyAgent 为每种请求。</p>
<ol>
<li>安装 ProxyAgent。<code>npm install proxy-agent</code></li>
<li>在您的 hubot 实例的<code>scripts/</code>目录下创建一个<a href="https://hubot.github.com/docs/scripting/">捆绑脚本</a></li>
<li>添加后面的代码，并按需修改：</li>
</ol>
<figure class="highlight coffee"><table><tr><td class="code"><pre><span class="line">proxy = <span class="built_in">require</span> <span class="string">&#x27;proxy-agent&#x27;</span></span><br><span class="line"><span class="built_in">module</span>.<span class="built_in">exports</span> = <span class="function"><span class="params">(robot)</span> -&gt;</span></span><br><span class="line">  robot.globalHttpOptions.httpAgent  = proxy(<span class="string">&#x27;http://my-proxy-server.internal&#x27;</span>, <span class="literal">false</span>)</span><br><span class="line">  robot.globalHttpOptions.httpsAgent = proxy(<span class="string">&#x27;http://my-proxy-server.internal&#x27;</span>, <span class="literal">true</span>)</span><br></pre></td></tr></table></figure>

<h3 id="消息的动态匹配"><a href="#消息的动态匹配" class="headerlink" title="消息的动态匹配"></a>消息的动态匹配</h3><p>在某些情况下，您希望动态匹配不同的消息（e.g. factoids, JIRA projects）。而不是定义一个过于宽泛的总是匹配的正则表达，您可以告诉 hubot 只有在满足某些条件时才匹配。</p>
<p>在一个简单的机器人中，这与仅仅把条件放在监听器回调中没什么不同，但是在处理中间件时却有很大的不同：用基本的模型，正则表达式每次匹配中间件将执行。用这个动态匹配模型，中间件仅当动态条件匹配时执行。</p>
<p>例如，<a href="https://github.com/github/hubot-scripts/blob/bd810f99f9394818a9dcc2ea3729427e4101b96d/src/scripts/factoid.coffee#L95-L99">factoid lookup command</a>可以被重新实现为：</p>
<figure class="highlight coffee"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.<span class="built_in">exports</span> = <span class="function"><span class="params">(robot)</span> -&gt;</span></span><br><span class="line">  <span class="comment"># Dynamically populated list of factoids</span></span><br><span class="line">  facts =</span><br><span class="line">    fact1: <span class="string">&#x27;stuff&#x27;</span></span><br><span class="line">    fact2: <span class="string">&#x27;other stuff&#x27;</span></span><br><span class="line"></span><br><span class="line">  robot.listen(</span><br><span class="line">    <span class="comment"># Matcher</span></span><br><span class="line">    (message) -&gt;</span><br><span class="line">      match = message.match(<span class="regexp">/^~(.*)$/</span>)</span><br><span class="line">      <span class="comment"># Only match if there is a matching factoid</span></span><br><span class="line">      <span class="keyword">if</span> match <span class="keyword">and</span> match[<span class="number">1</span>] <span class="keyword">in</span> facts</span><br><span class="line">        match[<span class="number">1</span>]</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        <span class="literal">false</span></span><br><span class="line">    <span class="comment"># Callback</span></span><br><span class="line">    (response) -&gt;</span><br><span class="line">      fact = response.match</span><br><span class="line">      res.reply <span class="string">&quot;<span class="subst">#&#123;fact&#125;</span> is <span class="subst">#&#123;facts[fact]&#125;</span>&quot;</span></span><br><span class="line">  )</span><br></pre></td></tr></table></figure>

<h3 id="限制命令访问"><a href="#限制命令访问" class="headerlink" title="限制命令访问"></a>限制命令访问</h3><p>Hubot 的一个了不起的特色是它能够通过一条聊天消息改变生产环境。但是，并非每个访问您的聊天服务的人都能够触发生产环境改变。</p>
<p>有多种不同的模式来限制访问，您可以根据您的需求来选择：</p>
<ul>
<li>两个访问 buckets：完整的和用黑白名单限制的</li>
<li>为每个命令定制访问规则（基于角色的权限控制）</li>
<li>特定房间的黑白名单命令</li>
</ul>
<h4 id="简单的每个监听器访问"><a href="#简单的每个监听器访问" class="headerlink" title="简单的每个监听器访问"></a>简单的每个监听器访问</h4><p>在某些组织中，几乎所有员工都获得了相同级别的访问权限，只有少数员工需要受到限制（e.g. 新员工，外包员工等）。在这种模式下，您划分所有监听器集合，将“权力命令（power commands）”与“常规命令（normal commands）”分开。</p>
<p>一旦您将监听器分开了，您需要围绕黑白名单用户和监听器做出一些权衡。</p>
<p>选择用户白名单模式与用户黑名单模式的关键因素是：每个类别中的用户数量、任一类别的变化频率以及您的组织愿意接受的安全风险级别。</p>
<ul>
<li>白名单用户模式（用户X、Y、Z有权访问权力命令；所有的其他用户只能访问常规命令）是一种更安全的访问方法（新用户没有默认的权限去执行权力命令），但有更高的维护成本（您需要将每个新用户添加到”审批”列表中）</li>
<li>黑名单用户模式（所有的用户都可以执行权力命令，除了用户X、Y、Z只能访问常规命令）是一种不太安全的方法（新的用户默认有权执行权力命令除非他们被加入了黑名单），却有较低的维护成本，在黑名单是小或者很少改变的情况下。</li>
</ul>
<p>决定使用选择性的允许监听器和限制监听器的关键因素是：在每个分类中监听器的数量、内部和外部脚本的比例以及您的组织愿意接受的安全风险级别。</p>
<ul>
<li>选择性的允许监听器（所有的监听器都是权力命令，除了监听器A、B、C被视为常规命令）是更安全的（新的监听器默认被限制），但维护成本却高得多（每个愚蠢/有趣的监听器需要被明确的降级到“常规”状态）。</li>
<li>选择性的限制监听器（监听器A、B、C是权力命令，其它的都是常规命令）是安全性更差的一种方式（新的监听器默认被放进常规分类，它能够被意想不到的访问；外部脚本在这里特别可怕），不过有更低的维护成本（无需修改/列举访问策略中的所有fun/culture脚本）。</li>
</ul>
<p>作为额外的考虑，大多数脚本目前没有监听器 ID，因此您可能需要打开您使用的外部脚本的 PRs（或 fork）来添加监听器 ID。实际修改很容易，但与许多维护人员协调可能很费时。</p>
<p>一旦您决定遵循这四种模型的某一种，您需要构建适当的用户和监听器列表，以插入到您的授权中间件。</p>
<p>例如：用白名单用户模式去选择性的限制权力命令。</p>
<figure class="highlight coffee"><table><tr><td class="code"><pre><span class="line">POWER_COMMANDS = [</span><br><span class="line">  <span class="string">&#x27;deploy.web&#x27;</span> <span class="comment"># String that matches the listener ID</span></span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">POWER_USERS = [</span><br><span class="line">  <span class="string">&#x27;jdoe&#x27;</span> <span class="comment"># String that matches the user ID set by the adapter</span></span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.<span class="built_in">exports</span> = <span class="function"><span class="params">(robot)</span> -&gt;</span></span><br><span class="line">  robot.listenerMiddleware (context, next, done) -&gt;</span><br><span class="line">    <span class="keyword">if</span> context.listener.options.id <span class="keyword">in</span> POWER_COMMANDS</span><br><span class="line">      <span class="keyword">if</span> context.response.message.user.id <span class="keyword">in</span> POWER_USERS</span><br><span class="line">        <span class="comment"># User is allowed access to this command</span></span><br><span class="line">        next()</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        <span class="comment"># Restricted command, but user isn&#x27;t in whitelist</span></span><br><span class="line">        context.response.reply <span class="string">&quot;I&#x27;m sorry, @<span class="subst">#&#123;context.response.message.user.name&#125;</span>, but you don&#x27;t have access to do that.&quot;</span></span><br><span class="line">        done()</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="comment"># This is not a restricted command; allow everyone</span></span><br><span class="line">      next()</span><br></pre></td></tr></table></figure>

<p>记住所有匹配给定消息的监听器（包括<code>robot.hear /.+/</code>）执行的中间件，在对监听器进行分类时，请确保包含它们。</p>
<h4 id="每个监听器特定的访问规则"><a href="#每个监听器特定的访问规则" class="headerlink" title="每个监听器特定的访问规则"></a>每个监听器特定的访问规则</h4><p>对于较大的组织，访问的二元分类通常是不够的，需要更复杂的访问规则。</p>
<p>访问策略示例：</p>
<ul>
<li>每个开发团队都有权编译处于某个状态的代码(cut releases)并部署其服务</li>
<li>运营组有权部署所有服务（但是不能 cut releases）</li>
<li>前台无法cut releases或部署服务</li>
</ul>
<p>像这样的复杂政策目前最好直接在代码中实现，尽管这是<a href="https://github.com/michaelansel/hubot-rbac">正在进行中的工作</a>为访问管理建立一个通用的框架。</p>
<h4 id="每个房间特定的访问规则"><a href="#每个房间特定的访问规则" class="headerlink" title="每个房间特定的访问规则"></a>每个房间特定的访问规则</h4><p>拥有多个不同用途的聊天室的组织通常希望能够使用相同的 hubot 实例，但每个房间允许使用不同的命令集。</p>
<p>广泛的黑名单的解决方案<a href="https://github.com/kristenmills/hubot-command-blacklist">正在进行中</a>。白名单的解决方案可以采取类似的方法。</p>
<h2 id="适配器-1"><a href="#适配器-1" class="headerlink" title="适配器"></a>适配器</h2><p>适配器是您希望 hubot 所运行的服务的界面。</p>
<p>Hubot 包含两个官方的适配器：</p>
<ul>
<li><a href="https://hubot.github.com/docs/adapters/shell/">Shell</a>，用于开发</li>
<li><a href="https://hubot.github.com/docs/adapters/campfire/">Campfire</a> </li>
</ul>
<p>对于大多数聊天服务，有许多第三方适配器。这是其中最受欢迎的一些：</p>
<ul>
<li><a href="https://github.com/huafu/hubot-gitter2">Gitter</a></li>
<li><a href="https://github.com/hipchat/hubot-hipchat">HipChat</a></li>
<li><a href="https://github.com/nandub/hubot-irc">IRC</a></li>
<li><a href="https://github.com/RocketChat/hubot-rocketchat">Rocket.Chat</a></li>
<li><a href="https://github.com/slackhq/hubot-slack">Slack</a></li>
<li><a href="https://github.com/markstory/hubot-xmpp">XMPP</a></li>
</ul>
<p>浏览所有的仓库通过<a href="https://github.com/search?q=topic:hubot-adapter&type=Repositories">在 Github 上的 <code>hubot-adapter</code> topic</a> 或者<a href="https://www.npmjs.com/search?q=hubot%20adapter&ranking=popularity">在 NPM 上搜索适配器</a>。添加<code>hubot-adapter</code> <a href="https://help.github.com/articles/classifying-your-repository-with-topics/">topic</a>到您Github上的个人仓库，以将其包含在此列表中。</p>
<h3 id="编写您自己的适配器"><a href="#编写您自己的适配器" class="headerlink" title="编写您自己的适配器"></a>编写您自己的适配器</h3><p>有兴趣添加自己的适配器？查看我们用于<a href="https://hubot.github.com/docs/adapters/development/">开发适配器</a>的文档。</p>
<h3 id="Campfire-适配器"><a href="#Campfire-适配器" class="headerlink" title="Campfire 适配器"></a>Campfire 适配器</h3><p><a href="http://campfirenow.com/">Campfire</a>是一个由<a href="http://37signals.com/">37signals</a>构建的基于 web 的聊天应用。Campfire 是 hubot 的一个原装适配器。</p>
<h4 id="起步"><a href="#起步" class="headerlink" title="起步"></a>起步</h4><p>您将需要一个Campfire帐户来开始，你可以<a href="https://signup.37signals.com/campfire/free/signup/new">免费注册</a>。</p>
<p>下一步，你需要为你的 hubot 在 Campfire 账户上创建一个用户，然后给它访问权限，以便它可以加入您的房间。如果您尚未创建房间，则需要创建一个房间。</p>
<p>Hubot 默认使用它的 <a href="https://hubot.github.com/docs/adapters/shell/">shell</a>，用 Campfire 替代，你需要带上 <code>-a campfire</code> 运行 hubot：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> bin/hubot -a campfire</span></span><br></pre></td></tr></table></figure>

<p>如果你部署到 Heroku 或者使用 foreman，你需要确保在 <code>Procfile</code> 中携带<code>-a campfire</code> 被调用：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">web: bin/hubot -a campfire -n Hubot</span><br></pre></td></tr></table></figure>

<h4 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h4><p>适配器需要以下环境变量：</p>
<ul>
<li><code>HUBOT_CAMPFIRE_ACCOUNT</code></li>
<li><code>HUBOT_CAMPFIRE_TOKEN</code></li>
<li><code>HUBOT_CAMPFIRE_ROOMS</code></li>
</ul>
<h5 id="Campfire-API-令牌"><a href="#Campfire-API-令牌" class="headerlink" title="Campfire API 令牌"></a>Campfire API 令牌</h5><p>这可以通过登录您的 hubot 的帐户，点击 <code>My Info</code> 链接来找到， 并记下 API 令牌。</p>
<h5 id="Campfire-房间号"><a href="#Campfire-房间号" class="headerlink" title="Campfire 房间号"></a>Campfire 房间号</h5><p>如果你加入了你希望你的hubot加入的房间，你可以看见在URL中的房间的数字 ID。记下你想你的 hubot 加入的每个房间 ID。</p>
<h5 id="Campfire-账户"><a href="#Campfire-账户" class="headerlink" title="Campfire 账户"></a>Campfire 账户</h5><p>这只是您访问 Campfire 帐户的域名的第一部分。例如，如果您的 Campfire 是<code>hubot.campfirenow.com</code>，你的二级域名是<code>hubot</code>。记下这个二级域名。</p>
<h5 id="在-Heroku-上配置环境变量"><a href="#在-Heroku-上配置环境变量" class="headerlink" title="在 Heroku 上配置环境变量"></a>在 Heroku 上配置环境变量</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> heroku config:<span class="built_in">set</span> HUBOT_CAMPFIRE_TOKEN=<span class="string">&quot;...&quot;</span></span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> heroku config:<span class="built_in">set</span> HUBOT_CAMPFIRE_ROOMS=<span class="string">&quot;123,321&quot;</span></span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> heroku config:<span class="built_in">set</span> HUBOT_CAMPFIRE_ACCOUNT=<span class="string">&quot;...&quot;</span></span></span><br></pre></td></tr></table></figure>

<h5 id="在-Unix-上配置环境变量"><a href="#在-Unix-上配置环境变量" class="headerlink" title="在 Unix 上配置环境变量"></a>在 Unix 上配置环境变量</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">export</span> HUBOT_CAMPFIRE_TOKEN=<span class="string">&quot;...&quot;</span></span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">export</span> HUBOT_CAMPFIRE_ROOMS=<span class="string">&quot;123,321&quot;</span></span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">export</span> HUBOT_CAMPFIRE_ACCOUNT=<span class="string">&quot;...&quot;</span></span></span><br></pre></td></tr></table></figure>

<h5 id="在-Windows-上配置环境变量"><a href="#在-Windows-上配置环境变量" class="headerlink" title="在 Windows 上配置环境变量"></a>在 Windows 上配置环境变量</h5><p>使用 PowerShell：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">setx HUBOT_CAMPFIRE_TOKEN &quot;...&quot; /m</span><br><span class="line"></span><br><span class="line">setx HUBOT_CAMPFIRE_ROOMS &quot;123,321&quot; /m</span><br><span class="line"></span><br><span class="line">setx HUBOT_CAMPFIRE_ACCOUNT &quot;...&quot; /m</span><br></pre></td></tr></table></figure>

<h3 id="Shell-适配器"><a href="#Shell-适配器" class="headerlink" title="Shell 适配器"></a>Shell 适配器</h3><p>Shell 适配器提供一个简单的读取打印循环，用于与本地 hubot 进行交互。它可用于在hubot 上使用脚本之前测试脚本。</p>
<h4 id="起步-1"><a href="#起步-1" class="headerlink" title="起步"></a>起步</h4><p>要使用外壳适配器，您可以在运行 hubot 时简单地省略 -a 选项，因为它默认会使用 Shell 适配器。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> bin/hubot</span></span><br></pre></td></tr></table></figure>

<h4 id="配置-1"><a href="#配置-1" class="headerlink" title="配置"></a>配置</h4><p>这个适配器不需要任何配置。</p>
<p>它支持两个环境变量以支持作为不同的用户测试脚本：</p>
<ul>
<li>HUBOT_SHELL_USER_ID: default is 1</li>
<li>HUBOT_SHELL_USER_NAME: default is Shell</li>
</ul>
<h3 id="开发适配器"><a href="#开发适配器" class="headerlink" title="开发适配器"></a>开发适配器</h3><h4 id="适配器基础"><a href="#适配器基础" class="headerlink" title="适配器基础"></a>适配器基础</h4><p>所有适配器继承自在 <code>src/adapter.coffee</code> 文件中的适配器类。有明确的你想去重写的方法。下面是扩展适配器类的基本桩代码：</p>
<figure class="highlight coffee"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sample</span> <span class="keyword">extends</span> <span class="title">Adapter</span></span></span><br><span class="line"></span><br><span class="line">  constructor: <span class="function">-&gt;</span></span><br><span class="line">    <span class="built_in">super</span></span><br><span class="line">    @robot.logger.info <span class="string">&quot;Constructor&quot;</span></span><br><span class="line"></span><br><span class="line">  send: <span class="function"><span class="params">(envelope, strings...)</span> -&gt;</span></span><br><span class="line">    @robot.logger.info <span class="string">&quot;Send&quot;</span></span><br><span class="line"></span><br><span class="line">  reply: <span class="function"><span class="params">(envelope, strings...)</span> -&gt;</span></span><br><span class="line">    @robot.logger.info <span class="string">&quot;Reply&quot;</span></span><br><span class="line"></span><br><span class="line">  run: <span class="function">-&gt;</span></span><br><span class="line">    @robot.logger.info <span class="string">&quot;Run&quot;</span></span><br><span class="line">    @emit <span class="string">&quot;connected&quot;</span></span><br><span class="line">    user = <span class="keyword">new</span> User <span class="number">1001</span>, name: <span class="string">&#x27;Sample User&#x27;</span></span><br><span class="line">    message = <span class="keyword">new</span> TextMessage user, <span class="string">&#x27;Some Sample Message&#x27;</span>, <span class="string">&#x27;MSG-001&#x27;</span></span><br><span class="line">    @robot.receive message</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">exports</span>.use = <span class="function"><span class="params">(robot)</span> -&gt;</span></span><br><span class="line">  <span class="keyword">new</span> Sample robot</span><br></pre></td></tr></table></figure>

<h4 id="配置您的开发环境"><a href="#配置您的开发环境" class="headerlink" title="配置您的开发环境"></a>配置您的开发环境</h4><ol>
<li>为您的适配器<code>hubot-sample</code>创建一个新的文件夹。<ul>
<li><code>mkdir hubot-sample</code></li>
</ul>
</li>
<li>切换您的工作路径到<code>hubot-sample</code><ul>
<li><code>cd hubot-sample</code></li>
</ul>
</li>
<li>运行<code>npm init</code>去创建您的 package.json<ul>
<li>确保入口是<code>src/sample.coffee</code></li>
</ul>
</li>
<li>添加您的<code>.gitignore</code>去包含<code>node_modules</code>。</li>
<li>编辑 <code>src/sample.coffee</code> 文件为您的适配器去包含上述的桩代码。</li>
<li>编辑<code>package.json</code>去为hubot添加 peer 依赖。 <figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;dependencies&quot;</span>: &#123;</span><br><span class="line">&#125;,</span><br><span class="line"><span class="string">&quot;peerDependencies&quot;</span>: &#123;</span><br><span class="line">  <span class="attr">&quot;hubot&quot;</span>: <span class="string">&quot;&gt;=2.0&quot;</span></span><br><span class="line">&#125;,</span><br><span class="line"><span class="string">&quot;devDependencies&quot;</span>: &#123;</span><br><span class="line">  <span class="attr">&quot;coffee-script&quot;</span>: <span class="string">&quot;&gt;=1.2.0&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>用<code>yo hubot</code><a href="https://hubot.github.com/docs/">命令</a>生成您的hubot。</li>
<li>切换工作目录到<code>hubot</code>你在第七步创建的。</li>
<li>现在执行<code>npm link</code>去添加您的适配器到<code>hubot</code><ul>
<li><code>npm link ../hubot-sample</code></li>
</ul>
</li>
<li>运行<code>hubot -a sample</code>。</li>
</ol>
<h4 id="Gochas"><a href="#Gochas" class="headerlink" title="Gochas"></a>Gochas</h4><p>在 node 社区有一个开放的议题围绕<a href="https://github.com/npm/npm/issues/5875">npm 链接的 peer 依赖不工作</a>。要让我们的项目工作，您的代码需要做一些小的修改。</p>
<ol>
<li>引入您的 <code>hubot-sample</code> 适配器，添加下面的代码： <figure class="highlight coffee"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span></span><br><span class="line">  &#123;Robot,Adapter,TextMessage,User&#125; = <span class="built_in">require</span> <span class="string">&#x27;hubot&#x27;</span></span><br><span class="line"><span class="keyword">catch</span></span><br><span class="line">  prequire = <span class="built_in">require</span>(<span class="string">&#x27;parent-require&#x27;</span>)</span><br><span class="line">  &#123;Robot,Adapter,TextMessage,User&#125; = prequire <span class="string">&#x27;hubot&#x27;</span></span><br></pre></td></tr></table></figure></li>
<li>在您的<code>hubot-sample</code>文件夹，修改<code>package.json</code>去包含下面的依赖以至于这种自定义导入机制将起作用 <figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;dependencies&quot;</span>: &#123;</span><br><span class="line">  <span class="attr">&quot;parent-require&quot;</span>: <span class="string">&quot;^1.0.0&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>现在尝试再运行<code>hubot -a sample</code>并看到引入正常加载了。</li>
<li>一旦这工作正常，您可以根据您认为合适的情况构建适配器的功能。看看其他一些适配器，获取一些实现想法。<ul>
<li>一旦通过 <code>npm</code> 进行打包和部署，您就不再需要在 <code>hubot</code> 中的依赖性了，因为 peer 依赖应该作为官方模块工作。</li>
</ul>
</li>
</ol>
<h2 id="部署-1"><a href="#部署-1" class="headerlink" title="部署"></a>部署</h2><h3 id="部署到-Heroku"><a href="#部署到-Heroku" class="headerlink" title="部署到 Heroku"></a>部署到 Heroku</h3><p>如果你一直跟着<a href="https://hubot.github.com/docs/">官方文档</a>到了这里，是时候部署了，这样你就不仅在你的本地机器能使用它了。<a href="http://www.heroku.com/">Heroku</a>是部署hubot的最简单和支持的方式。</p>
<p>安装 <a href="https://toolbelt.heroku.com/">Heroku Toolbelt</a> 去开始，然后跟着他们的“Getting Started”操作指南，包括第一次登录：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ heroku login</span><br><span class="line">Enter your Heroku credentials.</span><br><span class="line">Email: youremail@example.com</span><br><span class="line">Password:</span><br><span class="line">Could not find an existing public key.</span><br><span class="line">Would you like to generate one? [Yn]</span><br><span class="line">Generating new SSH public key.</span><br><span class="line">Uploading ssh public key /Users/you/.ssh/id_rsa.pub</span><br></pre></td></tr></table></figure>

<p>在新的 hubot 目录中，请确保您创建了 git 仓库，并且您的代码已经被 commit：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git init</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git add .</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git commit -m <span class="string">&quot;Initial commit&quot;</span></span></span><br></pre></td></tr></table></figure>

<p>创建一个 Heroku 应用：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> heroku create</span></span><br><span class="line">Creating rosemary-britches-123... done, stack is cedar</span><br><span class="line">http://rosemary-britches-123.herokuapp.com/ | git@heroku.com:rosemary-britches-123.git</span><br><span class="line">Git remote heroku added</span><br></pre></td></tr></table></figure>

<p>在您部署应用之前，您需要配置一些环境变量，供 hubot 使用。您需要的特定变量取决于您正在使用的适配器和脚本。对于 Campfire，没有其它脚本的话，你需要去设置以下环境变量：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> heroku config:<span class="built_in">set</span> HUBOT_CAMPFIRE_ACCOUNT=yourcampfireaccount</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> heroku config:<span class="built_in">set</span> HUBOT_CAMPFIRE_TOKEN=yourcampfiretoken</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> heroku config:<span class="built_in">set</span> HUBOT_CAMPFIRE_ROOMS=comma,separated,list,of,rooms,to,join</span></span><br></pre></td></tr></table></figure>

<p>此时，您已准备好部署并开始聊天。使用 Heroku，就是执行 git push：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git push heroku master</span></span><br></pre></td></tr></table></figure>

<p>您会看到一些文本飞过，最终是成功的。此时您应该可以在您配置的聊天室，看见您的机器人。如果没有，您可以看一看日志去调试：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> heroku logs</span></span><br></pre></td></tr></table></figure>

<p>如果您对您的 hubot 做了一些改变，在 push 它们之前，commit 一下就好：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git commit -am <span class="string">&quot;Awesome scripts OMG&quot;</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git push heroku master</span></span><br></pre></td></tr></table></figure>

<p>一些脚本需要 redis 来运行，Heroku 提供一个叫 <a href="https://addons.heroku.com/rediscloud">Redis Cloud</a> 的附加装置，它是有免费计划的。使用它：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> heroku addons:create rediscloud</span></span><br></pre></td></tr></table></figure>

<p>在Heroku上的免费的dyno在<a href="https://devcenter.heroku.com/articles/dyno-sleeping">不活跃30分钟后将休眠</a>。那意味着您的hubot将离开聊天室并且仅重新加入当它获得流量。这是极度不方便的因为大多数交互都是通过聊天完成的，hubot 必须在线、在房间里回复消息。解决这个问题的一个临时方案是，你可以使用<a href="https://github.com/hubot-scripts/hubot-heroku-keepalive">hubot-heroku-keepalive</a>脚本，它可以让您免费的dyno活跃时间提升到18小时每天。如果你不想你的 hubot 休眠，你可能就需要<a href="https://www.heroku.com/pricing">升级到 Heroku 的 bobby 计划</a>。</p>
<h3 id="部署到-Unix"><a href="#部署到-Unix" class="headerlink" title="部署到 Unix"></a>部署到 Unix</h3><p>由于 Linux 的变种很多，以及 UNIX，因此 hubot 团队很难拥有规范文档，用于安装和部署到每个版本。因此，这试图概述部署所需的内容。</p>
<p>有3个主要的东西去部署和运行 hubot：</p>
<ul>
<li>node 和 npm</li>
<li>在服务器上更新源代码的方法</li>
<li>启动 hubot 的方法， 在崩溃时启动它， 并在代码更新时重新启动它</li>
</ul>
<h4 id="node-和-npm"><a href="#node-和-npm" class="headerlink" title="node 和 npm"></a>node 和 npm</h4><p>首先，您的 UNIX 服务器将需要 node 和 npm。查看node.js 的 wiki：<a href="https://github.com/joyent/node/wiki/Installing-Node.js-via-package-manager">通过包管理器安装 Node.js</a>，<a href="https://github.com/joyent/node/wiki/Installation#building-on-gnulinux-and-other-unix">在 GNU/Linux 和 其它 UNIX 上编译</a>。</p>
<h4 id="在服务器上更新代码"><a href="#在服务器上更新代码" class="headerlink" title="在服务器上更新代码"></a>在服务器上更新代码</h4><p>更新 hubot 代码的最简单方法是对 hubot 的源代码进行 git checkout（您在阅读<a href="https://hubot.github.com/docs/">官方文档</a>期间创建的源代码，而不是 github/hubot 仓库），只需 git pull 即可获取更改。这可能感觉不够优雅，但是刚开始的时候是有用的。</p>
<p>如果您有 Ruby 背景，使用 <a href="https://github.com/capistrano/capistrano">capistrano</a> 会让您感到更舒服。</p>
<p>如果您有 <a href="http://www.chef.io/chef/">Chef</a> 背景，有一个用于管理部署的<a href="https://docs.chef.io/resource_deploy.html">部署</a>资源。</p>
<h4 id="启动、停止和重启-hubot"><a href="#启动、停止和重启-hubot" class="headerlink" title="启动、停止和重启 hubot"></a>启动、停止和重启 hubot</h4><p>每个hubot安装有一个<code>bin/hubot</code>脚本来处理启动hubot。您可以在服务器上的 git checkout 处运行此命令，但是您可能会遭遇一些问题：</p>
<ul>
<li>你断开终端连接，hubot 挂掉</li>
<li>hubot 因为一些原因挂掉，不会自己重新启动</li>
<li>它不会开机自启</li>
</ul>
<p>要处理断开连接，你可以在<a href="http://www.gnu.org/software/screen/">screen session</a>中运行<code>bin/hubot</code>，或者使用<a href="http://linux.die.net/man/1/nohup">nohup</a>。</p>
<p>要处理 hubot 挂掉，和自动重启，你可以想象运行<code>bin/hubot</code>在一个<a href="http://tldp.org/HOWTO/Bash-Prog-Intro-HOWTO-7.html#ss7.3">bash while 循环</a>。但真的，你可能想要一些进程监控工具， 如 <a href="http://mmonit.com/monit/">monit</a>、<a href="http://godrb.com/">god</a>、<a href="https://github.com/arya/bluepill">bluepill</a>、<a href="http://upstart.ubuntu.com/">upstart</a>、<a href="http://smarden.org/runit/">runit</a>、 <a href="http://freedesktop.org/wiki/Software/systemd/">systemd</a>。</p>
<p>要处理开机自启，您可以创建适合 UNIX 分发的初始化脚本。如果您正在使用上面的进程监控工具之一，请确保它在启动时启动。有关配置<a href="https://github.com/github/hubot/tree/master/examples">示例</a>，请参阅示例。</p>
<h4 id="建议"><a href="#建议" class="headerlink" title="建议"></a>建议</h4><p>本文档有意淡化强烈建议。不过在高层次上，强烈建议避免任何过于手动和不可复现的东西。尽可能使用操作系统的包和工具，并使用适当的部署工具来更新 hubot，以及进程管理以保持 hubot 的运行。</p>
<h3 id="部署到-Windows"><a href="#部署到-Windows" class="headerlink" title="部署到 Windows"></a>部署到 Windows</h3><p>尚未完全测试 —— 你的历程可能有所不同（YMMV）</p>
<p>在 Windows 机器上，有四个主要的部署运行 hubot 的步骤：</p>
<ul>
<li>node 和 npm</li>
<li>在服务器上更新源代码的方法</li>
<li>为 hubot 设置环境变量</li>
<li>启动 hubot， 在崩溃时启动它，在代码更新时重新启动它的方法</li>
</ul>
<h4 id="node-和-npm-1"><a href="#node-和-npm-1" class="headerlink" title="node 和 npm"></a>node 和 npm</h4><p>首先，您的 windows server 需要 node 和 npm。最佳方式是用 <a href="http://chocolatey.org/">chocolately</a> 使用 <a href="http://chocolatey.org/packages/nodejs.install">nodejs.install</a> 包 。我发现在系统上的 path 变量没有设置正确；确保你能通过命令行运行 node/npm。如果你需要设置 path 变量，就用“setx PATH “%PATH%;C:\Program Files\nodejs””。</p>
<p>你也可以直接通过<a href="https://nodejs.org/">NodeJS</a> 安装，这可以为你设置path 变量。</p>
<blockquote>
<p>译者注：chocolately 和 scoop 都是 windows 下的包管理软件，译者使用的是 scoop。</p>
</blockquote>
<h4 id="更新服务器上的代码"><a href="#更新服务器上的代码" class="headerlink" title="更新服务器上的代码"></a>更新服务器上的代码</h4><p>在您的本地机器或直接在服务器上，去获取您服务器上的代码，您可以跟着在<a href="https://hubot.github.com/docs/">官方文档</a>上的操作指南。如果您本地构建，推送您的hubot到Github并且克隆仓库到您的服务器上。不要克隆这标准的<a href="http://github.com/github/hubot">github/hubot repository</a>，确保您用 Yo Generator 去构建您自己的 hubot。</p>
<h4 id="设置环境变量"><a href="#设置环境变量" class="headerlink" title="设置环境变量"></a>设置环境变量</h4><p>您会想设置您的 hubot 环境变量，在它运行的服务器上。您可以实现这个通过打开一个有管理员权限的 PowerShell 并且键入如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[Environment]::SetEnvironmentVariable(&quot;HUBOT_ADAPTER&quot;, &quot;Campfire&quot;, &quot;Machine&quot;)</span><br></pre></td></tr></table></figure>

<p>这相当于去系统菜单 -&gt; 选择高级系统设置 -&gt; 环境变量并且添加一个新的系统变量叫 HUBOT_ADAPTER，值为 Campfire。</p>
<h4 id="启动、停止和重启-hubot-1"><a href="#启动、停止和重启-hubot-1" class="headerlink" title="启动、停止和重启 hubot"></a>启动、停止和重启 hubot</h4><p>每个hubot安装有一个 <code>bin/hubot</code> 脚本去处理hubot的启动。您可以在您的 hubot 的文件夹下直接执行以下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.\bin\hubot –adapter campfire</span><br></pre></td></tr></table></figure>

<p>不过，如果您手动调用，则存在一些问题。</p>
<ul>
<li>你断开连接，hubot 也挂掉</li>
<li>hubot 因为某些原因挂掉，不会重启</li>
<li>hubot 不开机自启</li>
</ul>
<p>解决这些，您可能想创建一个您将从您的hubot路径调用的 .ps1 文件，用您喜欢的名字。<a href="https://hubot.github.com/_submodules/hubot/examples/hubot-start.ps1">此</a><code>examples</code>目录中有此文件的副本。它应包含以下内容：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Write-Host &quot;Starting Hubot Watcher&quot;</span><br><span class="line">While (1)</span><br><span class="line">&#123;</span><br><span class="line">    Write-Host &quot;Starting Hubot&quot;</span><br><span class="line">    Start-Process powershell -ArgumentList &quot;.\bin\hubot –adapter slack&quot; -wait</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果您使用 .ps1 文件来运行 hubot，记得允许本地未签名的 PowerShell 脚本。在一个管理员权限的 PowerShell 窗口运行下面的命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Set-ExecutionPolicy RemoteSigned</span><br></pre></td></tr></table></figure>

<p>如果您想用一些其它的方式去启动您的进程，您可以设置这个 .ps1 文件为一个预启动项。</p>
<h4 id="扩充文档"><a href="#扩充文档" class="headerlink" title="扩充文档"></a>扩充文档</h4><p>还不够完整，感谢您，<a href="https://github.com/github/hubot/pull/new/master">帮助贡献提交一个 pull request？</a></p>
<h3 id="部署到-Azure"><a href="#部署到-Azure" class="headerlink" title="部署到 Azure"></a>部署到 Azure</h3><p>如果你一直跟随着<a href="https://hubot.github.com/docs/">本文档</a>到现在。是时候部署了，这样您就可以在本地机器之外使用它。<a href="http://azure.microsoft.com/">Azure</a>是部署 hubot 的一种方式，是 Heroku 的替代方案。</p>
<p>按照hubot的初始说明进行操作后，您将需要通过npm安装azure-cli。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ npm install -g azure-cli</span><br></pre></td></tr></table></figure>

<p>在新的 hubot 目录中，请确保您创建了 git 仓库，并且您代码已经 commit：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git init</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git add .</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git commit -m <span class="string">&quot;Initial commit&quot;</span></span></span><br></pre></td></tr></table></figure>

<p>然后，为您的 hubot 创建一个 <a href="https://help.github.com/articles/create-a-repo/">Github repository</a>。Azure 就可以从这个 git 仓库，而不是直接从您的开发机器拉取代码了。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git remote add origin _your GitHub repo_</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git push -u origin master</span></span><br></pre></td></tr></table></figure>

<p>一旦您拥有了您的 Github 仓库，创建一个 Azure 网站链接到您的仓库。在 Azure，创建一个网站并且选择源码控制。当它询问“您的源码控制在哪里”，选择 Github 并且链接这个网站到您在上一步创建的 git 仓库。如果你下载过 Azure PowerShell 模块，你可以通过PowerShell 做这些。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ $creds = Get-Credential</span><br><span class="line">$ New-AzureWebsite mynewhubot -github -githubrepository yourgithubaccount/yourhubotreponame -githubcredentials $creds</span><br></pre></td></tr></table></figure>

<p>一旦您完成了这个，Azure 将在您任何时间推送代码到 Github 部署您的网站。不过您的 hubot 还不能正常运行。下一步，您需要您配置部署， 告诉 Azure 如何运行hubot。</p>
<p>首先，运行下面的命令去添加 <code>deploy.cmd</code> 到您的hubot路径。这是 Azure 用来知道如何部署 node 应用程序的文件。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> azure site deploymentscript --node</span></span><br></pre></td></tr></table></figure>

<p>然后，编辑此文件并查找为您提供步骤 1、2 和 3 的部分。您将添加第 4 步：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">:: 4. Create Hubot file with a coffee extension</span><br><span class="line">copy /Y &quot;%DEPLOYMENT_TARGET%\node_modules\hubot\bin\hubot&quot; &quot;%DEPLOYMENT_TARGET%\node_modules\hubot\bin\hubot.coffee&quot;</span><br></pre></td></tr></table></figure>

<p>现在，在hubot的根路径下创建一个新文件叫<code>server.js</code>，并添加下列两行：</p>
<figure class="highlight coffee"><table><tr><td class="code"><pre><span class="line"><span class="built_in">require</span>(<span class="string">&#x27;coffee-script/register&#x27;</span>);</span><br><span class="line"><span class="built_in">module</span>.<span class="built_in">exports</span> = <span class="built_in">require</span>(<span class="string">&#x27;hubot/bin/hubot.coffee&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>最后，您需要添加环境变量到网站去确保它能够运行。下面的配置，您也可以通过图像界面来配置，或者用 Azure PowerShell 命令行，如下所示（示例显示：适配器为slack， 网站名称为mynewhubot）。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ $settings = New-Object Hashtable</span><br><span class="line">$ $settings[&quot;HUBOT_ADAPTER&quot;] = &quot;Slack&quot;</span><br><span class="line">$ $settings[&quot;HUBOT_SLACK_TOKEN&quot;] = &quot;yourslackapikey&quot;</span><br><span class="line">$ Set-AzureWebsite -AppSettings $settings mynewhubot</span><br></pre></td></tr></table></figure>

<p>Commit 你的改变在git 仓库，并推送到Github，Azure 将自动获取改变并且部署到网站。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git commit -m &quot;Add Azure settings for hubot&quot;</span><br><span class="line">$ git push</span><br></pre></td></tr></table></figure>

<p>Azure 提供了一个市场，您可以在其中使用 Redis Labs 提供的 Redis Cloud 使用默认的 heroku-redis-brain。或者，要添加 Azure 存储大脑，您需要创建 Azure 存储帐户和帐户密钥。然后您可以在您的 hubot 根目录中执行以下操作。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> npm install hubot-azure-scripts --save</span></span><br></pre></td></tr></table></figure>

<p>然后 <code>external-scripts.json</code> 中添加以下行以及其它外部脚本</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;hubot-azure-scripts/brain/storage-blob-brain&quot;</span><br></pre></td></tr></table></figure>

<p>最后，在您的网站中再添加两个环境变量。您可以通过图形界面或以下PowerShell命令做到这一点。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ $settings = New-Object Hashtable</span><br><span class="line">$ $settings[&quot;HUBOT_BRAIN_AZURE_STORAGE_ACCOUNT&quot;] = &quot;your Azure storage account&quot;</span><br><span class="line">$ $settings[&quot;HUBOT_BRAIN_AZURE_STORAGE_ACCESS_KEY&quot;] = &quot;your Azure storage account key&quot;</span><br><span class="line">$ Set-AzureWebsite -AppSettings $settings mynewhubot</span><br></pre></td></tr></table></figure>

<p>现在任何需要大脑的脚本都可以运行。您应该查找其他脚本或通过查看<a href="https://hubot.github.com/docs/scripting/">文档</a>编写自己的脚本。 Hubot 的所有普通脚本都与 Azure 上的托管 hubot 兼容。</p>
<h4 id="故障排除提示和技巧"><a href="#故障排除提示和技巧" class="headerlink" title="故障排除提示和技巧"></a>故障排除提示和技巧</h4><p>由于 Azure 基于 Windows，您可能会遇到路径长度问题。要解决此问题，您可以将环境变量 <code>IN_PLACE_DEPLOYMENT</code> 设置为 1，并使用<a href="https://github.com/felixrieseberg/azure-npm3">自定义部署脚本来利用 NPM3</a> 和 flat 模块安装。</p>
<p>如果使用 Azure 的免费 tier，还可以添加部署后步骤，通过使用诸如 <code>startup.sh</code> 之类的脚本（相对于 src 目录）设置环境变量 <code>POST_DEPLOYMENT_ACTION</code> 来在启动时 ping 服务器。</p>
<p>启动脚本示例：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">let retrys=0</span><br><span class="line">while : ; do</span><br><span class="line">    STATUSCODE=$(curl --silent --output /dev/stderr --write-out &quot;%&#123;http_code&#125;&quot; https://$&#123;WEBSITE_SITE_NAME&#125;.azurewebsites.net/heroku/keepalive)</span><br><span class="line">    echo $STATUSCODE</span><br><span class="line">    [[ $retrys -ne 5 ]] || break</span><br><span class="line">    echo $retrys</span><br><span class="line">    ((retrys++))</span><br><span class="line">    [[ $STATUSCODE -ne 200 ]] || break</span><br><span class="line">done</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>信息技术</category>
      </categories>
      <tags>
        <tag>hubot</tag>
        <tag>chatops</tag>
      </tags>
  </entry>
</search>
